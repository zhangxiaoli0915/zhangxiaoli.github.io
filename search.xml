<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack 4 源码主流程分析（十四）：webpack 优化</title>
      <link href="/385.html"/>
      <url>/385.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><p>前面一至十一章，介绍了在 <code>development</code> 的模式下，整个完整了构建主流程。在了解构建流程的基础上，本章整理一些与 <code>webpack</code> 优化相关的知识点。</p><h2 id="production-模式"><a href="#production-模式" class="headerlink" title="production 模式"></a>production 模式</h2><p>我们参考 <code>production</code> 模式里，里面已经做了大部分的优化，如压缩，<code>Scope Hoisting</code>， <code>tree-shaking</code> 等给予我们启发，接下来具体分析各个点。</p><h3 id="production-模式启用的插件"><a href="#production-模式启用的插件" class="headerlink" title="production 模式启用的插件"></a>production 模式启用的插件</h3><ul><li><code>FlagDependencyUsagePlugin</code><ul><li>触发时机：<code>compilation.hooks.optimizeDependencies</code></li><li>功能：标记模块导出中被使用的导出，存在 <code>module.usedExports</code> 里。用于 <code>Tree shaking</code>。</li><li>对应配置项：<code>optimization.usedExports:true</code></li></ul></li><li><code>FlagIncludedChunksPlugin</code><ul><li>触发时机：<code>compilation.hooks.optimizeChunkId</code></li><li>功能：给每个 <code>chunk</code> 添加了 <code>ids</code>，用于判断避免加载不必要的 <code>chunk</code></li></ul></li><li><code>ModuleConcatenationPlugin</code><ul><li>触发时机：<code>compilation.hooks.optimizeChunkModules</code></li><li>功能：使用 <code>esm</code> 语法可以作用域提升(<code>Scope Hoisting</code>)或预编译所有模块到一个闭包中，提升代码在浏览器中的执行速度</li><li>对应配置项：<code>optimization.concatenateModules:true</code></li></ul></li><li><code>NoEmitOnErrorsPlugin</code><ul><li>触发时机：<code>compiler.hooks.shouldEmit</code>，<code>compilation.hooks.shouldRecord</code></li><li>功能：如果在 <code>compilation</code> 编译时有 <code>error</code>，则不执行 <code>Record</code> 相关的钩子，并且抛错和不编译资源</li></ul></li><li><code>OccurrenceOrderModuleIdsPlugin</code>，<code>OccurrenceOrderChunkIdsPlugin</code><ul><li>注意不是<a href="https://webpack.js.org/configuration/mode/#root" target="_blank" rel="noopener">文档</a>写的 <code>OccurrenceOrderPlugin</code>，这个没用</li><li>触发时机：<code>compilation.hooks.optimizeModuleOrder</code>，<code>compilation.hooks.optimizeChunkOrder</code></li><li>功能：根据模块初始调用次数或者总调用次数排序（<a href="https://webpack.docschina.org/configuration/optimization/#optimization-moduleids" target="_blank" rel="noopener">配置</a>），这样在后面分配 <code>ID</code> 的时候常被调用 <code>ID</code> 就靠前，除此之外，还可以让 <code>id</code> 为路径，<code>hash</code> 等。</li><li>对应配置项：<code>optimization.occurrenceOrder</code>，<code>optimization.chunkIds</code>，<code>optimization.moduleIds</code></li></ul></li><li><code>SideEffectsFlagPlugin</code><ul><li>触发时机：<code>normalModuleFactory.hooks.module</code>，<code>compilation.hooks.optimizeDependencies</code></li><li>功能：<ul><li><code>normalModuleFactory.hooks.module</code> 钩子里读取 <code>package.json</code> 里的 <code>sideEffects</code> 字段和读取 <code>module.rule</code> 里的 <code>sideEffects</code> 赋给 <code>module.factoryMeta</code>（纯的 <code>ES2015</code> 模块)；</li><li><code>compilation.hooks.optimizeDependencies</code> 钩子里根据 <code>sideEffects</code> 配置，删除未用到的 <code>export</code> 导出</li></ul></li><li>对应配置项：<code>optimization.sideEffects:true</code>（默认）</li></ul></li><li><code>TerserPlugin</code><ul><li>触发时机：<code>template.hooks.hashForChunk</code>，<code>compilation.hooks.optimizeChunkAssets</code></li><li>功能：<ul><li>在 <code>template.hooks.hashForChunk</code> 钩子即在 <code>chunks</code> 生成 <code>hash</code> 阶段会把压缩相关的信息也打入到里面</li><li>在 <code>compilation.hooks.optimizeChunkAssets</code> 钩子触发资源压缩事件</li></ul></li><li>对应配置项：<ul><li><code>optimization.minimize</code> 是否开启压缩</li><li><code>optimization.minimizer</code> 定制 <code>Terser</code></li></ul></li></ul></li></ul><p>另：<code>development</code> 模式单独启用的插件：</p><ul><li><code>NamedChunksPlugin</code><ul><li>触发时机：<code>compilation.hooks.beforeChunkIds</code></li><li>功能：以名称固化 <code>chunk id</code></li><li>对应配置项：<code>optimization.chunkIds</code></li></ul></li><li><code>NamedModulesPlugin</code><ul><li>触发时机：<code>compilation.hooks.beforeModuleIds</code></li><li>功能：以名称固化 <code>module id</code></li><li>对应配置项：<code>optimization.moduleIds</code></li></ul></li></ul><h2 id="持久化缓存"><a href="#持久化缓存" class="headerlink" title="持久化缓存"></a>持久化缓存</h2><blockquote><p>在更新部署页面资源时，无论是先部署页面，还是先部署其他静态资源，都会因为新老资源替换后的缓存原因，或者部署间隔原因，都会导致资源不对应而引起页面错误。</p></blockquote><p>持久化缓存方案就是在各静态资源的名字后面加唯一的 <code>hash</code> 值，这样在每次修改文件后生成的不同的 <code>hash</code> 值，然后在增量式发布文件时，就可以避免覆盖掉之前旧的文件。获取到新文件的用户就可以访问新的资源，而浏览器有缓存等情况的用户则继续访问老资源，保证新老资源同时存在且互不影响不出错。</p><ul><li>对于 <code>html</code>：不开启缓存，把 <code>html</code> 放到单独的服务器上并关闭服务器的缓存，需要保证每次的 <code>html</code> 都为最新</li><li>对于 <code>js</code>，<code>css</code>，<code>img</code> 等其他静态资源：开启缓存，将静态资源上传到 <code>cdn</code>，对资源开启长期缓存，因为有唯一 <code>hash</code> 的缘故所以不会导致资源被覆盖，用户在初次访问可以将这些长效缓存下载到本地，然后在后续的访问可以直接从缓存里读，节约网络资源。</li></ul><h3 id="webpack-中的持久化缓存"><a href="#webpack-中的持久化缓存" class="headerlink" title="webpack 中的持久化缓存"></a>webpack 中的持久化缓存</h3><ul><li>对 <code>js</code> 使用 <code>chunkhash</code> ，对 <code>css</code> 应用 <code>mini-css-extract-plugin</code> 插件并使用 <code>contenthash</code></li><li>通过 <code>optimization.moduleIds</code> 属性设置 <code>module id</code><ul><li>开发环境 <code>moduleIds</code> 设为 <code>named</code> 即使用 <code>NamedModulesPlugin</code> （相对路径为 <code>key</code>）来固化 <code>module id</code>，</li><li>生产环境 <code>moduleIds</code> 设为 <code>hashed</code> 即使用 <code>HashedModuleIdsPlugin</code> （将路径转换为 <code>hash</code> 为 <code>key</code>）来固化 <code>module id</code>，保证在某一模块增删后，不会影响其他模块的 <code>module id</code></li></ul></li><li>通过 <code>optimization.chunkIds</code> 属性设置为 <code>named</code> 或 <code>optimization.namedChunks</code> 属性设置为 <code>true</code> （通过将 <code>chunk name</code> 复制到 <code>chunk id</code>）固化 <code>chunk id</code>，该属性会启用 <code>NamedChunksPlugin</code><ul><li><code>NamedChunksPlugin</code> 插件里可以自定义 <code>nameResolver</code> 设置 <code>name</code></li><li><code>splitChunks.cacheGroups[].name</code> 也可以设置 <code>chunk name</code></li><li><a href="https://webpack.js.org/api/module-methods/#magic-comments" target="_blank" rel="noopener">魔法注释</a>也可以设置：<code>import(/* webpackChunkName: &quot;my-chunk-name&quot; */ &#39;module&#39;)</code></li></ul></li><li>通过 <code>optimization.splitChunks</code> 属性抽离库 <code>vendor</code>，业务公共代码 <code>common</code></li><li>通过 <code>optimization.runtimeChunk</code> 属性抽离运行时 <code>runtime</code>，其中 <code>runtime</code> 也可以通过 <code>script-ext-html-webpack-plugin</code> 插件嵌入到 <code>html</code></li></ul><h2 id="Tree-Sharing"><a href="#Tree-Sharing" class="headerlink" title="Tree Sharing"></a>Tree Sharing</h2><p><code>Tree Sharing</code> 是一个术语，通常用于描述移除 <code>JavaScript</code> 上下文中的未引用代码(<code>dead-code</code>)。由 <a href="https://rollupjs.org/guide/en/" target="_blank" rel="noopener">rollup</a> 普及，在 <code>webpack</code> 里由 <code>TerserPlugin</code> 实现。</p><h3 id="tree-sharing-原理"><a href="#tree-sharing-原理" class="headerlink" title="tree-sharing 原理"></a>tree-sharing 原理</h3><ul><li><code>ES6</code> 的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码</li><li>分析程序流，判断哪些变量未被使用、引用，进而删除此代码</li></ul><p>如果我们引入的模块被标记为 <code>sideEffects: false</code>，只要它任意一个导出都没有被其他模块引用到，那么不管它是否真的有副作用，整个模块都会被完整的移除。</p><blockquote><p>“<code>side effect</code>(副作用)” 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 <code>export</code> 或多个 <code>export</code>。举例说明，例如 <code>polyfill</code>，它影响全局作用域，并且通常不提供 <code>export</code>。</p></blockquote><h3 id="启用-tree-shaking-需要满足"><a href="#启用-tree-shaking-需要满足" class="headerlink" title="启用 tree shaking 需要满足"></a>启用 <code>tree shaking</code> 需要满足</h3><ul><li>使用 <code>ES2015</code> 模块语法（即 <code>import</code> 和 <code>export</code>），目的是为了供程序静态分析</li><li>确保没有 <code>compiler</code> 将 <code>ES2015</code> 模块语法转换为 <code>CommonJS</code> 模块（设置 <code>babel.config.js</code> <code>presets: [[&#39;@babel/env&#39;, { modules: false }]]</code>）</li><li>在 <code>package.json</code> 或者 <code>module.rule</code> 设置 <code>sideEffects : false</code>，告诉 <code>webpack</code> 该项目或者该文件没有副作用</li><li>mode 选项设置为 <code>production</code>，其中会启用 <code>FlagDependencyUsagePlugin</code>，<code>TerserPlugin</code> 完成 <code>tree shaking</code></li></ul><h2 id="Scope-Hoisting"><a href="#Scope-Hoisting" class="headerlink" title="Scope Hoisting"></a>Scope Hoisting</h2><p><code>Scope Hoisting</code> 即 作用域提升，可以让 <code>webpack</code> 打包出来的代码文件更小，运行更快。</p><h3 id="Scope-Hoisting-优点"><a href="#Scope-Hoisting-优点" class="headerlink" title="Scope Hoisting 优点"></a>Scope Hoisting 优点</h3><ul><li>代码体积会变小，因为函数声明语句会产生大量代码</li><li>代码在运行时因为创建的函数作用域减少了，内存开销也随之变小</li></ul><h3 id="Scope-Hoisting-原理"><a href="#Scope-Hoisting-原理" class="headerlink" title="Scope Hoisting 原理"></a>Scope Hoisting 原理</h3><p><code>ES6</code> 的静态模块分析，分析出模块之间的依赖关系，按照引用顺序尽可能地把模块放到同一个函数作用域中，然后适当的重命名一些变量以防止变量名冲突。</p><blockquote><p>异步 <code>import()</code> 不会启用 <code>Scope Hoisting</code></p></blockquote><h3 id="启用-Scope-Hoisting-需要满足"><a href="#启用-Scope-Hoisting-需要满足" class="headerlink" title="启用 Scope Hoisting 需要满足"></a>启用 Scope Hoisting 需要满足</h3><ul><li>使用 <code>ES2015</code> 模块语法（即 <code>import</code> 和 <code>export</code>）</li><li><code>mode</code> 选项设置为 <code>production</code>，其中会启用 <code>ModuleConcatenationPlugin</code> 插件完成 <code>Scope Hoisting</code></li></ul><h2 id="一些插件"><a href="#一些插件" class="headerlink" title="一些插件"></a>一些插件</h2><p>以下列举部分我用过优化相关的插件及 <code>loader</code>：</p><ol><li><a href="https://github.com/amireh/happypack" target="_blank" rel="noopener">happypack</a> 多线程编译，加快编译速度</li><li><a href="https://github.com/nuxt/webpackbar" target="_blank" rel="noopener">webpackbar</a> 编译进度条</li><li><a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="noopener">mini-css-extract-plugin</a> 提取 <code>css</code> 样式到单独文件</li><li><a href="https://github.com/numical/style-ext-html-webpack-plugin" target="_blank" rel="noopener">style-ext-html-webpack-plugin</a> 增强 <code>HtmlWebpackPlugin</code>，将 <code>css</code> 内联到 <code>html</code> 里</li><li><a href="https://github.com/numical/script-ext-html-webpack-plugin" target="_blank" rel="noopener">script-ext-html-webpack-plugin</a> 增强 <code>HtmlWebpackPlugin</code>，将 <code>js</code> 内联到 <code>html</code> 里</li><li><a href="https://github.com/NMFR/optimize-css-assets-webpack-plugin" target="_blank" rel="noopener">optimize-css-assets-webpack-plugin</a> 使用<a href="http://github.com/ben-eb/cssnano" target="_blank" rel="noopener">cssnano</a>压缩优化 <code>css</code></li><li><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a> 模块分析</li><li><a href="https://github.com/webpack-contrib/url-loader" target="_blank" rel="noopener">url-loader</a> 将文件转换为 <code>DataURL</code>，减少请求数</li></ol><p>各插件随着时间推移，有的可能废弃，有的可能被更好的所替代，已社区流行为准。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>从 <code>webpack</code> 源码开始，到后面打包结果分析，<code>watch</code>， <code>webpack</code> 优化总结等，前前后后花了一个月的时间，但收获也颇多。由于对 <code>webpack</code> 底层有了认知，海量配置也清楚具体实现，不用死记硬背了；由于对 <code>webpack</code> 底层有了认知，所以遇到的各种构建问题都能定位到是构建的哪一步；由于对 <code>webpack</code> 底层有了认知，也能够很快速的根据业务写一些针对性的 <code>loader</code> 和 <code>plugin</code>；最重要的是通过对源码分析，大型工程的组织架构，扩展性，健壮性等给人带来一些新的思路和启发。</p><p>本系列到此结束，后续会不断的更新优化。对 <code>webpack</code> 源码的分析解除了我心中很多的构建相关的疑惑，整个人都升华了。所以每个人精力、时间都有限，选择做自己喜欢的事情，方为上策。</p><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（十三）：watch</title>
      <link href="/384.html"/>
      <url>/384.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><p>前面分析了 <code>webpack</code> 的普通主流程构建，另外，通过设置 <code>watch</code> 模式，<code>webpack</code> 可以监听文件变化，当它们修改后会重新编译。<a href="https://webpack.js.org/configuration/watch/#root" target="_blank" rel="noopener">文档</a></p><blockquote><p><code>webpack-dev-server</code> 和 <code>webpack-dev-middleware</code> 里 <code>Watch</code> 模式默认开启。</p></blockquote><p>接下来设置 <code>cli</code> 命令加上 <code>--watch</code> 之后 对 <code>watch</code> 模式下的主流程进行分析（<code>mode = development</code>）。</p><h2 id="初次构建"><a href="#初次构建" class="headerlink" title="初次构建"></a>初次构建</h2><h3 id="资源构建"><a href="#资源构建" class="headerlink" title="资源构建"></a>资源构建</h3><p>代码执行后，跟主流程类似，然后执行到之前文章介绍到的 <code>编译前的准备 -&gt; 回到 cli.js</code> 里，读取到 <code>options.watchOptions</code> 等 <code>watch</code> 配置后， 走 <code>compiler.watch</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">compiler.watch(watchOptions, compilerCallback);</span><br></pre></td></tr></table></figure><p>在 <code>complier</code> 里的 <code>watch</code> 方法里，<code>new</code> 一个 <code>Watching</code> 实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Watching(<span class="keyword">this</span>, watchOptions, handler); <span class="comment">//handler即compilerCallback</span></span><br></pre></td></tr></table></figure><p>来到文件 <code>Watching.js</code>，在 <code>Watching</code> 实例化的过程中，先对 <code>watchOptions</code> 进行了处理后，在 <code>compiler.readRecords</code> 的回调里执行 <code>_go</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...Watching.js</span></span><br><span class="line"><span class="keyword">this</span>._go();</span><br></pre></td></tr></table></figure><p><code>_go</code> 方法与 <code>Compiler</code> 里的 <code>run</code> 很类似。 在 <code>_go</code> 里，触发 <code>compiler.hooks</code>:<code>watchRun</code>，执行插件 <code>CachePlugin</code>，即 <code>CachePlugin</code> 里的 <code>this.watching = true</code>，在钩子 <code>watchRun</code> 回调里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Watching.js</span></span><br><span class="line"><span class="keyword">const</span> onCompiled = <span class="function">(<span class="params">err, compilation</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>.compiler.compile(onCompiled);</span><br></pre></td></tr></table></figure><p>与普通 <code>webpack</code> 构建一致，即执行 <code>compiler.compile</code> 开始构建，在资源构建结束后执行 <code>onCompiled</code>。</p><p><code>onCompiled</code> 方法与 <code>compiler.run</code> 里的 <code>onCompiled</code> 大致一致，不同点是所有回调由 <code>finalCallback</code> 改为 <code>_done</code>，并且将 <code>stats</code> 统计信息相关处理也放到了 <code>_done</code> 里，执行 <code>_done</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//... Watching.js</span></span><br><span class="line"><span class="keyword">this</span>.compiler.hooks.done.callAsync(stats, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.handler(<span class="literal">null</span>, stats); <span class="comment">// compilerCallback</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">    <span class="keyword">this</span>.watch(<span class="built_in">Array</span>.from(compilation.fileDependencies), <span class="built_in">Array</span>.from(compilation.contextDependencies), <span class="built_in">Array</span>.from(compilation.missingDependencies));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> cb <span class="keyword">of</span> <span class="keyword">this</span>.callbacks) cb();</span><br><span class="line">  <span class="keyword">this</span>.callbacks.length = <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在该方法里对 <code>stats</code> 设置后，先执行 <code>handler</code>（实际与 <code>finalCallback</code> 执行一致） 即 <code>compilerCallback</code>，在 <code>cli</code> 里打印出构建相关的信息。到此，初始化构建完毕。</p><h3 id="添加监听"><a href="#添加监听" class="headerlink" title="添加监听"></a>添加监听</h3><p>然后执行 <code>watch</code> 方法并传入在之前 <code>compilation.seal</code> 里 <code>this.summarizeDependencies</code> 方法里生成的 <code>this.fileDependencies, this.contextDependencies, this.missingDependencies</code> 这些需要监听的文件和目录。</p><p>在 <code>Watching</code> 的实例 <code>watch</code> 方法里仅仅执行 <code>this.compiler.watchFileSystem.watch</code>，<code>watchFileSystem</code> 即是在前文 <code>NodeEnvironmentPlugin</code> 里所设置的 <code>NodeWatchFileSystem</code> 的实例。</p><p>在 <code>NodeWatchFileSystem</code> 的实例 <code>watch</code> 方法里，先对参数进行了格式判断后，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NodeWatchFileSystem.js</span></span><br><span class="line"><span class="keyword">const</span> oldWatcher = <span class="keyword">this</span>.watcher;</span><br><span class="line"><span class="keyword">this</span>.watcher = <span class="keyword">new</span> Watchpack(options);</span><br></pre></td></tr></table></figure><p><code>this.watcher</code> 在 <code>NodeWatchFileSystem</code> 实例化的时候已经创建了一个 <code>Watchpack</code> 的实例，这里相当于重新创建了一个实例。</p><p>该 <code>Watchpack</code> 继承了 <code>events</code> 模块的 <code>EventEmitter</code>，所以接下来分别在 <code>this.watcher</code>（<code>Watchpack</code> 实例） 上注册了 <code>change</code>，<code>aggregated</code> 事件，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.watcher.watch(cachedFiles.concat(missing), cachedDirs.concat(missing), startTime);</span><br></pre></td></tr></table></figure><p>即执行 <code>watchpack</code> 的实例方法 <code>watch</code>，在方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...watchpack.js</span></span><br><span class="line"><span class="keyword">this</span>.fileWatchers = files.map(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._fileWatcher(file, watcherManager.watchFile(file, <span class="keyword">this</span>.watcherOptions, startTime));</span><br><span class="line">&#125;, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.dirWatchers = directories.map(<span class="function"><span class="keyword">function</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._dirWatcher(dir, watcherManager.watchDirectory(dir, <span class="keyword">this</span>.watcherOptions, startTime));</span><br><span class="line">&#125;, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这里<strong>循环</strong>对每一个 <code>file</code> 进行执行 <code>this._fileWatcher</code> 方法。</p><blockquote><p>一般情况的监听只会涉及 this._fileWatchers，目录类的 this._dirWatchers 会在 require.context 的情况下被监听。</p></blockquote><p>这里先执行 <code>watcherManager.watchFile</code>，在类 <code>WatcherManager</code> 的实例方法 <code>watchFile</code> 中执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watcherManager.js</span></span><br><span class="line"><span class="keyword">var</span> directory = path.dirname(p);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getDirectoryWatcher(directory, options).watch(p, startTime);</span><br></pre></td></tr></table></figure><p>获取到文件对应路径 <code>directory</code> 后（文件路径 -&gt; 目录路径），<code>this.getDirectoryWatcher</code> 里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...watcherManager.js</span></span><br><span class="line"><span class="keyword">var</span> key = directory + <span class="string">' '</span> + <span class="built_in">JSON</span>.stringify(options);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.directoryWatchers[key]) &#123;</span><br><span class="line">  <span class="keyword">this</span>.directoryWatchers[key] = <span class="keyword">new</span> DirectoryWatcher(directory, options);</span><br><span class="line">  <span class="keyword">this</span>.directoryWatchers[key].on(</span><br><span class="line">    <span class="string">'closed'</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>.directoryWatchers[key];</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.directoryWatchers[key];</span><br></pre></td></tr></table></figure><p><code>this.directoryWatchers</code> 是一个 <code>key</code> 为目录路径，<code>value</code> 为 <code>DirectoryWatcher</code> 实例的对象。</p><p>可见 <code>this.getDirectoryWatcher</code> 返回了一个参数为目录路径和配置的 <code>DirectoryWatcher</code> 实例。</p><p><code>DirectoryWatcher</code> 与 <code>Watchpack</code> 一样，也 继承了 <code>events</code> 模块的 <code>EventEmitter</code>，在实例化的过程中执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DirectoryWatcher.js</span></span><br><span class="line"><span class="keyword">this</span>.watcher = chokidar.watch(directoryPath, &#123;</span><br><span class="line">  ignoreInitial: <span class="literal">true</span>,</span><br><span class="line">  persistent: <span class="literal">true</span>,</span><br><span class="line">  followSymlinks: <span class="literal">false</span>,</span><br><span class="line">  depth: <span class="number">0</span>,</span><br><span class="line">  atomic: <span class="literal">false</span>,</span><br><span class="line">  alwaysStat: <span class="literal">true</span>,</span><br><span class="line">  ignorePermissionErrors: <span class="literal">true</span>,</span><br><span class="line">  ignored: options.ignored,</span><br><span class="line">  usePolling: options.poll ? <span class="literal">true</span> : <span class="literal">undefined</span>,</span><br><span class="line">  interval: interval, <span class="comment">// 即 options.poll 文件系统轮询的时间间隔，越大性能越好</span></span><br><span class="line">  binaryInterval: interval,</span><br><span class="line">  disableGlobbing: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>webpack</code> 采用 <code>npm</code> 包 <a href="https://github.com/paulmillr/chokidar" target="_blank" rel="noopener">chokidar</a> 来进行文件的监听，然后根据不同操作（增加，删除，修改等）绑定一些事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DirectoryWatcher.js</span></span><br><span class="line"><span class="keyword">this</span>.watcher.on(<span class="string">'add'</span>, <span class="keyword">this</span>.onFileAdded.bind(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">this</span>.watcher.on(<span class="string">'addDir'</span>, <span class="keyword">this</span>.onDirectoryAdded.bind(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">this</span>.watcher.on(<span class="string">'change'</span>, <span class="keyword">this</span>.onChange.bind(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">this</span>.watcher.on(<span class="string">'unlink'</span>, <span class="keyword">this</span>.onFileUnlinked.bind(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">this</span>.watcher.on(<span class="string">'unlinkDir'</span>, <span class="keyword">this</span>.onDirectoryUnlinked.bind(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">this</span>.watcher.on(<span class="string">'error'</span>, <span class="keyword">this</span>.onWatcherError.bind(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure><p>这些事件是挂载在 <code>DirectoryWatcher</code> 类的原型方法上。然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DirectoryWatcher.js</span></span><br><span class="line"><span class="keyword">this</span>.doInitialScan();</span><br></pre></td></tr></table></figure><p>即执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DirectoryWatcher.js</span></span><br><span class="line">fs.readdir(</span><br><span class="line">  <span class="keyword">this</span>.path,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err, items</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">async</span>.forEach(</span><br><span class="line">      items,</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">item, callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> itemPath = path.join(<span class="keyword">this</span>.path, item);</span><br><span class="line">        fs.stat(</span><br><span class="line">          itemPath,</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">err2, stat</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (stat.isFile()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (!<span class="keyword">this</span>.files[itemPath]) <span class="keyword">this</span>.setFileTime(itemPath, +stat.mtime || +stat.ctime || <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stat.isDirectory()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (!<span class="keyword">this</span>.directories[itemPath]) <span class="keyword">this</span>.setDirectory(itemPath, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            callback();</span><br><span class="line">          &#125;.bind(<span class="keyword">this</span>)</span><br><span class="line">        );</span><br><span class="line">      &#125;.bind(<span class="keyword">this</span>),</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initialScan = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.initialScanRemoved = <span class="literal">null</span>;</span><br><span class="line">      &#125;.bind(<span class="keyword">this</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>即读取该 <code>path</code>（上文对应的文件对应文件夹路径 <code>directory</code>）下的所有文件及文件夹，如果是文件则执行 <code>this.setFileTime</code>，在该方法里根据是否是首次 <code>watch</code> 来收集该文件的修改时间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DirectoryWatcher.js</span></span><br><span class="line"><span class="keyword">this</span>.files[filePath] = [initial ? <span class="built_in">Math</span>.min(now, mtime) : now, mtime];</span><br></pre></td></tr></table></figure><p>如果是文件夹则执行 <code>this.setDirectory</code> 记录所有子路径。</p><p>因为 <code>fs.readdir</code> 为异步，所以 <code>fs.readdir</code> 的回调里先不执行，转而先执行 <code>this.getDirectoryWatcher(directory, options).watch(p, startTime)</code> 的 <code>watch</code> 方法，方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...DirectoryWatcher.js</span></span><br><span class="line"><span class="keyword">var</span> watcher = <span class="keyword">new</span> Watcher(<span class="keyword">this</span>, filePath, startTime);</span><br></pre></td></tr></table></figure><p>类 <code>Watcher</code> 依旧继承了 <code>events</code> 模块的 <code>EventEmitter</code>。这里实例化了一个 <code>watcher</code>，然后订阅了他的 <code>close</code> 方法后，将该 <code>watcher</code> <code>push</code> 到 <code>this.watchers</code>，然后返回一个 <code>watcher</code>，即执行 <code>watcherManager.watchFile(file, this.watcherOptions, startTime)</code> 返回了一个 <code>watcher</code>。然后回到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...DirectoryWatcher.js</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>._fileWatcher(file, watcherManager.watchFile(file, <span class="keyword">this</span>.watcherOptions, startTime));</span><br></pre></td></tr></table></figure><p>执行 <code>this._fileWatcher</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">watcher.on(</span><br><span class="line">  <span class="string">'change'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">mtime, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._onChange(file, mtime, file, type);</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>)</span><br><span class="line">);</span><br><span class="line">watcher.on(</span><br><span class="line">  <span class="string">'remove'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._onRemove(file, file, type);</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> watcher;</span><br></pre></td></tr></table></figure><p>即给对应的 <code>watcher</code> 订阅了 <code>change</code> 和 <code>remove</code> 事件。最终 <code>this.fileWatchers</code> 得到一个 <code>watcher</code> 数组。</p><p>然后回到 <code>NodeWatchFileSystem</code> 实例的 <code>watch</code> 方法执行 <code>oldWatcher.close()</code> 删除旧的 <code>Watchpack</code> 实例。</p><p>然后回到 <code>_done</code> 里，这一轮代码执行结束。</p><p>然后转而执行之前在 <code>doInitialScan</code> 里的 <code>fs.readdir</code> 的异步回调，收集文件修改时间（前文已解释），到此 <code>webpack watch</code> 的初次构建结束，文件正在被监听。</p><h2 id="修改文件触发监听"><a href="#修改文件触发监听" class="headerlink" title="修改文件触发监听"></a>修改文件触发监听</h2><p>修改文件后，触发 <code>chokidar</code> 的 <code>change</code> 事件，即对应路径在 <code>DirectoryWatcher</code> 实例化里设置的 <code>onChange</code> 事件，在方法里对 <code>path</code> 进行验证后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setFileTime(filePath, mtime, <span class="literal">false</span>, <span class="string">'change'</span>);</span><br></pre></td></tr></table></figure><p>再次调用了 <code>setFileTime</code> 方法。在方法里更新 <code>this.files[filePath]</code> 里对应的最新修改时间后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DirectoryWatcher.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.watchers[withoutCase(filePath)]) &#123;</span><br><span class="line">  <span class="keyword">this</span>.watchers[withoutCase(filePath)].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">w</span>) </span>&#123;</span><br><span class="line">    w.emit(<span class="string">'change'</span>, mtime, type);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断该文件是否在 <code>this.watchers</code> 即在被监听之列后，对该文件的每一个 <code>watcher</code> 触发其 <code>change</code> 事件，即执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchpack.js</span></span><br><span class="line"><span class="keyword">this</span>._onChange(file, mtime, file, type);</span><br></pre></td></tr></table></figure><p>方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchpack.js</span></span><br><span class="line"><span class="keyword">this</span>.emit(<span class="string">'change'</span>, file, mtime);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.aggregateTimeout) clearTimeout(<span class="keyword">this</span>.aggregateTimeout);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.aggregatedChanges.indexOf(item) &lt; <span class="number">0</span>) <span class="keyword">this</span>.aggregatedChanges.push(item);</span><br><span class="line"><span class="keyword">this</span>.aggregateTimeout = setTimeout(<span class="keyword">this</span>._onTimeout, <span class="keyword">this</span>.options.aggregateTimeout);</span><br></pre></td></tr></table></figure><p><code>this.emit(&#39;change&#39;, file, mtime)</code> 用于触发 <code>this.compiler.watchFileSystem.watch</code> 里的回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Watching.js</span></span><br><span class="line"><span class="keyword">this</span>.compiler.hooks.invalid.call(fileName, changeTime);</span><br></pre></td></tr></table></figure><p>然后剩下的部分是一个标准的<a href="https://blog.flqin.com/325.html">函数防抖(debounce)</a>，通过设置配置项 <code>options.aggregateTimeout</code> 可以设置间隔时间，间隔时间越长，性能越好。</p><p>执行 <code>this._onTimeout</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchpack.js</span></span><br><span class="line"><span class="keyword">this</span>.emit(<span class="string">'aggregated'</span>, changes, removals);</span><br></pre></td></tr></table></figure><p>主要作用触发 <code>aggregated</code> 事件即在 <code>NodeWatchFileSystem</code> 里注册，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NodeWatchFileSystem.js</span></span><br><span class="line"><span class="keyword">const</span> times = objectToMap(<span class="keyword">this</span>.watcher.getTimes());</span><br></pre></td></tr></table></figure><p>得到 <code>times</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  //...map结构</span><br><span class="line">  0: &#123;</span><br><span class="line">    "key": "/Users/github/webpack-demo/src/a.js",</span><br><span class="line">    "value": "1578382937093"</span><br><span class="line">  &#125;,</span><br><span class="line">  1: &#123;</span><br><span class="line">    "key": "/Users/github/webpack-demo/src/a.js",</span><br><span class="line">    "value": "1578382937093"</span><br><span class="line">  &#125;,</span><br><span class="line">  2: &#123;</span><br><span class="line">    "key": "/Users/github/webpack-demo/src/a.js",</span><br><span class="line">    "value": "1578382937093"</span><br><span class="line">  &#125;,</span><br><span class="line">  3: &#123;</span><br><span class="line">    "key": "/Users/github/webpack-demo/src/a.js",</span><br><span class="line">    "value": "1578382937093"</span><br><span class="line">  &#125;,</span><br><span class="line">  4: &#123;</span><br><span class="line">    "key": "/Users/github/webpack-demo/src/a.js",</span><br><span class="line">    "value": "1578382937093"</span><br><span class="line">  &#125;,</span><br><span class="line">  5: &#123;</span><br><span class="line">    "key": "/Users/github/webpack-demo/src/a.js",</span><br><span class="line">    "value": "1578382937093"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到每个文件的最新修改时间后，执行回调 <code>callback</code>，即 <code>Watching.js</code> 的 <code>this.compiler.watchFileSystem.watch</code> 方法的倒数第二个参数方法，在方法里将 <code>fileTimestamps</code> 即 <code>times</code> 赋给 <code>this.compiler.fileTimestamps</code> 后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._invalidate();</span><br></pre></td></tr></table></figure><p>方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._go();</span><br></pre></td></tr></table></figure><p>开启新一轮的构建。</p><h2 id="watch-优化"><a href="#watch-优化" class="headerlink" title="watch 优化"></a>watch 优化</h2><p>在构建过程中，依旧从入口开始构建，但在 <code>moduleFactory.create</code> 的回调里（包括 <code>addModuleDependencies</code> 里的 <code>factory.create</code>），执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addModuleResult = <span class="keyword">this</span>.addModule(<span class="built_in">module</span>);</span><br></pre></td></tr></table></figure><p>该方法除了判断 <code>module</code> 已加载之外，还判断了如果在 <code>compilation</code> 的 <code>this.cache</code> 存在该模块的话，则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rebuild = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.fileTimestamps &amp;&amp; <span class="keyword">this</span>.contextTimestamps) &#123;</span><br><span class="line">  rebuild = cacheModule.needRebuild(<span class="keyword">this</span>.fileTimestamps, <span class="keyword">this</span>.contextTimestamps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法 <code>needRebuild</code> 里判断模块修改时间 <code>fileTimestamps.get(file)</code> 与 模块构建时间 <code>this.buildTimestamp</code>（在 <code>module.build</code> 时取得）的先后来决定是否需要重新构建模块，若修改时间大于构建时间，则需要 <code>rebuild</code>，否则跳过 <code>build</code> 这步直接执行 <code>afterBuild</code> 即递归解析构建依赖。这样在监听时只 <code>rebuild</code> 修改过的 <code>module</code> 可大大提升编译过程。</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（十二）：打包后文件解析</title>
      <link href="/383.html"/>
      <url>/383.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><p>以 <code>前言及总流程概览</code> 里的 <code>demo</code> 为例， 前七章分析了打包过程，现在来分析它打包后的文件。</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">'Src/b'</span>;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./c.js'</span>).then(<span class="function"><span class="params">m</span> =&gt;</span> m.sub(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">add(<span class="number">3</span>, <span class="number">2</span> + a);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mul &#125; <span class="keyword">from</span> <span class="string">'@fe_korey/test-loader?number=20!Src/e'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + mul(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addddd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/c.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mul &#125; <span class="keyword">from</span> <span class="string">'Src/d'</span>;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./b.js'</span>).then(<span class="function"><span class="params">m</span> =&gt;</span> m.add(<span class="number">200</span>, <span class="number">100</span>)); <span class="comment">//require.ensure() 是 webpack 特有的，已经被 import() 取代。</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b + mul(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/d.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> d = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    bundle: <span class="string">'./src/a.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'none'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span>,</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash:4].js'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'[name].[chunkhash:8].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      Src: path.resolve(__dirname, <span class="string">'src/'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'babel-loader'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//babel.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [<span class="string">'@babel/env'</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>@fe_korey/test-loader</code> 是一个测试 <code>loader</code>，该 <code>loader</code> 作用为代码里的字符串 <code>10000</code> 替换为传入的 <code>number</code>。</p><h2 id="打包结果文件"><a href="#打包结果文件" class="headerlink" title="打包结果文件"></a>打包结果文件</h2><p>根据项目配置及同步异步的关系，打包后一共生成两个文件：</p><ul><li><code>bundle.xxxx.js</code></li></ul><p>总代码：见 <a href="https://github.com/zhaoky/webpack-demo/tree/master/dist" target="_blank" rel="noopener">github</a></p><p>入口文件，该文件名根据配置：<code>entry</code> 及 <code>output.filename</code> 生成，里面包含 <code>webpack runtime</code> 代码和同步模块代码。</p><p>如若配置了 <code>html-webpack-plugin</code>，那么在生成的 <code>html</code> 里将只会引入此 <code>js</code> 文件。</p><ul><li><code>0.xxxxxxxx.js</code></li></ul><p>总代码：见 <a href="https://github.com/zhaoky/webpack-demo/tree/master/distt" target="_blank" rel="noopener">github</a></p><p>非入口文件，本例为异步 <code>chunk</code> 文件，该文件名根据配置： <code>output.chunkFilename</code>生成，里面包含异步模块代码。</p><h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><p>根据代码执行顺序来分析，<code>html</code> 文件只需引入了<code>bundle.xxxx.js</code>文件，则从该文件开始执行，如果有其他 <code>import</code> 后，会先跳到对应的 <code>module</code> 进行处理，即<strong>先序深度优先</strong>遍历算法递归该依赖树。</p><h3 id="bundle-主体结构"><a href="#bundle-主体结构" class="headerlink" title="bundle 主体结构"></a>bundle 主体结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//runtime代码</span></span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">'./node_modules/@fe_korey/test-loader/loader.js?number=20!./src/d.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...模块代码d</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'./src/a.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...模块代码a</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'./src/b.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...模块代码b</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>主体结构为一个自执行函数，函数体为 <code>runtime</code> 函数，参数为 <code>modules</code> 对象，各模块以 <code>key-value</code> 的形式一起存在该 <code>modules</code> 对象里。当前 <code>key</code> 为模块的路径，<code>value</code> 为包裹模块代码的一个函数。</p><h3 id="runtime-函数"><a href="#runtime-函数" class="headerlink" title="runtime 函数"></a>runtime 函数</h3><p><code>runtime</code> 指的是 <code>webpack</code> 的运行环境(具体作用就是模块解析, 加载) 和 模块信息清单（表现在 <code>jsonpScriptSrc</code> 方法里）。</p><p>配置项 <code>optimization.runtimeChunk</code> 可以设置 <code>webpack</code> 将 <code>runtime</code> 这部分代码单独打包。</p><h4 id="runtime-函数主体结构"><a href="#runtime-函数主体结构" class="headerlink" title="runtime 函数主体结构"></a>runtime 函数主体结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">modules</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置 script src  __webpack_require__.p 即为 output.publicPath 配置</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">jsonpScriptSrc</span>(<span class="params">chunkId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __webpack_require__.p + <span class="string">""</span> + (&#123;&#125;[chunkId]||chunkId) + <span class="string">"."</span> + &#123;<span class="string">"0"</span>:<span class="string">"d680ffbe"</span>&#125;[chunkId] + <span class="string">".js"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> installedChunks = &#123;<span class="string">"bundle"</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一堆挂载在__webpack_require__上的属性</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// jsonp 初始化</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">"./src/a.js"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开始执行"><a href="#开始执行" class="headerlink" title="开始执行"></a>开始执行</h3><p>代码开始执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> installedModules = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>初始化 <code>installedModules</code>，保存所有创建过的 <code>module</code>，用于缓存判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// undefined：chunk未加载, null: chunk通过prefetch/preload提前获取过</span></span><br><span class="line"><span class="comment">// Promise：chunk正在加载, 0：chunk加载完毕</span></span><br><span class="line"><span class="comment">// 数组: 结构为 [resolve Function, reject Function, Promise] 的数组, 代表 chunk 在处于加载中</span></span><br><span class="line"><span class="keyword">var</span> installedChunks = &#123;</span><br><span class="line">  bundle: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>installedChunks</code> 以 <code>key-value</code> 的形式，用于收集保存所有的 <code>chunk</code>，这里 <code>bundle</code> 就是指的当前 <code>chunk</code>，自然是已经加载好了的。</p><h3 id="webpack-require-属性"><a href="#webpack-require-属性" class="headerlink" title="__webpack_require__ 属性"></a><code>__webpack_require__</code> 属性</h3><p>然后定义了一堆 <code>__webpack_require__</code> 的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步处理</span></span><br><span class="line">__webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//后文单独分析</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即为传入的modules：各模块组成的对象</span></span><br><span class="line">__webpack_require__.m = modules;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即为installedModules：已经缓存的对象</span></span><br><span class="line">__webpack_require__.c = installedModules;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在exports对象上添加属性，即 增加导出</span></span><br><span class="line">__webpack_require__.d = <span class="function"><span class="keyword">function</span>(<span class="params">exports, name, getter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!__webpack_require__.o(exports, name)) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(exports, name, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">get</span>: getter &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在exports对象上添加 __esModule 属性，用于标识 es6 模块</span></span><br><span class="line">__webpack_require__.r = <span class="function"><span class="keyword">function</span>(<span class="params">exports</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(exports, <span class="built_in">Symbol</span>.toStringTag, &#123; <span class="attr">value</span>: <span class="string">'Module'</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(exports, <span class="string">'__esModule'</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个伪命名空间对象</span></span><br><span class="line">__webpack_require__.t = <span class="function"><span class="keyword">function</span>(<span class="params">value, mode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//没用上，解释暂时略过</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到 getDefaultExport，即通过 __esModule 属性判断是否是 es6 来确定对应的默认导出方法</span></span><br><span class="line">__webpack_require__.n = <span class="function"><span class="keyword">function</span>(<span class="params">module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> getter =</span><br><span class="line">    <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.__esModule</span><br><span class="line">      ? <span class="function"><span class="keyword">function</span> <span class="title">getDefault</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">module</span>[<span class="string">'default'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      : <span class="function"><span class="keyword">function</span> <span class="title">getModuleExports</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">module</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">  __webpack_require__.d(getter, <span class="string">'a'</span>, getter);</span><br><span class="line">  <span class="keyword">return</span> getter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 hasOwnProperty，即判断对象上是否有某一属性</span></span><br><span class="line">__webpack_require__.o = <span class="function"><span class="keyword">function</span>(<span class="params">object, property</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(object, property);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即为 publicPath，在output.publicPath配置而来</span></span><br><span class="line">__webpack_require__.p = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line">__webpack_require__.oe = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个属性的作用已经写在注释上面。</p><h3 id="jsonp-初始化"><a href="#jsonp-初始化" class="headerlink" title="jsonp 初始化"></a><code>jsonp</code> 初始化</h3><p>然后执行 <code>jsonp</code> 初始化:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonpArray = (<span class="built_in">window</span>[<span class="string">'webpackJsonp'</span>] = <span class="built_in">window</span>[<span class="string">'webpackJsonp'</span>] || []); <span class="comment">//初始化 window['webpackJsonp']对象</span></span><br><span class="line"><span class="keyword">var</span> oldJsonpFunction = jsonpArray.push.bind(jsonpArray); <span class="comment">// 暂存 push 方法</span></span><br><span class="line">jsonpArray.push = webpackJsonpCallback; <span class="comment">//重写 jsonpArray 的 push 方法为 webpackJsonpCallback</span></span><br><span class="line">jsonpArray = jsonpArray.slice(); <span class="comment">//拷贝 jsonpArray（不带 push 方法）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]); <span class="comment">//若入口文件加载前，chunks文件先加载了，遍历 jsonpArray 用 webpackJsonpCallback 执行</span></span><br><span class="line"><span class="keyword">var</span> parentJsonpFunction = oldJsonpFunction; <span class="comment">//旧的 push 方法存入 parentJsonpFunction</span></span><br></pre></td></tr></table></figure><p><code>jsonp</code> 初始化的主要作用就是给 <code>window[&#39;webpackJsonp&#39;]</code> 重写了 <code>push</code> 方法为 <code>webpackJsonpCallback</code> 。接着执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> __webpack_require__((__webpack_require__.s = <span class="string">'./src/a.js'</span>));</span><br></pre></td></tr></table></figure><p>由入口文件 <code>a</code> 开始，传入 <code>moduleID : &quot;./src/a.js&quot;</code>，执行方法 <code>__webpack_require__</code>。</p><h3 id="webpack-require"><a href="#webpack-require" class="headerlink" title="__webpack_require__"></a><code>__webpack_require__</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断该module是否已经被缓存到installedModules，如果有，则直接返回它的导出exports</span></span><br><span class="line">  <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义module并缓存</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = (installedModules[moduleId] = &#123;</span><br><span class="line">    i: moduleId,</span><br><span class="line">    l: <span class="literal">false</span>,</span><br><span class="line">    exports: &#123;&#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 执行module代码</span></span><br><span class="line">  modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标志module已经读取完成</span></span><br><span class="line">  <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__webpack_require__</code> 方法的主要作用就是创建缓存 <code>module</code> 后，执行该 <code>module</code> 的代码。其中 <code>modules</code> 即为上文所解释的各模块组成的对象。</p><h3 id="执行各同步模块代码"><a href="#执行各同步模块代码" class="headerlink" title="执行各同步模块代码"></a>执行各同步模块代码</h3><p><code>modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</code> 执行模块 <code>a</code> 的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块 a</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line">__webpack_require__.r(__webpack_exports__);</span><br><span class="line"><span class="keyword">var</span> Src_b__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">'./src/b.js'</span>);</span><br><span class="line"></span><br><span class="line">__webpack_require__</span><br><span class="line">  .e(<span class="number">0</span>)</span><br><span class="line">  .then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">'./src/c.js'</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.sub(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>(Src_b__WEBPACK_IMPORTED_MODULE_0__[<span class="string">'add'</span>])(<span class="number">3</span>, <span class="number">2</span> + a);</span><br></pre></td></tr></table></figure><p>代码里 <code>__webpack_require__(&#39;./src/b.js&#39;)</code> 会去执行模块 <code>b</code> 的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块 b</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line">__webpack_require__.r(__webpack_exports__);</span><br><span class="line">__webpack_require__.d(__webpack_exports__, <span class="string">'add'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> add;</span><br><span class="line">&#125;);</span><br><span class="line">__webpack_require__.d(__webpack_exports__, <span class="string">'addddd'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> addddd;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> _fe_korey_test_loader_number_20_Src_d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">'./node_modules/@fe_korey/test-loader/loader.js?number=20!./src/d.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + <span class="built_in">Object</span>(_fe_korey_test_loader_number_20_Src_d__WEBPACK_IMPORTED_MODULE_0__[<span class="string">'mul'</span>])(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addddd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里在导出了两个方法后，去执行模块 <code>d</code> 的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块 d</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line">__webpack_require__.r(__webpack_exports__);</span><br><span class="line">__webpack_require__.d(__webpack_exports__, <span class="string">'mul'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mul;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块 <code>d</code> 代码导出了 <code>mul</code>。</p><h3 id="import-的处理"><a href="#import-的处理" class="headerlink" title="import() 的处理"></a>import() 的处理</h3><p>各自模块执行完后，回到模块 <code>a</code> 里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__</span><br><span class="line">  .e(<span class="number">0</span>)</span><br><span class="line">  .then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">'./src/c.js'</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.sub(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>该打包后的代码为<strong>动态加载</strong>，源代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./c.js'</span>).then(<span class="function"><span class="params">m</span> =&gt;</span> m.sub(<span class="number">2</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="webpack-require-e"><a href="#webpack-require-e" class="headerlink" title="__webpack_require__.e"></a><code>__webpack_require__.e</code></h4><p><code>__webpack_require__.e</code> 实现异步加载模块，方法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise队列，等待多个异步 chunk都加载完成才执行回调</span></span><br><span class="line"><span class="keyword">var</span> promises = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先判断是否加载过该 chunk</span></span><br><span class="line"><span class="keyword">var</span> installedChunkData = installedChunks[chunkId];</span><br><span class="line"><span class="keyword">if</span> (installedChunkData !== <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 0 means "already installed".</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// a Promise means "currently loading". 目标 chunk 正在加载，则将 promise push到 promises 数组</span></span><br><span class="line">  <span class="keyword">if</span> (installedChunkData) &#123;</span><br><span class="line">    promises.push(installedChunkData[<span class="number">2</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 新建一个Promise去异步加载目标chunk</span></span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      installedChunkData = installedChunks[chunkId] = [resolve, reject]; <span class="comment">//这里设置 installedChunks[chunkId]</span></span><br><span class="line">    &#125;);</span><br><span class="line">    promises.push((installedChunkData[<span class="number">2</span>] = promise)); <span class="comment">// installedChunks[chunkId]  = [resolve, reject, promise]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    <span class="keyword">var</span> onScriptComplete;</span><br><span class="line"></span><br><span class="line">    script.charset = <span class="string">'utf-8'</span>;</span><br><span class="line">    script.timeout = <span class="number">120</span>;</span><br><span class="line">    <span class="keyword">if</span> (__webpack_require__.nc) &#123;</span><br><span class="line">      script.setAttribute(<span class="string">'nonce'</span>, __webpack_require__.nc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置src</span></span><br><span class="line">    script.src = jsonpScriptSrc(chunkId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    <span class="comment">// 设置加载完成或错误的回调</span></span><br><span class="line">    onScriptComplete = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// avoid mem leaks in IE.</span></span><br><span class="line">      script.onerror = script.onload = <span class="literal">null</span>;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">      <span class="keyword">var</span> chunk = installedChunks[chunkId];</span><br><span class="line">      <span class="keyword">if</span> (chunk !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chunk) &#123;</span><br><span class="line">          <span class="keyword">var</span> errorType = event &amp;&amp; (event.type === <span class="string">'load'</span> ? <span class="string">'missing'</span> : event.type);</span><br><span class="line">          <span class="keyword">var</span> realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;</span><br><span class="line">          error.message = <span class="string">'Loading chunk '</span> + chunkId + <span class="string">' failed.\n('</span> + errorType + <span class="string">': '</span> + realSrc + <span class="string">')'</span>;</span><br><span class="line">          error.name = <span class="string">'ChunkLoadError'</span>;</span><br><span class="line">          error.type = errorType;</span><br><span class="line">          error.request = realSrc;</span><br><span class="line">          chunk[<span class="number">1</span>](error);</span><br><span class="line">        &#125;</span><br><span class="line">        installedChunks[chunkId] = <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置超时处理</span></span><br><span class="line">    <span class="keyword">var</span> timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      onScriptComplete(&#123; <span class="attr">type</span>: <span class="string">'timeout'</span>, <span class="attr">target</span>: script &#125;);</span><br><span class="line">    &#125;, <span class="number">120000</span>);</span><br><span class="line">    <span class="comment">//script标签的onload事件都是在外部js文件被加载完成并执行完成后（异步不算）才被触发</span></span><br><span class="line">    script.onerror = script.onload = onScriptComplete;</span><br><span class="line">    <span class="comment">// script标签加入文档</span></span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises);</span><br></pre></td></tr></table></figure><p>参数 <code>0</code> 为 <code>chunkId</code>，在方法 <code>__webpack_require__.e</code> 里，主要功能就是模拟 <code>jsonp</code> 去异步加载目标 <code>chunk</code> 文件 <code>0</code>，返回一个 <code>promise</code> 对象。</p><p>然后加载异步文件 <code>0.e3296d88.js</code> 并执行。</p><h3 id="加载非入口文件0-e3296d88-js"><a href="#加载非入口文件0-e3296d88-js" class="headerlink" title="加载非入口文件0.e3296d88.js"></a>加载非入口文件<code>0.e3296d88.js</code></h3><h4 id="非入口文件主体结构"><a href="#非入口文件主体结构" class="headerlink" title="非入口文件主体结构"></a>非入口文件主体结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">window</span>[<span class="string">'webpackJsonp'</span>] = <span class="built_in">window</span>[<span class="string">'webpackJsonp'</span>] || []).push([</span><br><span class="line">  [<span class="number">0</span>],</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'./src/c.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//模块 c</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'./src/d.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//模块 d</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>在模块加载后，就会立即执行的 <code>window[&#39;webpackJsonp&#39;].push()</code> 。由 <code>jsonp</code> 初始化可知， 即执行 <code>bundle</code> 文件里的 <code>webpackJsonpCallback</code> 方法。</p><h4 id="webpackJsonpCallback"><a href="#webpackJsonpCallback" class="headerlink" title="webpackJsonpCallback"></a>webpackJsonpCallback</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunkIds = data[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> moreModules = data[<span class="number">1</span>]; <span class="comment">//异步 chunk 的各模块组成的对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> moduleId,</span><br><span class="line">    chunkId,</span><br><span class="line">    i = <span class="number">0</span>,</span><br><span class="line">    resolves = [];</span><br><span class="line">  <span class="comment">// 这里收集 resolve 并将所有 chunkIds 标记为已加载</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; chunkIds.length; i++) &#123;</span><br><span class="line">    chunkId = chunkIds[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(installedChunks, chunkId) &amp;&amp; installedChunks[chunkId]) &#123;</span><br><span class="line">      resolves.push(installedChunks[chunkId][<span class="number">0</span>]); <span class="comment">//将 resolve push 到 resolves 数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    installedChunks[chunkId] = <span class="number">0</span>; <span class="comment">//标记为已加载</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历各模块组成的对象，将每个模块都加到 modules</span></span><br><span class="line">  <span class="keyword">for</span> (moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">      modules[moduleId] = moreModules[moduleId];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行保存的旧 push 方法，可能是 array.push (即 push 到 window.webpackJsonp)，也可能是前一个并行执行了 runtime 的 bundle 的 webpackJsonpCallback，即递归执行 webpackJsonpCallback，如多入口同时 import 同一个 module 的情况。</span></span><br><span class="line">  <span class="keyword">if</span> (parentJsonpFunction) parentJsonpFunction(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//循环触发 resolve 回调</span></span><br><span class="line">  <span class="keyword">while</span> (resolves.length) &#123;</span><br><span class="line">    resolves.shift()();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webpackJsonpCallback</code> 方法主要将异步的 <code>chunk</code> 里的所有模块都加到 <code>modules</code> 后，改变 <code>installedChunks[chunkId]</code> 的状态为 <code>0</code>（即已加载），然后执行之前创建的 <code>promise</code> 的 <code>resolve()</code>。</p><h4 id="执行-resolve-的回调-then-方法"><a href="#执行-resolve-的回调-then-方法" class="headerlink" title="执行 resolve 的回调 then 方法"></a>执行 resolve 的回调 then 方法</h4><p>回到模块 <code>a</code> 根据 <code>promise</code> 的定义，执行 <code>resolve</code> 后，就会去执行对应的 <code>then</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">'./src/c.js'</span>));</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>即执行模块 <code>c</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line">__webpack_require__.r(__webpack_exports__);</span><br><span class="line">__webpack_require__.d(__webpack_exports__, <span class="string">'sub'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sub;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> Src_d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">'./src/d.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">'./src/b.js'</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.add(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b + <span class="built_in">Object</span>(Src_d__WEBPACK_IMPORTED_MODULE_0__[<span class="string">'mul'</span>])(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure><p>模块 <code>c</code> 里引入了模块 <code>d</code>，这里的模块 <code>d</code> 与前文的模块 <code>d</code> 虽然是一样的，但由于用的 <code>loader</code> 不一样，所以会认为是两个不同的模块，故会再次加载，互不影响。这里模块 <code>d</code> 不在累述。</p><p>然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">'./src/b.js'</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.add(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>Promise.resolve</code> 方法允许调用时不带参数，直接返回一个<code>resolved</code> 状态的 <code>Promise</code> 对象。即执行 then 方法，即 <code>__webpack_require__.bind(null, &#39;./src/b.js&#39;)</code>。然后在 <code>__webpack_require__</code> 方法里判断缓存有模块 <code>b</code>，则直接返回模块 <code>b</code> 对应的 <code>exports</code>。到此异步加载完成。</p><p>根据微任务队列的先后顺序，先执行模块 <code>a</code> 的第二个 <code>then</code> 回调，然后执行模块 <code>c</code> 的第二个 <code>then</code> 回调，都执行完成后，执行加载完成回调 <code>onScriptComplete</code>。到此代码运行完成。</p><h2 id="异步加载小结"><a href="#异步加载小结" class="headerlink" title="异步加载小结"></a>异步加载小结</h2><p>再次梳理下异步加载的关键思路：</p><ol><li>通过 <code>__webpack_require__</code> 加载运行入口 <code>module</code></li><li>模块代码里遇到 import()即执行 <code>__webpack_require__.e</code> 加载异步 <code>chunk</code></li><li><code>__webpack_require__.e</code> 使用模拟 <code>jsonp</code> 的方式及创建 <code>script</code> 标签来加载异步 <code>chunk</code>，并为每个 <code>chunk</code> 创建一个 <code>promise</code></li><li>等到异步 <code>chunk</code> 被加载后，会执行 <code>window[&#39;webpackJsonp&#39;].push</code>，即 <code>webpackJsonpCallback</code> 方法</li><li><code>webpackJsonpCallback</code> 里将异步 <code>chunk</code> 里的 <code>module</code> 加入到 <code>modules</code>， 并触发前面创建 <code>promise</code> 的 <code>resolve</code> 回调，然后执行其 <code>then</code> 方法即 <code>__webpack_require__</code> 去加载新的 <code>module</code>。</li></ol><h2 id="扩展-使用-splitChunks-切割后的文件解析"><a href="#扩展-使用-splitChunks-切割后的文件解析" class="headerlink" title="扩展 使用 splitChunks 切割后的文件解析"></a>扩展 使用 splitChunks 切割后的文件解析</h2><p>demo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mul &#125; <span class="keyword">from</span> <span class="string">'./d'</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mul &#125; <span class="keyword">from</span> <span class="string">'./d'</span>;</span><br><span class="line"><span class="comment">// d.js为普通同步文件</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"entry"</span>: &#123;</span><br><span class="line">    <span class="attr">"bundle1"</span>: <span class="string">"./src/e.js"</span>,</span><br><span class="line">    <span class="attr">"bundle2"</span>: <span class="string">"./src/f.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"plugins"</span>: [new HtmlWebpackPlugin()],</span><br><span class="line">  //...</span><br><span class="line">  "optimization": &#123;</span><br><span class="line">    "splitChunks": &#123;</span><br><span class="line">      "chunks": "all",</span><br><span class="line">      "minSize": 0, //当模块小于这个值时，就不拆</span><br><span class="line">      "maxSize": 0, //当模块大于这个值时，尝试拆分</span><br><span class="line">      "minChunks": 1, //重复一次就打包</span><br><span class="line">      "name": true, //是否以cacheGroups中的filename作为文件名</span><br><span class="line">      "automaticNameDelimiter": "~", //打包的chunk名字连接符</span><br><span class="line">      "cacheGroups": &#123;</span><br><span class="line">        "default": &#123;</span><br><span class="line">          "chunks": "all",</span><br><span class="line">          "minChunks": 2,</span><br><span class="line">          "priority": -10</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入插件 <code>HtmlWebpackPlugin</code> 辅助分析。</p><p>打包后代码见 <a href="https://github.com/zhaoky/webpack-demo/tree/master/dist" target="_blank" rel="noopener">github</a>，以下只做关键点记录:</p><ul><li>html 会引入每个入口 <code>bundle</code> 生成的 <code>js</code> 和公共部分的 <code>js</code>：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"default~bundle1~bundle2.183bf5f4.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"bundle1.10ad.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"bundle2.c333.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>在 <code>jsonp</code> 初始化阶段，执行：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);</span><br></pre></td></tr></table></figure><p>和在 <code>webpackJsonpCallback</code> 方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parentJsonpFunction) parentJsonpFunction(data);</span><br></pre></td></tr></table></figure><p>可以保证无论页面先加载入口文件还是非入口文件，都可以将依赖 <code>module</code> 同步到各自的 <code>chunk</code> 里。</p><ul><li>两个入口文件 <code>bundle1.xxxx.js bundle2.xxxx.js</code> 的 <code>runtime</code> 代码里会多出一个新的变量 <code>deferredModules</code>：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deferredModules = [];</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">deferredModules.push([<span class="string">'./src/e.js'</span>, <span class="string">'default~bundle1~bundle2'</span>]);</span><br><span class="line"><span class="keyword">return</span> checkDeferredModules();</span><br></pre></td></tr></table></figure><p>该变量为一个数组，第一个变量是需要加载的 <code>module</code>，后面的变量就是要加载本 <code>module</code> 所需的其他依赖 <code>module</code>。然后在 <code>runtime</code> 的末尾执行：<code>return checkDeferredModules();</code></p><ul><li><code>checkDeferredModules</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkDeferredModules</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deferredModules.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> deferredModule = deferredModules[i];</span><br><span class="line">    <span class="keyword">var</span> fulfilled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; deferredModule.length; j++) &#123;</span><br><span class="line">      <span class="keyword">var</span> depId = deferredModule[j];</span><br><span class="line">      <span class="keyword">if</span> (installedChunks[depId] !== <span class="number">0</span>) fulfilled = <span class="literal">false</span>; <span class="comment">//判断依赖模块有没有加载过</span></span><br><span class="line">    <span class="keyword">if</span> (fulfilled) &#123;</span><br><span class="line">      deferredModules.splice(i--, <span class="number">1</span>);</span><br><span class="line">      result = __webpack_require__((__webpack_require__.s = deferredModule[<span class="number">0</span>])); <span class="comment">//如果所有依赖模块都加载了（即modules里有依赖模块），则就可以读取目标的module了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要检查依赖的 <code>module</code> 是否加载过，若都加载了则加载目标 <code>module</code>。</p><ul><li><code>webpackJsonpCallback</code> 格外代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">deferredModules.push.apply(deferredModules, executeModules || []);</span><br><span class="line"><span class="keyword">return</span> checkDeferredModules();</span><br></pre></td></tr></table></figure><p>该方法增加了这两句代码，用于在调用 <code>webpackJsonpCallback</code> 时（即 <code>window[&quot;webpackJsonp&quot;].push</code> 或 <code>webpackJsonpCallback(jsonpArray[i])</code>），有其他依赖的时候可以再去调用 <code>checkDeferredModules</code> 进行依赖检查。</p><h2 id="splitChunks-切割后加载小结"><a href="#splitChunks-切割后加载小结" class="headerlink" title="splitChunks 切割后加载小结"></a>splitChunks 切割后加载小结</h2><p>再次梳理下 <code>splitChunks</code> 切割后的关键思路：</p><ol><li>根据 <code>script</code> 标签先后顺序，<code>html</code> 先加载公共依赖 <code>default~bundle1~bundle2.xx.js</code>，即在 <code>window[&quot;webpackJsonp&quot;]</code> 里 <code>push</code> 了该 <code>module</code>。</li><li><code>html</code> 加载 <code>bundle1.js</code>，在 <code>jsonp</code> 初始化里调用 <code>webpackJsonpCallback(jsonpArray[i])</code> 将公共依赖模块加到 <code>modules</code> 里并改变其状态为已加载后，调用 <code>checkDeferredModules()</code>，但 <code>deferredModules</code> 为空，所以没有任何操作。</li><li>然后回到 <code>runtime</code> 里继续执行，将当前 <code>module</code> 和依赖 <code>module</code> <code>push</code> 到 <code>deferredModules</code> 里，再次调用 <code>checkDeferredModules</code>，此时判断各依赖模块状态均为已加载后，加载当期 <code>module</code>。</li><li><code>html</code> 加载 <code>bundle2</code> 文件，此后逻辑跟 <code>bundle1</code> 一致。</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（十一）：文件的生成</title>
      <link href="/382.html"/>
      <url>/382.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><h2 id="资源写入文件"><a href="#资源写入文件" class="headerlink" title="资源写入文件"></a>资源写入文件</h2><p>回到 <code>seal</code>。执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.summarizeDependencies();</span><br></pre></td></tr></table></figure><p>得到 <code>this.fileDependencies, this.contextDependencies, this.missingDependencies</code> 后，触发了一系列处理资源，优化资源的钩子之后，回到 <code>Compiler.js</code> 的 <code>compile</code> 里的 <code>compilation.seal</code> 回调，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.afterCompile.callAsync(compilation, err =&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> callback(<span class="literal">null</span>, compilation);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>该钩子会触发插件 <code>CachePlugin</code> 相关的事件，给 <code>compiler</code> 的属性 <code>_lastCompilationFileDependencies，_lastCompilationContextDependencies</code> 分别赋值 <code>fileDependencies，contextDependencies</code>。</p><h3 id="创建目标文件夹"><a href="#创建目标文件夹" class="headerlink" title="创建目标文件夹"></a>创建目标文件夹</h3><p>然后执行回调即 <code>onCompiled</code>，方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.emitAssets(compilation, err =&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>进入 <code>this.emitAssets</code>，<code>emitAssets</code> 负责的是构建资源输出的过程。在方法里触发了 <code>Compiler.hooks</code>:<code>emit</code>，在回调里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">outputPath = compilation.getPath(<span class="keyword">this</span>.outputPath); <span class="comment">// 获取资源输出的路径</span></span><br><span class="line"><span class="keyword">this</span>.outputFileSystem.mkdirp(outputPath, emitFiles); <span class="comment">// 递归创建输出目录并输出资源</span></span><br></pre></td></tr></table></figure><p><code>outputPath</code> 为配置里的 <code>output.path</code>，然后调用 <code>mkdirp</code> 创建文件夹。</p><h3 id="创建目标文件并写入"><a href="#创建目标文件并写入" class="headerlink" title="创建目标文件并写入"></a>创建目标文件并写入</h3><p>创建目标文件夹后，执行回调 <code>emitFiles</code>，在回调里通过 <code>asyncLib.forEachLimit</code> 并行执行对每个 <code>file</code> 资源文件进行路径拼接后，将每个 <code>source</code> 源码转换为 <code>buffer</code> 后（性能提升），写入真实路径的 <code>file</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">asyncLib.forEachLimit(</span><br><span class="line">  compilation.getAssets(),</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  (&#123; <span class="attr">name</span>: file, source &#125;, callback) =&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">const</span> writeOut = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">const</span> targetPath = <span class="keyword">this</span>.outputFileSystem.join(outputPath, targetFile); <span class="comment">// 路径拼接，得到真实路径</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.options.output.futureEmitAssets) &#123;</span><br><span class="line">        <span class="comment">//...判断重写入 及 gc释放内存（this.assets相关重写SizeOnlySource）</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> content = source.source(); <span class="comment">//source为 CachedSource 实例，content为得到的资源</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!Buffer.isBuffer(content)) &#123;</span><br><span class="line">          content = Buffer.from(content, <span class="string">'utf8'</span>); <span class="comment">//buffer转换，在node中提升性能</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...写入文件</span></span><br><span class="line">        <span class="keyword">this</span>.outputFileSystem.writeFile(targetPath, content, err =&gt; &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="keyword">this</span>.hooks.assetEmitted.callAsync(file, content, callback);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 若目标文件路径包含/或\，先创建文件夹再写入</span></span><br><span class="line">    <span class="keyword">if</span> (targetFile.match(<span class="regexp">/\/|\\/</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> dir = path.dirname(targetFile);</span><br><span class="line">      <span class="keyword">this</span>.outputFileSystem.mkdirp(<span class="keyword">this</span>.outputFileSystem.join(outputPath, dir), writeOut);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      writeOut();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 遍历完成的回调函数</span></span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="comment">//...回调</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> content = source.source();</span><br></pre></td></tr></table></figure><p><code>source</code> 为 <code>CachedSource</code> 实例，<code>source.source</code> 做了缓存判断，执行 <code>this._source.source</code>， <code>this._source</code> 为 <code>ConcatSource</code> 实例，该方法会遍历 <code>children</code>，如果子项不是字符串，则执行其 <code>source</code> 方法。</p><p>对于 <code>ReplaceSource</code> 实例来说，会执行其 <code>_replaceString</code> 方法，该方法里会循环处理替换在之前 <code>资源的构建 -&gt; 生成 chunk 资源 -&gt; chunkTemplate -&gt; 生成主体 chunk 代码 -&gt; 生成每个 module 代码</code> <code>push</code> 进去的 <code>replacements</code>，得到替换后的字符串，合并返回 <code>resultStr</code>。</p><p>所有文件都创建写入完成后然后执行回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.afterEmit.callAsync(compilation, err =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">  <span class="keyword">return</span> callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在回调里触发 <code>Compiler.afterEmit</code>:<code>hooks</code>，在回调里执行 <code>callback</code> 即 <code>this.emitAssets</code> 的回调，即执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">this</span>.emitRecords(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">const</span> stats = <span class="keyword">new</span> Stats(compilation);</span><br><span class="line">  stats.startTime = startTime;</span><br><span class="line">  stats.endTime = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">this</span>.hooks.done.callAsync(stats, err =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> finalCallback(err);</span><br><span class="line">    <span class="keyword">return</span> finalCallback(<span class="literal">null</span>, stats);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="设置-stats-并打印构建信息"><a href="#设置-stats-并打印构建信息" class="headerlink" title="设置 stats 并打印构建信息"></a>设置 stats 并打印构建信息</h2><p>执行 <code>this.emitRecords</code>，然后在其回调里设置相关 <code>stats</code>，然后在 <code>Compiler.done</code>:<code>hooks</code> 的回调里执行 <code>finalCallback</code>，即执行文件 <code>webpack-cli/bin/cli.js</code> 里的 <code>compiler.run</code> 的回调，即 <code>compilerCallback</code>。</p><p>方法里清除缓存之后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> statsString = stats.toString(outputOptions);</span><br><span class="line"><span class="keyword">const</span> delimiter = outputOptions.buildDelimiter ? <span class="string">`<span class="subst">$&#123;outputOptions.buildDelimiter&#125;</span>\n`</span> : <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span> (statsString) stdout.write(<span class="string">`<span class="subst">$&#123;statsString&#125;</span>\n<span class="subst">$&#123;delimiter&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>在 <code>cli</code> 里打印出构建相关的信息。至此，构建全部结束，下一章分析打包后的文件！</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>创建目标文件夹及文件并将资源写入；</li><li>写入的时候，会循环处理 <code>source</code> 中的 <code>ReplaceSource</code> 实例中的 <code>replacements</code>，将其替换为真实字符串；</li><li>设置 <code>stats</code> 并打印构建信息。</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（十）：资源的构建</title>
      <link href="/381.html"/>
      <url>/381.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><h2 id="生成-module-资源"><a href="#生成-module-资源" class="headerlink" title="生成 module 资源"></a>生成 module 资源</h2><p>接上文，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.beforeModuleAssets.call();</span><br><span class="line"><span class="keyword">this</span>.createModuleAssets();</span><br></pre></td></tr></table></figure><p>这一步用于生成 <code>module</code> 资源。在 <code>createModuleAssets</code> 里，获取每个 <code>module</code> 属性上的 <code>buildInfo.assets</code>，然后触发 <code>this.emitAsset</code> 生成资源。<code>buildInfo.assets</code> 相关数据可以在 <code>loader</code> 里调用 <code>api</code>: <code>this.emitFile</code> 生成。</p><h2 id="生成-chunk-资源"><a href="#生成-chunk-资源" class="headerlink" title="生成 chunk 资源"></a>生成 chunk 资源</h2><p>这一步用于创建 <code>chunk</code> 资源。</p><h3 id="生成前的准备"><a href="#生成前的准备" class="headerlink" title="生成前的准备"></a>生成前的准备</h3><h4 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h4><p>执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.beforeChunkAssets.call();</span><br><span class="line"><span class="keyword">this</span>.createChunkAssets();</span><br></pre></td></tr></table></figure><p>在 <code>createChunkAssets</code> 里循环对每个 <code>chunk</code> 执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">const</span> template = chunk.hasRuntime() ? <span class="keyword">this</span>.mainTemplate : <span class="keyword">this</span>.chunkTemplate;</span><br><span class="line"><span class="keyword">const</span> manifest = template.getRenderManifest(&#123;</span><br><span class="line">  chunk,</span><br><span class="line">  hash: <span class="keyword">this</span>.hash,</span><br><span class="line">  fullHash: <span class="keyword">this</span>.fullHash,</span><br><span class="line">  outputOptions,</span><br><span class="line">  moduleTemplates: <span class="keyword">this</span>.moduleTemplates,</span><br><span class="line">  dependencyTemplates: <span class="keyword">this</span>.dependencyTemplates</span><br><span class="line">&#125;); <span class="comment">//得到 `render` 所需要的全部信息：`[&#123; render(), filenameTemplate, pathOptions, identifier, hash &#125;]`</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在判断 <code>chunk</code> 是否含有 <code>runtime</code> 代码后即同步异步后，获取到对应的 <code>template</code>。异步 <code>chunk</code> 对应 <code>chunkTemplate</code>，同步及含有 <code>runtime</code> 的 <code>chunk</code> 对应 <code>mainTemplate</code>。</p><p>然后执行对应的 <code>getRenderManifest</code>，触发 <code>template.hooks：renderManifest</code> 执行插件 <code>JavascriptModulesPlugin</code> 相关事件得到 <code>render</code> 所需要的全部信息：<code>[{ render(), filenameTemplate, pathOptions, identifier, hash }]</code>。</p><p>如果是 <code>chunkTemplate</code> 还会触发插件 <code>WebAssemblyModulesPlugin</code> 的相关事件处理 <code>WebAssembly</code> 相关。</p><h4 id="pathAndInfo"><a href="#pathAndInfo" class="headerlink" title="pathAndInfo"></a>pathAndInfo</h4><p>然后遍历 <code>manifest</code> 对象执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pathAndInfo = <span class="keyword">this</span>.getPathWithInfo(filenameTemplate, fileManifest.pathOptions);</span><br></pre></td></tr></table></figure><p><code>this.getPathWithInfo</code> 用于得到路径和相关信息。会触发 <code>mainTemplate.hooks</code>:<code>assetPath</code>，去执行插件 <code>TemplatedPathPlugin</code> 相关事件，使用若干 <code>replace</code> 将如 <code>[name].[chunkhash:8].js</code> 替换为 <code>0.e3296d88.js</code>。</p><h3 id="构建资源"><a href="#构建资源" class="headerlink" title="构建资源"></a>构建资源</h3><p>然后判断有无 <code>source</code> 缓存后，若无则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source = fileManifest.render();</span><br></pre></td></tr></table></figure><p>即执行对应 <code>template</code> 的 <code>render</code>。</p><h3 id="chunkTemplate"><a href="#chunkTemplate" class="headerlink" title="chunkTemplate"></a>chunkTemplate</h3><h4 id="生成主体-chunk-代码"><a href="#生成主体-chunk-代码" class="headerlink" title="生成主体 chunk 代码"></a>生成主体 chunk 代码</h4><p>如果是异步 <code>chunk</code>，<code>render</code> 会执行在文件 <code>JavascriptModulesPlugin.js</code> 里的 <code>renderJavascript</code>。方法里先执行 <code>Template.renderChunkModules</code> 静态方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleSources = Template.renderChunkModules(chunk, m =&gt; <span class="keyword">typeof</span> m.source === <span class="string">'function'</span>, moduleTemplate, dependencyTemplates);</span><br></pre></td></tr></table></figure><h5 id="生成每个-module-代码"><a href="#生成每个-module-代码" class="headerlink" title="生成每个 module 代码"></a>生成每个 module 代码</h5><p>方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> allModules = modules.map(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id: <span class="built_in">module</span>.id,</span><br><span class="line">    source: moduleTemplate.render(<span class="built_in">module</span>, dependencyTemplates, &#123;</span><br><span class="line">      chunk</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里循环对每一个 <code>module</code> 执行 <code>render</code>，方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleSource = <span class="built_in">module</span>.source(dependencyTemplates, <span class="keyword">this</span>.runtimeTemplate, <span class="keyword">this</span>.type);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><code>module.source</code>里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="keyword">this</span>.generator.generate(<span class="keyword">this</span>, dependencyTemplates, runtimeTemplate, type);</span><br></pre></td></tr></table></figure><p>这个 <code>generator</code> 就是在 <code>reslove 流程 -&gt; getGenerator</code> 所获得，即执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.sourceBlock(<span class="built_in">module</span>, <span class="built_in">module</span>, [], dependencyTemplates, source, runtimeTemplate);</span><br></pre></td></tr></table></figure><p>这里循环处理 <code>module</code> 的每个依赖（<code>module.dependencies</code>）：获得依赖所对应的 <code>template</code> 模板类，然后执行该类的 <code>apply</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> template = dependencyTemplates.get(dependency.constructor);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">template.apply(dependency, source, runtimeTemplate, dependencyTemplates);</span><br></pre></td></tr></table></figure><p>这里的 <code>dependencyTemplates</code> 就是在 <code>reslove 流程前的准备 -&gt;Compiler.compile -&gt;实例化 compilation</code> 里添加的依赖模板模块。</p><p>在 <code>apply</code>里，会根据依赖不同做相应的源码转化的处理。但方法里并没有直接执行源码转化的工作，而是将其转化对象 <code>push</code> 到 <code>ReplaceSource.replacements</code> 里，转化对象的格式为：</p><blockquote><p>注：<code>webpack-sources</code> 提供若干类型的 <code>source</code> 类，如 <code>CachedSource, PrefixSource, ConcatSource, ReplaceSource</code> 等。它们可以组合使用，方便对代码进行添加、替换、连接等操作。同时又含有一些 <code>source-map</code> 相关，<code>updateHash</code> 等 <code>api</code> 供 <code>webpack</code> 内部调用.</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Replacement</span><br><span class="line">&#123;</span><br><span class="line">  "content": "__webpack_require__.r(__webpack_exports__);\n", // 替换的内容</span><br><span class="line">  "end": -11, // 替换源码的终止位置</span><br><span class="line">  "insertIndex": 0, // 优先级</span><br><span class="line">  "name": "", // 名称</span><br><span class="line">  "start": -10 // 替换源码的起始位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各模板的具体处理转化见 <code>构建 module（下） -&gt; parse 源码 -&gt; 各依赖作用解释</code>。</p><h5 id="包裹代码"><a href="#包裹代码" class="headerlink" title="包裹代码"></a>包裹代码</h5><p>收集完依赖相关的转化对象 <code>Replacement</code> 之后，回到 <code>module.source</code> 进行 <code>cachedSource</code> 缓存包装后，回到 <code>moduleTemplate.render</code> 方法得到 <code>moduleSource</code>。</p><p>然后触发相关 <code>ModuleTemplate.hooks：content，module，render，package</code>，前两个钩子主要是可以让我们完成对 <code>module</code> 源码的再次处理，然后在 <code>render</code> 钩子里执行插件 <code>FunctionModuleTemplatePlugin</code> 的相关事件，主要是给处理后的 <code>module</code> 源码进行包裹，即生成代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***/</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="comment">//CachedSource 即为module源码，里面包含 replacements</span></span><br><span class="line">  <span class="comment">/***/</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h5><p>然后触发 <code>package</code> 钩子执行插件 <code>FunctionModuleTemplatePlugin</code> 的相关事件，主要作用是添加相关注释，即生成代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!***************************************************************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/c.js ***!</span></span><br><span class="line"><span class="comment">  \***************************************************************/</span></span><br><span class="line"><span class="comment">/*! exports provided: sub */</span></span><br><span class="line"><span class="comment">/***/</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="comment">//CachedSource 即为module源码，里面包含 replacements</span></span><br><span class="line">  <span class="comment">/***/</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将所有的 <code>module</code> 都处理完毕后，回到 <code>renderChunkModules</code>，继续处理生成代码，最终将每个 <code>module</code> 生成的代码串起来得到 <code>moduleSources</code> 回到了 <code>renderJavascript</code>里。</p><h4 id="生成异步包裹代码"><a href="#生成异步包裹代码" class="headerlink" title="生成异步包裹代码"></a>生成异步包裹代码</h4><p>方法里先触发 <code>chunkTemplate.hooks : modules</code> 为修改生成的 <code>chunk</code> 代码提供钩子，得到 <code>core</code> 后，触发 <code>chunkTemplate.hooks</code>:<code>render</code> 执行插件 <code>JsonpChunkTemplatePlugin</code> 相关事件，该事件主要是添加 <code>jsonp</code> 异步包裹代码，得到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">window</span>[<span class="string">'webpackJsonp'</span>] = <span class="built_in">window</span>[<span class="string">'webpackJsonp'</span>] || []).push([</span><br><span class="line">  [<span class="number">0</span>]</span><br><span class="line">  <span class="comment">// 前面生成的 chunk 代码</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>完成后，最后返回一个 <code>new ConcatSource(source, &quot;;&quot;)</code>。到此普通的异步 <code>chunk</code> 代码 <code>chunkTemplate</code> 的 <code>fileManifest.render</code> 代码构建完成。</p><h3 id="mainTemplate"><a href="#mainTemplate" class="headerlink" title="mainTemplate"></a>mainTemplate</h3><p>如果是同步 <code>chunk</code>，<code>render</code> 会执行在文件 <code>JavascriptModulesPlugin.js</code> 里的 <code>compilation.mainTemplate.render</code> 即文件 <code>MainTemplate.js</code> 里的 <code>render</code>。</p><h4 id="生成-runtime-代码"><a href="#生成-runtime-代码" class="headerlink" title="生成 runtime 代码"></a>生成 runtime 代码</h4><p>方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">this</span>.renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates);</span><br></pre></td></tr></table></figure><p>该方法得到 <code>webpack runtime bootstrap</code> 代码数组，从中会判断是否有异步 <code>chunk</code>，如果有，则代码里还会包含异步相关的 <code>runtime</code> 代码，如果还有其他什么延迟加载的模块，都会在这里处理为相应是 <code>runtime</code>。</p><h4 id="包裹-runtime-与-chunk-代码"><a href="#包裹-runtime-与-chunk-代码" class="headerlink" title="包裹 runtime 与 chunk 代码"></a>包裹 runtime 与 chunk 代码</h4><p>然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> source = <span class="keyword">this</span>.hooks.render.call(<span class="keyword">new</span> OriginalSource(Template.prefix(buf, <span class="string">' \t'</span>) + <span class="string">'\n'</span>, <span class="string">'webpack/bootstrap'</span>), chunk, hash, moduleTemplate, dependencyTemplates);</span><br></pre></td></tr></table></figure><p>先通过 <code>Template.prefix</code> 合并 <code>runtime</code> 代码字符串，得到 <code>OriginalSource</code> 的实例，然后将其作为参数执行 <code>MainTemplate.hooks</code> : <code>render</code>，该 <code>hook</code> 在 <code>constructor</code> 里已注册，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> ConcatSource();</span><br><span class="line">source.add(<span class="string">'/******/ (function(modules) &#123; // webpackBootstrap\n'</span>);</span><br><span class="line">source.add(<span class="keyword">new</span> PrefixSource(<span class="string">'/******/'</span>, bootstrapSource));</span><br><span class="line">source.add(<span class="string">'/******/ &#125;)\n'</span>);</span><br><span class="line">source.add(<span class="string">'/************************************************************************/\n'</span>);</span><br><span class="line">source.add(<span class="string">'/******/ ('</span>);</span><br><span class="line">source.add(<span class="keyword">this</span>.hooks.modules.call(<span class="keyword">new</span> RawSource(<span class="string">''</span>), chunk, hash, moduleTemplate, dependencyTemplates));</span><br><span class="line">source.add(<span class="string">')'</span>);</span><br><span class="line"><span class="keyword">return</span> source;</span><br></pre></td></tr></table></figure><p>该方法对 <code>runtime bootstrap</code> 代码进行了包装（<code>bootstrapSource</code> 即为前面生成的 <code>runtime</code> 代码），其中触发 <code>MainTemplate.hooks: modules</code> 得到 <code>chunk</code> 的生成代码，即最终返回一个包含了 <code>runtime</code> 代码和 <code>chunk</code> 代码的 <code>ConcatSource</code> 实例。</p><h4 id="生成-chunk-代码"><a href="#生成-chunk-代码" class="headerlink" title="生成 chunk 代码"></a>生成 chunk 代码</h4><p>这里来看 <code>chunk</code> 代码的实现，如上文代码中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.modules.call(<span class="keyword">new</span> RawSource(<span class="string">''</span>), chunk, hash, moduleTemplate, dependencyTemplates);</span><br></pre></td></tr></table></figure><p>这里 <code>mainTemplate.hooks: modules</code> 触发插件 <code>JavascriptModulesPlugin</code> 的相关事件，即执行 <code>Template</code> 类的静态方法 <code>renderChunkModules</code>。与前文 <code>chunkTemplate -&gt; 生成主体 chunk 代码</code> 的实现一致。</p><p>最终经过包裹后得到的代码大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"/******/ (function(modules) &#123; // webpackBootstrap</span></span><br><span class="line"><span class="string">// runtime 代码的 PrefixSource 实例</span></span><br><span class="line"><span class="string">/******/ &#125;)</span></span><br><span class="line"><span class="string">/************************************************************************/</span></span><br><span class="line"><span class="string">/******/ (&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/***/ "</span>../github/test-loader/loader.js?number=<span class="number">20</span>!./src/d.js<span class="string">":</span></span><br><span class="line"><span class="string">/*!************************************************************!*\</span></span><br><span class="line"><span class="string">  !*** ../github/test-loader/loader.js?number=20!./src/d.js ***!</span></span><br><span class="line"><span class="string">  \************************************************************/</span></span><br><span class="line"><span class="string">/*! exports provided: mul */</span></span><br><span class="line"><span class="string">/***/ (function(module, __webpack_exports__, __webpack_require__) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>use strict<span class="string">";</span></span><br><span class="line"><span class="string">// module d 的 CachedSource 实例</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/***/ &#125;),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/***/ "</span>./src/a.js<span class="string">":</span></span><br><span class="line"><span class="string">/*!******************!*\</span></span><br><span class="line"><span class="string">  !*** ./src/a.js ***!</span></span><br><span class="line"><span class="string">  \******************/</span></span><br><span class="line"><span class="string">/*! no exports provided */</span></span><br><span class="line"><span class="string">/***/ (function(module, __webpack_exports__, __webpack_require__) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>use strict<span class="string">";</span></span><br><span class="line"><span class="string">// module a 的 CachedSource 实例</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/***/ &#125;),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/***/ "</span>./src/b.js<span class="string">":</span></span><br><span class="line"><span class="string">/*!******************!*\</span></span><br><span class="line"><span class="string">  !*** ./src/b.js ***!</span></span><br><span class="line"><span class="string">  \******************/</span></span><br><span class="line"><span class="string">/*! exports provided: add, addddd */</span></span><br><span class="line"><span class="string">/***/ (function(module, __webpack_exports__, __webpack_require__) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>use strict<span class="string">";</span></span><br><span class="line"><span class="string">// module b 的 CachedSource 实例</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/***/ &#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/******/ &#125;)"</span></span><br></pre></td></tr></table></figure><p>完成后，最后返回一个 <code>new ConcatSource(source, &quot;;&quot;)</code>。到此普通的同步 <code>chunk</code> 代码 <code>mainTemplate</code> 的 <code>fileManifest.render</code> 代码构建完成。</p><h3 id="文件名映射资源"><a href="#文件名映射资源" class="headerlink" title="文件名映射资源"></a>文件名映射资源</h3><p>无论是同步还是一部，最后都回到 <code>Compilation.js</code> 的 <code>createChunkAssets</code> 里，做了 <code>source</code> 缓存，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.emitAsset(file, source, assetInfo);</span><br></pre></td></tr></table></figure><p>建立起了文件名与对应源码的联系，将该映射对象挂载到 <code>compilation.assets</code> 下。 然后设置了 <code>alreadyWrittenFiles</code> 这个 <code>Map</code> 对象，防止重复构建代码。到此一个 <code>chunk</code> 的资源构建结束。</p><p><code>chunk</code> 遍历结束后，得到 <code>compilation.assets</code> 和 <code>compilation.assetsInfo</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compilation</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="string">"assets"</span>: &#123;</span><br><span class="line">    <span class="string">"0.3e.js"</span>: CachedSource, <span class="comment">// CachedSource 里包含资源</span></span><br><span class="line">    <span class="string">"bundle.bf23.js"</span>: CachedSource</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...map结构</span></span><br><span class="line">  <span class="string">"assetsInfo"</span>: &#123;</span><br><span class="line">    <span class="number">0</span>: &#123;</span><br><span class="line">      <span class="string">"key"</span>: <span class="string">'0.3e.js'</span>,</span><br><span class="line">      <span class="string">"value"</span>: &#123;</span><br><span class="line">        immutable:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">1</span>: &#123;</span><br><span class="line">      <span class="string">"key"</span>: <span class="string">'bundle.bf23.js'</span>,</span><br><span class="line">      <span class="string">"value"</span>: &#123;</span><br><span class="line">        immutable:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>通过 <code>this.emitFile</code> 可生成 <code>module</code> 资源，如果有则直接调用 <code>this.emitAsset</code> 生成资源；</li><li>生成 <code>chunk</code> 资源时，先根据是否含有 <code>runtime</code> 得到不同的 <code>template</code>，包括 <code>chunkTemplate</code> 和 <code>mainTemplate</code>;</li><li>通过不同的 <code>template</code> 得到不同的 <code>manifest</code> 和 <code>pathAndInfo</code>，然后调用不同的 <code>render</code> 渲染代码；</li><li>最后建立文件名与资源之间的映射，最终一起挂载到 <code>compilation.assets</code> 即目标资源。</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（九）：优化 chunk</title>
      <link href="/380.html"/>
      <url>/380.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><h2 id="chunk-的一些优化"><a href="#chunk-的一些优化" class="headerlink" title="chunk 的一些优化"></a>chunk 的一些优化</h2><p>接上文，在 <code>seal</code> 里，<code>chunk</code> 生成后，开始进行 <code>chunk</code> 优化之类的处理。</p><p>在触发钩子 <code>optimize，optimizeModules</code>（<code>module</code> 相关的优化）等之后，忽略掉本次打包未触发插件的钩子，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.optimizeChunksBasic.call(<span class="keyword">this</span>.chunks, <span class="keyword">this</span>.chunkGroups);</span><br></pre></td></tr></table></figure><p>触发插件：</p><ul><li><code>EnsureChunkConditionsPlugin</code> 处理 <code>chunkCondition</code></li><li><code>RemoveEmptyChunksPlugin</code> 移除空 <code>chunk</code></li><li><code>MergeDuplicateChunksPlugin</code> 处理重复 <code>chunk</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.optimizeChunksAdvanced.call(<span class="keyword">this</span>.chunks, <span class="keyword">this</span>.chunkGroups);</span><br></pre></td></tr></table></figure><p>触发插件：</p><ul><li><code>SplitChunksPlugin</code> 优化切割 <code>chunk</code></li><li><code>RemoveEmptyChunksPlugin</code> 再次移除空 <code>chunk</code></li></ul><h2 id="设置-module-id"><a href="#设置-module-id" class="headerlink" title="设置 module.id"></a>设置 module.id</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.reviveModules.call(<span class="keyword">this</span>.modules, <span class="keyword">this</span>.records);</span><br></pre></td></tr></table></figure><p>触发插件 <code>RecordIdsPlugin</code>：设置 <code>module.id</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.beforeModuleIds.call(<span class="keyword">this</span>.modules);</span><br></pre></td></tr></table></figure><p>触发插件 <code>NamedModulesPlugin</code>： 设置 <code>module.id</code> 为 文件相对路径，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.applyModuleIds();</span><br></pre></td></tr></table></figure><p>这一步主要用于设置 <code>module.id</code>（如果 <code>id</code> 在上一步没有设置的话），内部具体算法为：</p><p>先遍历各 <code>module</code>，找出其中最大的 <code>id</code> 以他为最大值（<code>usedIdmax</code>），计算出比他小的所有未使用的正整数和（<code>usedIdmax+1</code>）作为 <code>unusedIds</code> 用于给没有设置 <code>id</code> 的 <code>module</code> 使用，<code>unusedIds</code> 用尽后，则设置 <code>id</code> 为 <code>（usedIdmax+1）++</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.sortItemsWithModuleIds();</span><br></pre></td></tr></table></figure><p>根据 <code>module.id</code> 给 <code>module，chunk，reasons</code> 等排序。</p><h2 id="设置-chunk-id"><a href="#设置-chunk-id" class="headerlink" title="设置 chunk.id"></a>设置 chunk.id</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.reviveChunks.call(<span class="keyword">this</span>.chunks, <span class="keyword">this</span>.records);</span><br></pre></td></tr></table></figure><p>触发插件 <code>RecordIdsPlugin</code>：设置 <code>chunk.id</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.optimizeChunkOrder.call(<span class="keyword">this</span>.chunks);</span><br></pre></td></tr></table></figure><p>触发插件 <code>OccurrenceOrderChunkIdsPlugin</code>：<code>chunks</code> 排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.beforeChunkIds.call(<span class="keyword">this</span>.chunks);</span><br></pre></td></tr></table></figure><p>触发插件 <code>NamedChunksPlugin</code>：设置 <code>chunk.id = chunk.name</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.applyChunkIds();</span><br></pre></td></tr></table></figure><p>这一步主要用于设置 <code>chunk.id</code>，算法与 <code>this.applyModuleIds</code> 一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.sortItemsWithChunkIds();</span><br></pre></td></tr></table></figure><p>根据 <code>chunk.id</code> 给 <code>module，chunk，reasons，errors，warnings，children</code> 等排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldRecord) &#123;</span><br><span class="line">  <span class="keyword">this</span>.hooks.recordModules.call(<span class="keyword">this</span>.modules, <span class="keyword">this</span>.records);</span><br><span class="line">  <span class="keyword">this</span>.hooks.recordChunks.call(<span class="keyword">this</span>.chunks, <span class="keyword">this</span>.records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依旧是对 <code>records</code> 的一些设置。</p><h2 id="创建-hash"><a href="#创建-hash" class="headerlink" title="创建 hash"></a>创建 hash</h2><p>接下来执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.beforeHash.call();</span><br><span class="line"><span class="keyword">this</span>.createHash();</span><br><span class="line"><span class="keyword">this</span>.hooks.afterHash.call();</span><br><span class="line"><span class="keyword">if</span> (shouldRecord) &#123;</span><br><span class="line">  <span class="keyword">this</span>.hooks.recordHash.call(<span class="keyword">this</span>.records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入 <code>createHash</code>，前文已介绍生成 <code>hash</code> 的方法，此处先初始化一个 <code>hash</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.mainTemplate.updateHash(hash);</span><br><span class="line"><span class="keyword">this</span>.chunkTemplate.updateHash(hash);</span><br></pre></td></tr></table></figure><ul><li><code>mainTemplate</code>: 渲染生成包含 <code>webpack runtime bootstrap</code> 代码的 <code>chunk</code></li><li><code>chunkTemplate</code>: 渲染生成普通 <code>chunk</code></li></ul><p><code>mainTemplate</code> 在 <code>update(&#39;maintemplate&#39;,&#39;3&#39;)</code> 后，触发 <code>MainTemplate.hooks</code>: <code>hash</code>，执行插件 <code>JsonpMainTemplatePlugin</code>，<code>WasmMainTemplatePlugin</code> 内的相关事件，<code>hash.buffer</code> 更新为 <code>maintemplate3jsonp6WasmMainTemplatePlugin2</code>。</p><p><code>chunkTemplate</code> 在 <code>update(&#39;ChunkTemplate&#39;,&#39;2&#39;)</code> 后，触发<code>ChunkTemplate.hooks</code>: <code>hash</code>，执行插件 <code>JsonpChunkTemplatePlugin</code>内的相关事件，<code>hash.buffer</code> 更新为 <code>maintemplate3jsonp6WasmMainTemplatePlugin2ChunkTemplate2JsonpChunkTemplatePlugin4webpackJsonpwindow</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.moduleTemplates).sort()) &#123;</span><br><span class="line">  <span class="keyword">this</span>.moduleTemplates[key].updateHash(hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码为 complation 实例化的时候所定义</span></span><br><span class="line"><span class="keyword">this</span>.moduleTemplates = &#123;</span><br><span class="line">  javascript: <span class="keyword">new</span> ModuleTemplate(<span class="keyword">this</span>.runtimeTemplate, <span class="string">'javascript'</span>),</span><br><span class="line">  webassembly: <span class="keyword">new</span> ModuleTemplate(<span class="keyword">this</span>.runtimeTemplate, <span class="string">'webassembly'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将 <code>this.moduleTemplates</code> 的 <code>key</code> 排序后执行各自的 <code>updateHash</code>，<code>hash.buffer</code> 更新为 <code>maintemplate3jsonp6WasmMainTemplatePlugin2ChunkTemplate2JsonpChunkTemplatePlugin4webpackJsonpwindow1FunctionModuleTemplatePlugin21</code></p><p>然后如果有 <code>children,warnings,errors</code> 也把他们的 <code>hash</code> 或者 <code>message</code> <code>update</code> 进去。然后执行：</p><h3 id="创建-module-hash"><a href="#创建-module-hash" class="headerlink" title="创建 module hash"></a>创建 module hash</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; modules.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = modules[i];</span><br><span class="line">  <span class="keyword">const</span> moduleHash = createHash(hashFunction);</span><br><span class="line">  <span class="built_in">module</span>.updateHash(moduleHash);</span><br><span class="line">  <span class="built_in">module</span>.hash = <span class="comment">/** @type &#123;string&#125; */</span> (moduleHash.digest(hashDigest));</span><br><span class="line">  <span class="built_in">module</span>.renderedHash = <span class="built_in">module</span>.hash.substr(<span class="number">0</span>, hashDigestLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里循环初始化了每个 <code>module</code> 的 <code>hash</code>，并调用了每个 <code>module</code> 的 <code>updateHash</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.updateHash(moduleHash);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面 module.updateHash 调用</span></span><br><span class="line">hash.update(<span class="keyword">this</span>._buildHash); <span class="comment">//这里加入了 _buildHash</span></span><br><span class="line"><span class="keyword">super</span>.updateHash(hash);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面 super 调用</span></span><br><span class="line">hash.update(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.id&#125;</span>`</span>);</span><br><span class="line">hash.update(<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.usedExports));</span><br><span class="line"><span class="keyword">super</span>.updateHash(hash);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面 super 调用</span></span><br><span class="line"><span class="comment">//调用各自 dependencies，blocks，variables的 updateHash</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> dep <span class="keyword">of</span> <span class="keyword">this</span>.dependencies) dep.updateHash(hash);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> block <span class="keyword">of</span> <span class="keyword">this</span>.blocks) block.updateHash(hash);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> variable <span class="keyword">of</span> <span class="keyword">this</span>.variables) variable.updateHash(hash);</span><br></pre></td></tr></table></figure><p>最终得到 <code>moduleHash.buffer</code> 形如：<code>ac01f98d10f099796d2f3d600c2592d1./src/a.jsnull0,28./src/b.jsnamespace./src/b.js29,57./src/c.jsnamespace./src/c.js58,121../github/test-loader/loader.js?number=20000!./src/e.jsnamespace../github/test-loader/loader.js?number=20000!./src/e.js./src/b.jsnamespace./src/b.jsaddaddnamespacenullnull./src/c.jsnamespace./src/c.jssubsubnamespacenullnull../github/test-loader/loader.js?number=20000!./src/e.jsnamespace../github/test-loader/loader.js?number=20000!./src/e.jsdivdivnamespacenullnull</code></p><p>然后最终生成出 <code>module</code> 各自的 <code>hash</code> 和 <code>renderedHash</code>。</p><h3 id="创建-chunk-hash"><a href="#创建-chunk-hash" class="headerlink" title="创建 chunk hash"></a>创建 chunk hash</h3><p>继续执行，先对 <code>chunks</code> 进行排序，然后遍历 <code>chunks</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; chunks.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> chunk = chunks[i];</span><br><span class="line">  <span class="keyword">const</span> chunkHash = createHash(hashFunction);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (outputOptions.hashSalt) &#123;</span><br><span class="line">      chunkHash.update(outputOptions.hashSalt);</span><br><span class="line">    &#125;</span><br><span class="line">    chunk.updateHash(chunkHash);</span><br><span class="line">    <span class="keyword">const</span> template = chunk.hasRuntime() ? <span class="keyword">this</span>.mainTemplate : <span class="keyword">this</span>.chunkTemplate;</span><br><span class="line">    template.updateHashForChunk(chunkHash, chunk, <span class="keyword">this</span>.moduleTemplates.javascript, <span class="keyword">this</span>.dependencyTemplates);</span><br><span class="line">    <span class="keyword">this</span>.hooks.chunkHash.call(chunk, chunkHash);</span><br><span class="line">    chunk.hash = <span class="comment">/** @type &#123;string&#125; */</span> (chunkHash.digest(hashDigest));</span><br><span class="line">    hash.update(chunk.hash);</span><br><span class="line">    chunk.renderedHash = chunk.hash.substr(<span class="number">0</span>, hashDigestLength);</span><br><span class="line">    <span class="keyword">this</span>.hooks.contentHash.call(chunk);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">this</span>.errors.push(<span class="keyword">new</span> ChunkRenderError(chunk, <span class="string">''</span>, err));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里循环初始化了每个 <code>chunk</code> 的 <code>hash</code>，并调用了每个 <code>chunk</code> 的 <code>updateHash</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chunk.updateHash(chunkHash);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面 chunk.updateHash 调用</span></span><br><span class="line">hash.update(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.id&#125;</span> `</span>);</span><br><span class="line">hash.update(<span class="keyword">this</span>.ids ? <span class="keyword">this</span>.ids.join(<span class="string">','</span>) : <span class="string">''</span>);</span><br><span class="line">hash.update(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name || <span class="string">''</span>&#125;</span> `</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> m <span class="keyword">of</span> <span class="keyword">this</span>._modules) &#123;</span><br><span class="line">  hash.update(m.hash); <span class="comment">//此处把每个 module 的 hash 一并加入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到 <code>chunkHash.buffer</code> 形如 <code>bundle bundlebundle 99d78a1615d2e348fbf274adb4e0b67c4fa9f69c98e5b41607cb6354e95983c3824bbf3e0b5e82705f88a41a6741b08f2f18bdc137e8a1e8e6cc78ca7ce0caf64b500a96034ab069ecf31c34f944ede6</code>，然后判断 <code>chunk</code> 是否含有 <code>runtime</code> 代码（ <code>template</code> 判断入口 <code>chunk</code> 与运行时 <code>chunk</code> 一致则为 <code>this.mainTemplate</code>，不一致则为 <code>this.chunkTemplate</code> ）。</p><h4 id="chunkTemplate"><a href="#chunkTemplate" class="headerlink" title="chunkTemplate"></a>chunkTemplate</h4><p>如果是 <code>chunkTemplate</code> 的 <code>updateHashForChunk</code>，则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.updateHash(hash); <span class="comment">//与上文 this.chunkTemplate.updateHash(hash) 执行相同</span></span><br><span class="line"><span class="keyword">this</span>.hooks.hashForChunk.call(hash, chunk);</span><br></pre></td></tr></table></figure><p><code>this.hooks.hashForChunk.call(hash, chunk)</code> 触发插件 <code>JsonpChunkTemplatePlugin</code> 相关事件， <code>update</code> <code>entryModule</code> 和 <code>group.childrenIterable</code>。</p><h4 id="mainTemplate"><a href="#mainTemplate" class="headerlink" title="mainTemplate"></a>mainTemplate</h4><p>如果是 <code>mainTemplate</code> 的 <code>updateHashForChunk</code>，则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.updateHash(hash); <span class="comment">//与上文 this.mainTemplate.updateHash(hash) 执行相同</span></span><br><span class="line"><span class="keyword">this</span>.hooks.hashForChunk.call(hash, chunk);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> line <span class="keyword">of</span> <span class="keyword">this</span>.renderBootstrap(<span class="string">'0000'</span>, chunk, moduleTemplate, dependencyTemplates)) &#123;</span><br><span class="line">  hash.update(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this.hooks.hashForChunk.call(hash, chunk)</code> 触发插件 <code>TemplatedPathPlugin</code> 相关事件，根据 <code>chunkFilename</code> 的不同配置，<code>update chunk.getChunkMaps</code> 的不同导出，<code>chunk.getChunkMaps</code> 的实现为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">getChunkMaps(realHash) &#123;</span><br><span class="line">  <span class="keyword">const</span> chunkHashMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> chunkContentHashMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> chunkNameMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> <span class="keyword">this</span>.getAllAsyncChunks()) &#123;</span><br><span class="line">    chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(chunk.contentHash)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!chunkContentHashMap[key]) &#123;</span><br><span class="line">        chunkContentHashMap[key] = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (chunk.name) &#123;</span><br><span class="line">      chunkNameMap[chunk.id] = chunk.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    hash: chunkHashMap, <span class="comment">// chunkFilename 配置为 chunkhash的导出</span></span><br><span class="line">    contentHash: chunkContentHashMap, <span class="comment">// chunkFilename 配置为 contenthash 的导出</span></span><br><span class="line">    name: chunkNameMap <span class="comment">// chunkFilename 配置为 name 的导出</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见各种类型的 <code>hash</code> 都与其他的 <code>不含runtime模块即异步模块</code> 的 <code>hash</code> 有强关联，所以前面的 <code>chunk</code> 排序也就很重要。</p><p><code>this.renderBootstrap</code> 用于拼接 <code>webpack runtime bootstrap</code> 代码字符串。这里相当于把每一行 <code>runtime</code> 代码循环 <code>update</code> 进去，到此 <code>chunk hash</code> 生成结束。 将 <code>chunk.hash</code> <code>update</code> 到 <code>hash</code> 上。 最终得到 <code>chunk.hash</code> 和 <code>chunk.renderedHash</code>。</p><h3 id="创建-content-hash"><a href="#创建-content-hash" class="headerlink" title="创建 content hash"></a>创建 content hash</h3><p>然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.contentHash.call(chunk);</span><br></pre></td></tr></table></figure><p>这里触发 <code>JavascriptModulesPlugin</code> 相关事件，主要作用是创建生成 <code>chunk.contentHash.javascript</code>，也就是 <code>contentHash</code> 生成相关，大体跟生成 <code>chunk hash</code> 一致.</p><p>最后在 <code>createHash</code> 里得到 <code>Compilation.hash</code> 和 <code>Compilation。fullhash</code>，<code>hash</code> 生成到此结束。<code>chunk</code> 相关优化到此结束。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>本章主要是对 <code>chunk</code> 的一些优化工作，暴露了很多相关的优化钩子；</li><li>设置了 <code>module.id</code> 及 <code>chunk.id</code> 并排序；</li><li>创建了 <code>hash</code>，包括 <code>module hash，chunk hash，content hash</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（八）：生成 chunk</title>
      <link href="/379.html"/>
      <url>/379.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><p>在 <code>this._addModuleChain</code> 的回调里，得到了生成的入口 <code>module</code>。触发 <code>compilation.hooks</code>:<code>succeedEntry</code> 后，执行 <code>return callback(null, module)</code>，回到文件 <code>Compile.js</code> 的 <code>compile</code> 的 <code>make</code> 钩子的回调里:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.make.callAsync(compilation, err =&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  compilation.finish(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    compilation.seal(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">this</span>.hooks.afterCompile.callAsync(compilation, err =&gt; &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> callback(<span class="literal">null</span>, compilation);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="compilation-finish"><a href="#compilation-finish" class="headerlink" title="compilation.finish"></a>compilation.finish</h2><p>执行 <code>compilation.finish</code>，触发 <code>compilation.hooks</code>：<code>finishModules</code>，执行插件 <code>FlagDependencyExportsPlugin</code> 注册的事件，作用是遍历所有 <code>module</code> 将 <code>export</code> 出来的变量以数组的形式，单独存储到 <code>module.buildMeta.providedExports</code>变量下。</p><p>然后执行 <code>reportDependencyErrorsAndWarnings</code> 收集生成每一个 <code>module</code> 时暴露出来的 <code>err</code> 和 <code>warning</code>。</p><p>最后走回调执行 <code>compilation.seal</code> 。</p><h2 id="compilation-seal"><a href="#compilation-seal" class="headerlink" title="compilation.seal"></a>compilation.seal</h2><p><code>compilation.seal</code> 里触发了海量 <code>hooks</code>，为我们侵入 <code>webpack</code> 构建流程提供了海量钩子。先执行（我们先略过没有注册方法的钩子）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.seal.call();</span><br></pre></td></tr></table></figure><p>触发插件 <code>WarnCaseSensitiveModulesPlugin</code>：模块文件路径需要区分大小写的警告</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.optimizeDependencies.call(<span class="keyword">this</span>.modules);</span><br></pre></td></tr></table></figure><p><code>production</code> 模式会触发插件：</p><ul><li><code>SideEffectsFlagPlugin</code>：识别 <code>package.json</code> 或者 <code>module.rules</code> 的 <code>sideEffects</code> 标志（纯的 ES2015 模块)，安全地删除未用到的 <code>export</code> 导出</li><li><code>FlagDependencyUsagePlugin</code>：编译时标记依赖 <code>unused harmony export</code> 用于 <code>Tree shaking</code></li></ul><h3 id="chunk-初始化"><a href="#chunk-初始化" class="headerlink" title="chunk 初始化"></a>chunk 初始化</h3><p>在触发 <code>compilation.hooks</code>:<code>beforeChunks</code> 后，开始遍历入口对象 <code>this._preparedEntrypoints</code>，为每一个入口生成一个 <code>chunk</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chunk = <span class="keyword">this</span>.addChunk(name);</span><br></pre></td></tr></table></figure><p>该方法里做了缓存判断后执行 <code>new Chunk(name)</code>，并同时添加 <code>chunk</code> 到 <code>Compilation.chunks</code>，继续执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> entrypoint = <span class="keyword">new</span> Entrypoint(name);</span><br></pre></td></tr></table></figure><p><code>Entrypoint</code> 类扩展于 <code>ChunkGroup</code> 类，是 <code>chunks</code> 的集合，主要用来优化 <code>chunk graph</code>。</p><p>继续执行设置了 <code>Compilation.runtimeChunk &amp; Compilation.namedChunkGroups &amp; Compilation.entrypoints &amp; Compilation.chunkGroups</code> 和 <code>ChunkGroup.origins</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk);</span><br><span class="line">GraphHelpers.connectChunkAndModule(chunk, <span class="built_in">module</span>);</span><br></pre></td></tr></table></figure><p>建立了 <code>chunk</code> 与 <code>entrypoint</code>，<code>chunk</code> 与 <code>module</code> 之间的联系，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.assignDepth(<span class="built_in">module</span>);</span><br></pre></td></tr></table></figure><p>根据各个模块依赖的深度（多次依赖取最小值）设置 <code>module.depth</code>，入口模块则为 <code>depth = 0</code>。</p><p>遍历完 <code>this._preparedEntrypoints</code> 后，然后执行：</p><h3 id="生成-chunk-graph"><a href="#生成-chunk-graph" class="headerlink" title="生成 chunk graph"></a>生成 chunk graph</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buildChunkGraph(<span class="keyword">this</span>, <span class="comment">/** @type &#123;Entrypoint[]&#125; */</span> (<span class="keyword">this</span>.chunkGroups.slice()));</span><br></pre></td></tr></table></figure><p><code>buildChunkGraph</code> 用于生成并优化 <code>chunk</code> 依赖图，建立起各模块之前的关系。分为三阶段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PART ONE</span></span><br><span class="line"></span><br><span class="line">visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, chunkDependencies, blocksWithNestedBlocks, allCreatedChunkGroups);</span><br><span class="line"></span><br><span class="line"><span class="comment">// PART TWO</span></span><br><span class="line"></span><br><span class="line">connectChunkGroups(blocksWithNestedBlocks, chunkDependencies, chunkGroupInfoMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cleaup work</span></span><br><span class="line"></span><br><span class="line">cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);</span><br></pre></td></tr></table></figure><h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>先执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> blockInfoMap = extraceBlockInfoMap(compilation);</span><br></pre></td></tr></table></figure><p>得到一个 <code>map</code> 结构： <code>module</code> 与该 <code>module</code> 内导入其他模块的关系，同步存入 <code>modules</code>，异步存入 <code>blocks</code>。以 <code>demo</code> 为例，得到 <code>blockInfoMap</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...map结构</span></span><br><span class="line">  <span class="number">0</span>:&#123;</span><br><span class="line">    key:NormalModule, <span class="comment">//a</span></span><br><span class="line">    value:&#123;</span><br><span class="line">      blocks:[ImportDependenciesBlock],<span class="comment">//异步</span></span><br><span class="line">      modules:[NormalModule] <span class="comment">//b  modules为set结构</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1</span>:&#123;</span><br><span class="line">    key: ImportDependenciesBlock,</span><br><span class="line">    value:&#123;</span><br><span class="line">      blocks: [],</span><br><span class="line">      modules:[NormalModule] <span class="comment">//c</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">2</span>:&#123;</span><br><span class="line">    key: NormalModule, <span class="comment">//c</span></span><br><span class="line">    value:&#123;</span><br><span class="line">      blocks: [ImportDependenciesBlock],</span><br><span class="line">      modules:[NormalModule] <span class="comment">//d</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续执行，设置了 <code>queue</code> 数组，<code>push</code> 入口 <code>module</code> 和对应的 <code>action</code> 等信息组成的对象，用于 <code>while</code> 循环；设置了 <code>chunkGroupInfoMap</code>，他映射了 <code>chunkGroup</code> 和与他相关的信息对象，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (chunkGroup !== queueItem.chunkGroup) &#123;</span><br><span class="line">      <span class="comment">// 重置更新chunkGroup</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (queueItem.action) &#123;</span><br><span class="line">      <span class="keyword">case</span> ADD_AND_ENTER_MODULE: &#123;</span><br><span class="line">        <span class="comment">// 建立chunk和module之间的联系</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> ENTER_MODULE: &#123;</span><br><span class="line">        <span class="comment">// 设置 chunkGroup._moduleIndices 和 module.index，然后 queue.push 一个新的该 module 的 queueItem，action 设为 LEAVE_MODULE</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> PROCESS_BLOCK: &#123;</span><br><span class="line">        <span class="comment">// 1. 遍历 blockInfoMap 里的同步模块 modules，如果对应 chunk 已有此模块则跳过，如果 minAvailableModules 有此模块则一个新的 queueItem 存入 skippedItems 数组，没有则该 queueItem 存入 queue，其中 queue 的 action 都设为 ADD_AND_ENTER_MODULE</span></span><br><span class="line">        <span class="comment">// 2. 遍历 blockInfoMap 里的异步模块 blocks</span></span><br><span class="line">        <span class="comment">// 2.1 创建一个对应import依赖的chunkGroup和chunk，并建立两者的联系，然后更新了 compilation.chunkGroups 和 compilation.namedChunkGroups，chunkGroupCounters(计数 map)，blockChunkGroups（映射依赖和 ChunkGroup的关系 map），allCreatedChunkGroups（收集被创建的ChunkGroup set）</span></span><br><span class="line">        <span class="comment">// 2.2 更新 chunkDependencies（map） 建立前一个 ChunkGroup 与新的 ChunkGroup 和 import 依赖的映射</span></span><br><span class="line">        <span class="comment">// 2.3 更新 queueConnect（map） 建立前一个 ChunkGroup 与新的 ChunkGroup 的映射</span></span><br><span class="line">        <span class="comment">// 2.4 更新 queueDelayed，同 queue，注意 module 是前一个的 module</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> LEAVE_MODULE: &#123;</span><br><span class="line">        <span class="comment">// 设置 chunkGroup._moduleIndices2 和 module.inde2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (queueConnect.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 在 chunkGroupInfoMap 中设置前一个 ChunkGroup 的信息对象的 resultingAvailableModules, children</span></span><br><span class="line">    <span class="comment">// 2. 在 chunkGroupInfoMap 中初始化新的 ChunkGroup 与他相关的信息对象的映射并设置了 availableModulesToBeMerged</span></span><br><span class="line">    <span class="keyword">if</span> (outdatedChunkGroupInfo.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 1.获取设置新的 ChunkGroup 信息对象的 minAvailableModules</span></span><br><span class="line">      <span class="comment">// 2.如果新的 ChunkGroup 信息对象的 skippedItems 不为空则 push 到 queue</span></span><br><span class="line">      <span class="comment">// 3.如果新的 ChunkGroup 信息对象的 children 不为空，则更新 queueConnect 递归循环</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把queueDelayed 放入queue走while的最外层循环，目的的同步循环处理完后，然后才处理异步module</span></span><br><span class="line">  <span class="keyword">if</span> (queue.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> tempQueue = queue;</span><br><span class="line">    queue = queueDelayed.reverse();</span><br><span class="line">    queueDelayed = tempQueue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在内部 <code>while</code> 对 <code>queue.length</code> 循环里（ <code>while+push</code> 防递归爆栈，后序深度优先），从入口 <code>module</code> 开始，解析了所有同步 <code>module</code> 并建立了 <code>module</code> 与 <code>chunk</code> 的联系；解析了所有第一层异步的 <code>module</code>，并为每个不同 <code>mudule</code> 都新建了 <code>chunkGroup</code> 和 <code>chunk</code> 并建立了两者的联系。</li><li>然后在 <code>while</code> 对 <code>queueConnect.size</code> 的循环里，更新了 <code>chunkGroupInfoMap</code> 中前一个 <code>ChunkGroup</code> 的信息对象和初始化了新的 <code>ChunkGroup</code> 的信息对象，并获取了最小可用模块。</li><li>同步模块循环处理结束后，开始处理异步 <code>module</code>，将 <code>queueDelayed</code> 赋给 <code>queue</code>，走外部 <code>while</code> 对 <code>queue.length</code> 的循环。</li><li>处理异步模块的时候，<code>queue</code> 里的 <code>block</code> 为 <code>ImportDependenciesBlock</code> 依赖，然后更新 <code>chunkGroup</code> 后， <code>switch</code> 走 <code>PROCESS_BLOCK</code> 获得本次异步对应的真正模块，后面的处理数据都将在新的 <code>ChunkGroup</code> 信息对象上。就这样循环处理，最终得到一个 <code>Map</code> 结构的 <code>chunkGroupInfoMap</code>。以本 <code>demo</code> 为例，得到:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...map结构</span></span><br><span class="line">  <span class="number">0</span>:&#123;</span><br><span class="line">    key:Entrypoint, <span class="comment">//groupDebugId:5000</span></span><br><span class="line">    value:&#123;</span><br><span class="line">      availableModulesToBeMerged:<span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">      children:<span class="built_in">Set</span>(<span class="number">1</span>) &#123;&#125; <span class="comment">//ChunkGroup 5001</span></span><br><span class="line">      chunkGroup:Entrypoint</span><br><span class="line">      minAvailableModules:<span class="built_in">Set</span>(<span class="number">0</span>)</span><br><span class="line">      minAvailableModulesOwned:<span class="literal">true</span></span><br><span class="line">      resultingAvailableModules:<span class="built_in">Set</span>(<span class="number">3</span>)</span><br><span class="line">      skippedItems:<span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1</span>:&#123;</span><br><span class="line">    key: ChunkGroup, <span class="comment">//groupDebugId:5001</span></span><br><span class="line">    value:&#123;</span><br><span class="line">      availableModulesToBeMerged:<span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">      children:<span class="built_in">Set</span>(<span class="number">1</span>) &#123;&#125; <span class="comment">//ChunkGroup 5002</span></span><br><span class="line">      chunkGroup:Entrypoint</span><br><span class="line">      minAvailableModules:<span class="built_in">Set</span>(<span class="number">3</span>)</span><br><span class="line">      minAvailableModulesOwned:<span class="literal">true</span></span><br><span class="line">      resultingAvailableModules:<span class="built_in">Set</span>(<span class="number">5</span>)</span><br><span class="line">      skippedItems:<span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">2</span>:&#123;</span><br><span class="line">    key: ChunkGroup, <span class="comment">//groupDebugId:5002</span></span><br><span class="line">    value:&#123;</span><br><span class="line">      availableModulesToBeMerged:<span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">      children:<span class="literal">undefined</span></span><br><span class="line">      chunkGroup:Entrypoint</span><br><span class="line">      minAvailableModules:<span class="built_in">Set</span>(<span class="number">5</span>)</span><br><span class="line">      minAvailableModulesOwned:<span class="literal">true</span></span><br><span class="line">      resultingAvailableModules:<span class="literal">undefined</span></span><br><span class="line">      skippedItems:<span class="built_in">Array</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>遍历 <code>chunkDependencies</code>，<code>chunkDependencies</code> 是 <code>Map</code> 结构，保存着前一个 <code>ChunkGroup</code> 与新的 <code>ChunkGroup</code> 和 <code>import</code> 依赖之间的映射：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...map结构</span></span><br><span class="line">  <span class="number">0</span>:&#123;</span><br><span class="line">    key:Entrypoint, <span class="comment">//groupDebugId:5000</span></span><br><span class="line">    value:[</span><br><span class="line">      &#123;</span><br><span class="line">        block:ImportDependenciesBlock,</span><br><span class="line">        chunkGroup:ChunkGroup <span class="comment">//groupDebugId:5001</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1</span>:&#123;</span><br><span class="line">    key:ChunkGroup, <span class="comment">//groupDebugId:5001</span></span><br><span class="line">    value:[</span><br><span class="line">      &#123;</span><br><span class="line">        block:ImportDependenciesBlock,</span><br><span class="line">        chunkGroup:ChunkGroup <span class="comment">//groupDebugId:5002</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在判断如果前一个 <code>ChunkGroup</code> 信息对象的可用模块 <code>resultingAvailableModules</code> 包含后一个 <code>ChunkGroup.chunks[]._modules</code>，则分别建立 <code>import</code> 依赖与对应的 <code>ChunkGroup</code>，前一个 <code>chunkGroup</code> 和后一个 <code>chunkGroup</code> 的关系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GraphHelpers.connectDependenciesBlockAndChunkGroup(depBlock, depChunkGroup); <span class="comment">// ImportDependenciesBlock与chunkGroup建立联系</span></span><br><span class="line"></span><br><span class="line">GraphHelpers.connectChunkGroupParentAndChild(chunkGroup, depChunkGroup); <span class="comment">// chunkGroup之间建立联系：_children和_parents</span></span><br></pre></td></tr></table></figure><h4 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h4><p>遍历 <code>allCreatedChunkGroups</code>，<code>allCreatedChunkGroups</code> 即为异步被创建的 <code>ChunkGroup</code>，判断 <code>chunkGroup</code> 有没有父的 <code>chunkGroup</code>（<code>_parents</code>）,如果没有执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> chunkGroup.chunks) &#123;</span><br><span class="line">  <span class="keyword">const</span> idx = compilation.chunks.indexOf(chunk);</span><br><span class="line">  <span class="keyword">if</span> (idx &gt;= <span class="number">0</span>) compilation.chunks.splice(idx, <span class="number">1</span>);</span><br><span class="line">  chunk.remove(<span class="string">'unconnected'</span>);</span><br><span class="line">&#125;</span><br><span class="line">chunkGroup.remove(<span class="string">'unconnected'</span>);</span><br></pre></td></tr></table></figure><p>即解除 <code>module，chunkGroup，chunk</code> 三者之间的联系。</p><p>最终每个 <code>module</code> 与每个 <code>chunk</code>，每个 <code>chunkGroup</code> 和他们之间都建立了联系，优化形成了 <code>chunk Graph</code>。</p><p><code>seal</code> 里继续执行，先将 <code>compilation.modules</code> 按 <code>index</code> 属性大小排序，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.afterChunks.call(<span class="keyword">this</span>.chunks);</span><br></pre></td></tr></table></figure><p>触发插件 <code>WebAssemblyModulesPlugin</code>：设置与 <code>webassembly</code> 相关的报错信息，到此 <code>chunk</code> 生成结束。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>在 <code>finish</code> 回调中执行的 <code>seal</code> 方法里，包含了海量钩子用于我们侵入 <code>webpack</code> 的封包阶段；</li><li>在遍历入口文件实例化生成 <code>chunk</code> 时，同时实例化了 <code>Entrypoint</code> 等，并建立了入口 <code>module</code> 和 <code>chunk</code>，<code>Entrypoint</code> 之间的联系；</li><li>通过 <code>buildChunkGraph</code> 的三个阶段，让所有的 <code>module、chunk、chunkGroup</code> 之间都建立了联系，形成了 <code>chunk Graph</code>。</li><li>最后触发钩子 <code>afterChunks</code> 标志这 <code>chunk</code> 生成结束。</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（七）：构建 module（下）</title>
      <link href="/378.html"/>
      <url>/378.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><h2 id="parse-源码"><a href="#parse-源码" class="headerlink" title="parse 源码"></a>parse 源码</h2><p><code>runLoaders</code> 运行结束后，在回调里执行了 <code>createSource</code> 后,判断 <code>loader</code> 的 <code>result</code> 是否有第三个参数对象并且里面存在 <code>webpackAST</code> 属性，如果有则为 <code>ast</code> 赋值到 <code>_ast</code> 上。</p><p>然后回到 <code>this.doBuild</code> 执行回调，在根据项目配置项判断是否需要 <code>parse</code> 后，若需要解析，则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">this</span>.parser.parse(</span><br><span class="line">  <span class="keyword">this</span>._ast || <span class="keyword">this</span>._source.source(),</span><br><span class="line">  &#123;</span><br><span class="line">    current: <span class="keyword">this</span>,</span><br><span class="line">    <span class="built_in">module</span>: <span class="keyword">this</span>,</span><br><span class="line">    compilation: compilation,</span><br><span class="line">    options: options</span><br><span class="line">  &#125;,</span><br><span class="line">  (err, result) =&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (result !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="comment">// parse is sync</span></span><br><span class="line">  handleParseResult(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this.parser</code> 即是在 <code>reslove 流程</code> 里的组合对象里得到的 <code>parser</code>。</p><p><code>this.parser.parse</code>，在该方法里如果 <code>this._ast</code> 不存在则传 <code>this._source._value</code> 即代码字符串。 然后进入文件 <code>node_modules/webpack/lib/Parser.js</code> 执行 <code>Parser.parse</code>。</p><h3 id="parser-parse"><a href="#parser-parse" class="headerlink" title="parser.parse"></a>parser.parse</h3><h4 id="析出-ast"><a href="#析出-ast" class="headerlink" title="析出 ast"></a>析出 ast</h4><p>方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ast = Parser.parse(source, &#123;</span><br><span class="line">  sourceType: <span class="keyword">this</span>.sourceType,</span><br><span class="line">  onComment: comments</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Parser.parse</code> 即为 <code>Parser</code> 静态方法，该方法里主要执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ast = acornParser.parse(code, parserOptions); <span class="comment">//即 acorn.Parser</span></span><br></pre></td></tr></table></figure><p><code>webpack</code> 通过 <a href="https://github.com/acornjs/acorn" target="_blank" rel="noopener">acorn</a> 得到源码对应的 <code>ast</code>。<code>ast</code> 相关资料：</p><ul><li><a href="https://github.com/estree/estree/blob/master/es2015.md" target="_blank" rel="noopener">estree</a></li><li><a href="https://juejin.im/post/5c8d3c48f265da2d8763bdaf" target="_blank" rel="noopener">ast 类型查阅</a></li><li><a href="https://astexplorer.net/" target="_blank" rel="noopener">在线测试</a></li></ul><h4 id="遍历-ast-收集依赖"><a href="#遍历-ast-收集依赖" class="headerlink" title="遍历 ast 收集依赖"></a>遍历 ast 收集依赖</h4><p>回到 <code>Parser.parse</code> ，对 <code>ast</code> 进行遍历，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hooks.program.call(ast, comments) === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.detectStrictMode(ast.body);</span><br><span class="line">  <span class="keyword">this</span>.prewalkStatements(ast.body);</span><br><span class="line">  <span class="keyword">this</span>.blockPrewalkStatements(ast.body);</span><br><span class="line">  <span class="keyword">this</span>.walkStatements(ast.body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>this.hooks.program.call(ast, comments)</code></p><p>触发回调 <code>plugin</code>(<code>HarmonyDetectionParserPlugin</code> 和 <code>UseStrictPlugin</code>) 根据是否有 <code>import/export</code> 和 <code>use strict</code> 增加依赖：<code>HarmonyCompatibilityDependency</code>, <code>HarmonyInitDependency</code>，<code>ConstDependency</code></p></li><li><p><code>this.detectStrictMode(ast.body)</code></p><p>检测当前执行块是否有 <code>use strict</code>，并设置 <code>this.scope.isStrict = true</code></p></li><li><p><code>this.prewalkStatements(ast.body)</code></p><ul><li>处理 <code>import</code> 进来的变量，是 <code>import</code> 就增加依赖 <code>HarmonyImportSideEffectDependency</code>，<code>HarmonyImportSpecifierDependency</code>;</li><li>处理 <code>export</code> 出去的变量，是 <code>export</code> 增加依赖 <code>HarmonyExportHeaderDependency</code>，<code>HarmonyExportSpecifierDependency</code></li><li>还会处理其他相关导入导出的变量</li></ul></li><li><p><code>this.blockPrewalkStatements(ast.body)</code></p><p>处理块遍历</p></li><li><p><code>this.walkStatements(ast.body)</code></p><p>用于深入函数内部（方法在 <code>walkFunctionDeclaration</code> 进行递归），然后递归继续查找 <code>ast</code> 上的依赖，异步此处深入会增加依赖 <code>ImportDependenciesBlock</code>;</p></li></ul><p>上述执行结束后，会根据 <code>import/export</code> 的不同情况即模块间的相互依赖关系，在对应的 <code>module.dependencies</code> 上增加相应的依赖。</p><h3 id="各依赖作用解释"><a href="#各依赖作用解释" class="headerlink" title="各依赖作用解释"></a>各依赖作用解释</h3><p>在后面 <code>generate</code> 即 <code>render</code> 阶段，调用这些依赖（<code>Dependency</code>）对应的 <code>template.apply</code> 来渲染生成代码资源。</p><p>以 <code>demo</code> 入口文件 <code>a.js</code> 和 <code>c.js</code> 为例，则依赖为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//a.js module</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dependencies"</span>: [</span><br><span class="line">    <span class="string">"HarmonyCompatibilityDependency"</span>, //对应模板 `HarmonyExportDependencyTemplate` 会在源码里最前面添加如：`__webpack_require__.r(__webpack_exports__);` 的代码，用于定义 exports:__esModule</span><br><span class="line">    <span class="string">"HarmonyInitDependency"</span>, // 对应模板 `HarmonyInitDependencyTemplate`, 下文单独说明其作用</span><br><span class="line">    <span class="string">"ConstDependency"</span>, // 对应模板 `ConstDependencyTemplate` 操作会在源码里将同步 import 语句删掉</span><br><span class="line">    <span class="string">"HarmonyImportSideEffectDependency"</span>, //对应模板 `HarmonyImportSideEffectDependencyTemplate`，执行 apply 调用父类 HarmonyImportDependencyTemplate 的 apply，即为空。</span><br><span class="line">    <span class="string">"HarmonyImportSpecifierDependency"</span> //对应模板 `HarmonyImportSpecifierDependencyTemplate`，会在源码里将引入的变量替换为 webpack 对应的包装变量</span><br><span class="line">  ],</span><br><span class="line">  "blocks": ["ImportDependenciesBlock"] //异步模块  对应模板 `ImportDependencyTemplate`， 会在源码里将本 demo 中的 `import('./c.js')`替换为 `Promise.resolve(/*! import() */).then(__webpack_require__.bind(null, /*! ./c.js */ "./src/c.js"))`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//d.js module</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dependencies"</span>: [</span><br><span class="line">    <span class="string">"HarmonyCompatibilityDependency"</span>,</span><br><span class="line">    <span class="string">"HarmonyInitDependency"</span>,</span><br><span class="line">    <span class="string">"HarmonyExportHeaderDependency"</span>, // 对应模板 `HarmonyExportDependencyTemplate` 会在源码里将关键字 export 删掉</span><br><span class="line">    <span class="string">"HarmonyExportSpecifierDependency"</span> //对应模板 `HarmonyExportSpecifierDependencyTemplate` 执行 apply 为空</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"blocks"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HarmonyInitDependency"><a href="#HarmonyInitDependency" class="headerlink" title="HarmonyInitDependency"></a>HarmonyInitDependency</h4><p>执行其对应 <code>template.apply</code>（文件 <code>HarmonyInitDependency.js</code>）中，先遍历 <code>module.dependencies</code>，判断各依赖对应的 <code>template</code> 是否包含 <code>harmonyInit</code> 和 <code>getHarmonyInitOrder</code> 函数（用于导入的 <code>import</code> 排序），若都存在，则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> order = template.getHarmonyInitOrder(dependency);</span><br></pre></td></tr></table></figure><p>执行对应的 <code>template.getHarmonyInitOrder</code> 用于获取排序的 <code>order</code>，在不同的依赖里根据需要可能会返回 <code>NaN</code>（如 <code>HarmonyImportSideEffectDependencyTemplate</code> 里判断无副作用（<code>sideEffects</code>）就会返回 <code>NaN</code>），最终筛选出不是 <code>NaN</code> 的依赖组成数组 <code>list</code>，即为含有 <code>import</code> 和 <code>export</code> 的依赖，按 <code>order</code> 排序后，<br>执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> list) &#123;</span><br><span class="line">  item.template.harmonyInit(item.dependency, source, runtime, dependencyTemplates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行对应的 <code>template.harmonyInit</code> ，对应模板在源码前加入以下代码:</p><ul><li><code>export</code> 相关（<code>HarmonyExportSpecifierDependency</code>）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* harmony export (binding) */</span></span><br><span class="line"></span><br><span class="line">__webpack_require__.d(__webpack_exports__, <span class="string">'mul'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mul;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>import</code> 相关（<code>HarmonyImportSideEffectDependency</code>，<code>HarmonyImportSpecifierDependency</code>）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* harmony import */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Src_b__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="comment">/*! Src/b */</span> <span class="string">'./src/b.js'</span>);</span><br></pre></td></tr></table></figure><h2 id="生成-buildHash"><a href="#生成-buildHash" class="headerlink" title="生成 buildHash"></a>生成 buildHash</h2><p><code>parse</code> 结束后，在 <code>handleParseResult</code> 里执行 <code>this._initBuildHash(compilation)</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_initBuildHash(compilation) &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = createHash(compilation.outputOptions.hashFunction); <span class="comment">// compilation.outputOptions.hashFunction : md4</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._source) &#123;</span><br><span class="line">        hash.update(<span class="string">"source"</span>);</span><br><span class="line">        <span class="keyword">this</span>._source.updateHash(hash); <span class="comment">// this._value</span></span><br><span class="line">    &#125;</span><br><span class="line">    hash.update(<span class="string">"meta"</span>);</span><br><span class="line">    hash.update(<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.buildMeta));</span><br><span class="line">    <span class="keyword">this</span>._buildHash = <span class="comment">/** @type &#123;string&#125; */</span> (hash.digest(<span class="string">"hex"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webpack</code> 采用 <code>nodejs</code> 提供的加密模块 <a href="https://nodejs.org/api/crypto.html" target="_blank" rel="noopener">crypto</a> 进行 <code>hash</code> 加密。</p><ul><li><code>createHash()</code>： 即执行 <code>new BulkUpdateDecorator(require(&quot;crypto&quot;).createHash(algorithm))</code></li><li><code>hash.update()</code>： 更新 <code>hash</code> 内容</li><li><code>hash.digest(&quot;hex&quot;)</code>：得到 <code>hash</code> 值</li></ul><p>先初始化了 <code>hash</code>， 然后分别 <code>update</code> 了 <code>source</code>，<code>this._value</code>（ <code>this._source.updateHash(hash)</code> 获得，为文件源码），<code>meta</code>，<code>this.buildMeta</code>，最后计算出结果赋给 <code>this._buildHash</code>。</p><p>然后回到文件 <code>Compilation.js</code> 的 <code>module.build</code> 的回调。对 <code>error</code> 和 <code>warning</code> 的处理后，对 <code>module.dependencies</code> 按照代码在文件中出现的先后顺序进行排序，然后触发 <code>Compilation.hooks</code>: <code>succeedModule</code>。</p><h2 id="递归解析依赖"><a href="#递归解析依赖" class="headerlink" title="递归解析依赖"></a>递归解析依赖</h2><p>然后执行回调回到 <code>this.buildModule</code> 的回调里执行 <code>afterBuild</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> afterBuild = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (addModuleResult.dependencies) &#123;</span><br><span class="line">    <span class="keyword">this</span>.processModuleDependencies(<span class="built_in">module</span>, err =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">      callback(<span class="literal">null</span>, <span class="built_in">module</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(<span class="literal">null</span>, <span class="built_in">module</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即判断如果该模块是首次解析则执行 <code>processModuleDependencies</code>。</p><p>一旦某个模块被解析创建后，在 <code>this.addModule(module)</code>（上文已提到）里会设置 <code>addModuleResult.dependencies</code> 为 <code>false</code> 即可以避免该模块重复解析创建依赖。</p><p>在 <code>processModuleDependencies</code> 里，对 <code>mudule</code> 的 <code>dependencies</code>, <code>blocks</code>（懒加载 <code>import xx</code> 会存入）, <code>variables</code>（内部变量 <code>__resourceQuery</code> ）分别处理，其中对 <code>blocks</code> 的处理会递归调用。整理过滤没有标识 <code>Identifier</code> 的 <code>module</code>，得到 <code>sortedDependencies</code>（以 <code>module a</code> 为例）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sortedDependencies = [</span><br><span class="line">  &#123;</span><br><span class="line">    factory: NormalModuleFactory,</span><br><span class="line">    dependencies: [HarmonyImportSideEffectDependency, HarmonyImportSpecifierDependency]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    factory: NormalModuleFactory,</span><br><span class="line">    dependencies: [ImportDependency]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>然后调用 <code>this.addModuleDependencies</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">addModuleDependencies(<span class="built_in">module</span>, dependencies, bail, cacheGroup, recursive, callback) &#123;</span><br><span class="line"><span class="comment">// dependencies 即为上文中的 sortedDependencies</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  asyncLib.forEach(</span><br><span class="line">      dependencies,</span><br><span class="line">      (item, callback) =&gt; &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">const</span> semaphore = <span class="keyword">this</span>.semaphore;</span><br><span class="line">        semaphore.acquire(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> factory = item.factory;</span><br><span class="line">          factory.create(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;,(err, dependentModule) =&gt; &#123;</span><br><span class="line">                <span class="comment">// 回调内容</span></span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      err =&gt; &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> process.nextTick(callback);</span><br><span class="line">      &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <a href="https://caolan.github.io/async/v3/docs.html#each" target="_blank" rel="noopener">asyncLib.forEach</a> <code>forEach</code> 会将回调传给 <code>iterator</code>，在出现 <code>err</code> 或 <code>iterator</code> 全部执行后执行回调。</p><p>批量调用每个依赖的 <code>NormalModuleFactory.create</code>，即与前文<code>moduleFactory.create</code> 功能一致。所以重复开始走 <code>reslove 流程</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NormalModuleFactory.create -&gt; resolve流程 -&gt; 初始化<span class="built_in">module</span> -&gt; add <span class="built_in">module</span> -&gt; <span class="built_in">module</span> build -&gt; afterBuild -&gt; processModuleDependencies</span><br></pre></td></tr></table></figure><p>就这样，从入口 <code>module</code> 开始，根据 <code>module</code> 间的依赖关系，递归调用将所有的 <code>module</code> 都转换编译。</p><h2 id="入口-module-生成"><a href="#入口-module-生成" class="headerlink" title="入口 module 生成"></a>入口 module 生成</h2><p>在依赖转换完成后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> process.nextTick(callback);</span><br></pre></td></tr></table></figure><p>将在 <code>nodejs</code> 下一次事件循环时调用 <code>callback</code> 即执行 <code>this.processModuleDependencies</code> 的回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.processModuleDependencies(<span class="built_in">module</span>, err =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">  callback(<span class="literal">null</span>, <span class="built_in">module</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时返回一个入口 <code>module</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"module"</span>: &#123;</span><br><span class="line">    //...</span><br><span class="line">    //同步模块</span><br><span class="line">    "dependencies": ["HarmonyImportSideEffectDependency", "HarmonyImportSpecifierDependency"],</span><br><span class="line">    //异步模块</span><br><span class="line">    "blocks": ["ImportDependenciesBlock"]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>this._addModuleChain</code> 的回调,触发 <code>compilation.hooks</code>:<code>succeedEntry</code>, 到此 <code>mudule</code> 生成结束!</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>调用 <code>parser</code> 将前面 <code>runloaders</code> 的编译结果通过 <code>acorn</code> 转换为 <code>ast</code>；</li><li>遍历 <code>ast</code> 根据导入导出及异步的情况触发相关钩子插件收集依赖，这些依赖用于解析递归依赖和模板操作；</li><li>根据每个 <code>module</code> 的相关信息生成各自唯一的 <code>buildHash</code>；</li><li>根据 <code>module</code> 间的相互依赖关系，递归解析所有依赖 <code>module</code>，最终返回一个入口 <code>module</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（六）：构建 module（上）</title>
      <link href="/377.html"/>
      <url>/377.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><h2 id="初始化-module"><a href="#初始化-module" class="headerlink" title="初始化 module"></a>初始化 module</h2><p>接上文，在 <code>resolver</code> 函数回调里，触发 <code>normalModuleFactory.hooks</code>:<code>afterResolve</code> 之后，回调里执行:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createdModule = <span class="keyword">this</span>.hooks.createModule.call(result); <span class="comment">// result 即为 resolver 返回的组合对象 data</span></span><br><span class="line"><span class="keyword">if</span> (!createdModule) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!result.request) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Empty dependency (no request)'</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createdModule = <span class="keyword">new</span> NormalModule(result);</span><br><span class="line">&#125;</span><br><span class="line">createdModule = <span class="keyword">this</span>.hooks.module.call(createdModule, result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> callback(<span class="literal">null</span>, createdModule);</span><br></pre></td></tr></table></figure><p>这里触发 <code>normalModuleFactory.hooks</code>:<code>createModule</code>，如果钩子里没有项目配置的自定义 <code>module</code>，则使用 <code>webpack</code> 生成的 <code>module</code>。</p><h3 id="add-module"><a href="#add-module" class="headerlink" title="add module"></a>add module</h3><p>得到 <code>module</code> 实例，接着触发 <code>normalModuleFactory.hooks</code>:<code>module</code> 之后，跳出 <code>factory</code> 函数，执行 <code>factory</code> 函数回调进行依赖缓存后，跳出 <code>create</code> 函数执行 <code>moduleFactory.create</code> 的回调。回调里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addModuleResult = <span class="keyword">this</span>.addModule(<span class="built_in">module</span>); <span class="comment">// 将这个 `module` 保存到全局的 `Compilation.modules` 数组中和 `_modules` 对象中，判断`_modules`是否有该 module 来设置是否已加载的标识</span></span><br><span class="line"><span class="built_in">module</span> = addModuleResult.module;</span><br><span class="line"></span><br><span class="line">onModule(<span class="built_in">module</span>); <span class="comment">// 如果是入口文件还会将 modules 保存到 `Compilation.entries`</span></span><br><span class="line"></span><br><span class="line">dependency.module = <span class="built_in">module</span>;</span><br><span class="line"><span class="built_in">module</span>.addReason(<span class="literal">null</span>, dependency); <span class="comment">// 添加该 `module` 被哪些模块依赖</span></span><br></pre></td></tr></table></figure><p>然后调用 <code>this.buildModule</code> 进入 <code>build</code> 阶段。该方法做了回调缓存后，触发 <code>compilation.hooks</code>:<code>buildModule</code>，然后执行 <code>module.build()</code>。</p><h2 id="构建-module"><a href="#构建-module" class="headerlink" title="构建 module"></a>构建 module</h2><p>在 <code>/node_modules/webpack/lib/NormalModule.js</code> 文件里执行 <code>module.build</code>, 设置一些属性后，直接调用了 <code>this.doBuild</code>。</p><p>该方法里先执行了 <code>this.createLoaderContext</code> 得到<code>loaderContext</code>，为所有的 <code>loader</code> 提供上下文环境并共享，然后调用了 <code>runLoaders</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">runLoaders(</span><br><span class="line">  &#123;</span><br><span class="line">    resource: <span class="keyword">this</span>.resource,</span><br><span class="line">    loaders: <span class="keyword">this</span>.loaders,</span><br><span class="line">    context: loaderContext,</span><br><span class="line">    readResource: fs.readFile.bind(fs)</span><br><span class="line">  &#125;,</span><br><span class="line">  (err, result) =&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="loader-runner"><a href="#loader-runner" class="headerlink" title="loader-runner"></a>loader-runner</h3><p>该方法来自 <code>loader-runner</code>，通过各种 <code>loader</code> 处理源码后，得到一个处理后的 <code>string</code> 或 <code>buffer</code>（可能还有个 <code>sourcemap</code>）。</p><p>还可以解析自定义 <code>loader</code> <a href="https://webpack.docschina.org/contribute/writing-a-loader" target="_blank" rel="noopener">编写一个 loader</a>。</p><p>主要流程为：</p><p><code>runLoaders</code> -&gt; <code>iteratePitchingLoaders（按正序 require 每个 loader）</code> -&gt; <code>loadLoader（对应的 loader 导出的函数赋值到 loaderContext.loader[].normal、pitch函数赋值到loaderContext.loader[].pitch，然后执行pitch函数（如果有的话））</code> -&gt; <code>processResource（转换 buffer 和设置 loaderIndex）</code> -&gt; <code>iterateNormalLoaders（倒序执行所有 loader）</code>-&gt; <code>runSyncOrAsync（同步或者异步执行 loader）</code></p><h4 id="pitch-函数"><a href="#pitch-函数" class="headerlink" title="pitch 函数"></a>pitch 函数</h4><ul><li><p>每个 <code>loader</code> 可以挂载一个 <code>pitch</code> 函数，该函数主要是用于利用 <code>module</code> 的 <code>request</code>，来提前做一些拦截处理的工作，并不实际处理 <code>module</code> 内容<a href="https://webpack.js.org/api/loaders/#pitching-loader" target="_blank" rel="noopener">文档</a>。</p></li><li><p>正序 <code>require</code> <code>loader</code> 并执行其 <code>pitch</code> 方法（ <code>loadLoader</code> 里），在执行后的回调里，如果有除了 <code>err</code> 的参数还有其他参数，则执行 <code>iterateNormalLoaders</code> 越过剩下的未 <code>require</code> 的 <code>loader</code> 直接进入到执行 <code>loader</code> 的步骤。如果想没有其他参数，则执行 <code>iteratePitchingLoaders</code> 进行下个 <code>loader</code> 的 <code>require</code>。如代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  loaderContext.loaderIndex--;</span><br><span class="line">  iterateNormalLoaders(options, loaderContext, args, callback);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  iteratePitchingLoaders(options, loaderContext, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>倒序执行每个 <code>loader</code> 的 <code>normal</code> 方法 。</p></li></ul><h4 id="核心代码解析"><a href="#核心代码解析" class="headerlink" title="核心代码解析"></a>核心代码解析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法按正序 require 每个 loader</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratePitchingLoaders</span>(<span class="params">options, loaderContext, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// abort after last loader 读取所有 loader 后，执行 processResource 方法</span></span><br><span class="line">  <span class="keyword">if</span> (loaderContext.loaderIndex &gt;= loaderContext.loaders.length) <span class="keyword">return</span> processResource(options, loaderContext, callback);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex]; <span class="comment">//选择第一个  loader</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// iterate 增序后递归读取下一个 loader</span></span><br><span class="line">  <span class="keyword">if</span> (currentLoaderObject.pitchExecuted) &#123;</span><br><span class="line">    loaderContext.loaderIndex++;</span><br><span class="line">    <span class="keyword">return</span> iteratePitchingLoaders(options, loaderContext, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// load loader module 加载该 loader 模块</span></span><br><span class="line">  <span class="comment">// 对应的 loader 导出的函数赋值到 loaderContext.loader[].normal</span></span><br><span class="line">  loadLoader(currentLoaderObject, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      loaderContext.cacheable(<span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">return</span> callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fn = currentLoaderObject.pitch; <span class="comment">//loadLoader 里会把 module 赋值到 loader.normal, pitch 赋值到 loader.pitch</span></span><br><span class="line">    currentLoaderObject.pitchExecuted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fn) <span class="keyword">return</span> iteratePitchingLoaders(options, loaderContext, callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有的话，开始执行 pitch 函数，根据参数情况决定是否继续读取剩下的loader</span></span><br><span class="line">    runSyncOrAsync(fn, loaderContext, [loaderContext.remainingRequest, loaderContext.previousRequest, (currentLoaderObject.data = &#123;&#125;)], <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">      <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        loaderContext.loaderIndex--;</span><br><span class="line">        iterateNormalLoaders(options, loaderContext, args, callback);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        iteratePitchingLoaders(options, loaderContext, callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换 buffer 和设置 loaderIndex</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processResource</span>(<span class="params">options, loaderContext, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// set loader index to last loader 获取最后一个 loader 的 index</span></span><br><span class="line">  loaderContext.loaderIndex = loaderContext.loaders.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> resourcePath = loaderContext.resourcePath;</span><br><span class="line">  <span class="keyword">if</span> (resourcePath) &#123;</span><br><span class="line">    loaderContext.addDependency(resourcePath);</span><br><span class="line">    <span class="comment">// 转换为 buffer</span></span><br><span class="line">    options.readResource(resourcePath, <span class="function"><span class="keyword">function</span>(<span class="params">err, buffer</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">      options.resourceBuffer = buffer; <span class="comment">//得到buffer</span></span><br><span class="line">      iterateNormalLoaders(options, loaderContext, [buffer], callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iterateNormalLoaders(options, loaderContext, [<span class="literal">null</span>], callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//倒序执行所有 loader</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterateNormalLoaders</span>(<span class="params">options, loaderContext, args, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (loaderContext.loaderIndex &lt; <span class="number">0</span>) <span class="keyword">return</span> callback(<span class="literal">null</span>, args); <span class="comment">//执行完所有 loader 后退出，去执行 iteratePitchingLoaders 回调即 runLoaders 的回调</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex]; <span class="comment">//获取对应 loader</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// iterate 减序后递归执行下一个 loader</span></span><br><span class="line">  <span class="keyword">if</span> (currentLoaderObject.normalExecuted) &#123;</span><br><span class="line">    loaderContext.loaderIndex--;</span><br><span class="line">    <span class="keyword">return</span> iterateNormalLoaders(options, loaderContext, args, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fn = currentLoaderObject.normal;</span><br><span class="line">  currentLoaderObject.normalExecuted = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> iterateNormalLoaders(options, loaderContext, args, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  convertArgs(args, currentLoaderObject.raw);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行 loader 函数</span></span><br><span class="line">  runSyncOrAsync(fn, loaderContext, args, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//loader 执行结果的回调</span></span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>); <span class="comment">// arg:[] 为 loader 转换结果（字符串或者buffer+可能有的sourcemap）</span></span><br><span class="line">    iterateNormalLoaders(options, loaderContext, args, callback); <span class="comment">//递归，并将转换结果一并传入</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步或者异步执行 loader 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runSyncOrAsync</span>(<span class="params">fn, context, args, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isSync = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> isDone = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> isError = <span class="literal">false</span>; <span class="comment">// internal error</span></span><br><span class="line">  <span class="keyword">var</span> reportedError = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//异步处理</span></span><br><span class="line">  context.async = <span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDone) &#123;</span><br><span class="line">      <span class="keyword">if</span> (reportedError) <span class="keyword">return</span>; <span class="comment">// ignore</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'async(): The callback was already called.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isSync = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> innerCallback;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 异步后会执行此方法，loader 的结果会作为参数传导出来</span></span><br><span class="line">  <span class="keyword">var</span> innerCallback = (context.callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDone) &#123;</span><br><span class="line">      <span class="keyword">if</span> (reportedError) <span class="keyword">return</span>; <span class="comment">// ignore</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'callback(): The callback was already called.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isDone = <span class="literal">true</span>;</span><br><span class="line">    isSync = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// arguments 为 loader 结果，第一个值为 null 第二个为字符串或者 buffer，第三个为 SourceMap</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = (<span class="function"><span class="keyword">function</span> <span class="title">LOADER_EXECUTION</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(context, args); <span class="comment">//执行 loader 函数，参数传递前一个 loader 的执行结果</span></span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="keyword">if</span> (isSync) &#123;</span><br><span class="line">      isDone = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (result === <span class="literal">undefined</span>) <span class="keyword">return</span> callback();</span><br><span class="line">      <span class="keyword">if</span> (result &amp;&amp; <span class="keyword">typeof</span> result === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> result.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result.then(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">          callback(<span class="literal">null</span>, r);</span><br><span class="line">        &#125;, callback);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> callback(<span class="literal">null</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>实例化 <code>NormalModule</code> 得到初始化的 <code>module</code>，然后在 <code>build</code> 过程中先 <code>run loader</code> 处理源码，得到一个编译后的字符串或 <code>buffer</code>。</li><li>在 <code>run loader</code> 的过程中，先正序执行了每个 <code>loader</code> 的 <code>pitch</code> ，然后倒序执行了每个 <code>loader</code> 的 <code>normal</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（五）：reslove 流程</title>
      <link href="/376.html"/>
      <url>/376.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><h2 id="触发-NormalModuleFactory-hooks-factory"><a href="#触发-NormalModuleFactory-hooks-factory" class="headerlink" title="触发 NormalModuleFactory.hooks:factory"></a>触发 <code>NormalModuleFactory.hooks</code>:<code>factory</code></h2><p>接上文，来到 <code>NormalModuleFactory.js</code> 文件，该 <code>create</code> 先触发了 <code>normalModuleFactory.hooks:beforeResolve</code>，然后在回调里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factory = <span class="keyword">this</span>.hooks.factory.call(<span class="literal">null</span>);</span><br><span class="line">factory(result, (err, <span class="built_in">module</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>触发 <code>NormalModuleFactory.hooks:factory</code>，该事件返回了一个 <code>factory</code> 函数。接着执行该 <code>factory</code> 函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resolver = <span class="keyword">this</span>.hooks.resolver.call(<span class="literal">null</span>);</span><br><span class="line">resolver(result, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>factory</code> 函数触发 <code>NormalModuleFactory.hooks</code>:<code>resolver</code> 后，最终在 <code>resolver</code> 的回调里创建一个 <code>normalModule</code> 实例。</p><h2 id="触发-NormalModuleFactory-hooks-resolver"><a href="#触发-NormalModuleFactory-hooks-resolver" class="headerlink" title="触发 NormalModuleFactory.hooks:resolver"></a>触发 <code>NormalModuleFactory.hooks</code>:<code>resolver</code></h2><p>触发 <code>NormalModuleFactory.hooks:resolver</code> 该事件返回了一个 <code>resolver</code> 函数。</p><p>执行 <code>resolver</code> 函数，该函数作用为解析构建所有 <code>module</code> 所需要的 <code>loaders</code> 的绝对路径及这个 <code>module</code> 的相关构建信息(例如获取 <code>module</code> 的 <code>packge.json</code> 等。</p><p>在函数里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderResolver = <span class="keyword">this</span>.getResolver(<span class="string">'loader'</span>);</span><br><span class="line"><span class="keyword">const</span> normalResolver = <span class="keyword">this</span>.getResolver(<span class="string">'normal'</span>, data.resolveOptions);</span><br></pre></td></tr></table></figure><ul><li><code>loaderResolver</code> 为用于解析 <code>loader</code> 的绝对路径</li><li><code>normalResolver</code> 用于解析 <code>文件</code> 和 <code>module</code> 的绝对路径</li></ul><p><code>this.getResolver</code> 会执行 <code>resolverFactory.get</code>，判断缓存后，即执行 <code>webpack/lib/ResolverFactory.js</code> 里的 <code>_create</code>，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resolveOptions = <span class="keyword">this</span>.hooks.resolveOptions.for(type).call(resolveOptions);</span><br><span class="line"><span class="keyword">const</span> resolver = Factory.createResolver(resolveOptions);</span><br></pre></td></tr></table></figure><p>此时触发的 <code>ResolverFactory.hooks: resolveOptions for (type)</code> 即在 <code>编译前的准备 - 注册 resolverFactory.hooks 阶段</code> 所注册。</p><p>在该钩子里通过 <code>cachedCleverMerge</code> 判断缓存及融合配置（如果是 <code>loaderResolver</code> 则为 <strong>配置项: <code>options.resolveLoader</code></strong>，如果是 <code>normalResolver</code> 则为 <strong>配置项: <code>options.resolve</code></strong>），并添加了属性 <code>fileSystem: compiler.inputFileSystem</code>，返回一个 <code>resolveOptions</code> 对象，作为<code>Factory.createResolver</code> 执行的参数。</p><p><code>Factory</code> 为 <code>require(&quot;enhanced-resolve&quot;).ResolverFactory</code>，所以此处进入到<code>enhanced-resolve</code> 包的阶段。</p><h2 id="enhanced-resolve"><a href="#enhanced-resolve" class="headerlink" title="enhanced-resolve"></a>enhanced-resolve</h2><p>执行 <code>Factory.createResolver(resolveOptions)</code>，进入文件 <code>node_modules/enhanced-resolve/lib/ResolverFactory.js</code>，先融合处理了项目配置 <code>resolve</code> 与默认配置 <code>resolve/resolveLoader</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!resolver) &#123;</span><br><span class="line">  resolver = <span class="keyword">new</span> Resolver(useSyncFileSystemCalls ? <span class="keyword">new</span> SyncAsyncFileSystemDecorator(fileSystem) : fileSystem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有传入项目的 <code>resolver</code>，那么就自己 <code>new</code> 一个。接着定义了 <code>Resolver</code> 的生命周期钩子和根据配置 <code>push</code> 了一大堆的 <code>plugins</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins.forEach(<span class="function"><span class="params">plugin</span> =&gt;</span> &#123;</span><br><span class="line">  plugin.apply(resolver);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对每一个插件执行 <code>apply</code>，主要作用是获取到 <code>hooks</code> 后，在 <code>Resolver</code> 的不同生命周期钩子上注册了一些事件，然后在事件末尾执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取hooks</span></span><br><span class="line"><span class="keyword">const</span> target = resolver.ensureHook(<span class="keyword">this</span>.target);</span><br><span class="line"><span class="comment">// 触发插件后的回调里，执行：</span></span><br><span class="line"> resolver.doResolve(target, obj, ...);</span><br></pre></td></tr></table></figure><p><code>target</code> 为事件钩子 <code>hook</code>，在触发完当前插件后，最后通过 <code>doResolve</code> 将 <code>hook</code> 带入到下一个插件中，实现了递归串联调用一系列的插件。包括：<code>UnsafeCachePlugin，ParsePlugin，DescriptionFilePlugin，NextPlugin，AliasPlugin，AliasFieldPlugin，ModuleKindPlugin，SymlinkPlugin</code> 等等，完成各自的插件操作。</p><p>注册事件完成后，最后得到返回 <code>resolver</code> 对象回到 <code>_create</code> 触发 <code>ResolverFactory.hooks: resolver for (type)</code>，此处可以对 <code>resolver</code> 进行篡改。然后返回对应的 <code>resolver</code> 回到 <code>NormalModuleFactory.hooks</code>: <code>resolver</code> 的钩子函数里继续执行。</p><p><code>resolver</code> 对象暴露 <code>resolve</code> 方法，用于解析路径。</p><h2 id="解析-inline-loader-和-resource"><a href="#解析-inline-loader-和-resource" class="headerlink" title="解析 inline loader 和 resource"></a>解析 inline loader 和 resource</h2><p>继续执行，先进行 <code>inline loader</code> 和对应资源文件 <code>resource</code> 的解析:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> elements = requestWithoutMatchResource</span><br><span class="line">  .replace(<span class="regexp">/^-?!+/</span>, <span class="string">''</span>)</span><br><span class="line">  .replace(<span class="regexp">/!!+/g</span>, <span class="string">'!'</span>)</span><br><span class="line">  .split(<span class="string">'!'</span>);</span><br><span class="line"><span class="keyword">let</span> resource = elements.pop();</span><br><span class="line">elements = elements.map(identToLoaderRequest);</span><br></pre></td></tr></table></figure><p>如<code>&#39;import Styles from style-loader!css-loader?modules!./styles.css&#39;</code>，会得到：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"resource"</span>: <span class="string">"./styles.css"</span>,</span><br><span class="line">  <span class="attr">"elements"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"loader"</span>: <span class="string">"style-loader"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"loader"</span>: <span class="string">"css-loader"</span>,</span><br><span class="line">      <span class="attr">"options"</span>: <span class="string">"modules"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asyncLib.parallel(</span><br><span class="line">  [</span><br><span class="line">    callback =&gt; <span class="keyword">this</span>.resolveRequestArray(contextInfo, context, elements, loaderResolver, callback), <span class="comment">// 解析`elements`(`inline loader`)</span></span><br><span class="line">    callback =&gt; &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      normalResolver.resolve(contextInfo, context, resource, &#123;&#125;, (err, resource, resourceResolveData) =&gt; &#123;...&#125;); <span class="comment">// //解析对应的 `module` 的绝对路径等信息</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  (err, results) =&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>asyncLib</code> 来自 <code>neo-async</code> 包<a href="https://www.npmjs.com/package/neo-async" target="_blank" rel="noopener">npm</a>， <code>asyncLib.parallel</code> <a href="http://suguru03.github.io/neo-async/doc/async.parallel.html" target="_blank" rel="noopener">API 文档</a> 会并行处理参数数组各任务，任务都完成之后，返回一个 <code>results</code> 列表，列表顺序为参数数组顺序，与执行顺序无关。</p><p><code>this.resolveRequestArray</code> 内部采用 <code>asyncLib.map</code> 循环调用 <code>resolver.resolve</code>。</p><p>得到 <code>results</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"results"</span>: [</span><br><span class="line">    [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"loader"</span>: <span class="string">"loader的绝对路径1"</span>,</span><br><span class="line">        <span class="attr">"options"</span>: <span class="string">"loader参数1"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"loader"</span>: <span class="string">"loader的绝对路径2"</span>,</span><br><span class="line">        <span class="attr">"options"</span>: <span class="string">"loader参数2"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"resource"</span>: <span class="string">"模块绝对路径"</span>,</span><br><span class="line">      <span class="attr">"resourceResolveData"</span>: <span class="string">"模块基本信息（即enhanced-resolve执行结果）"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析-config-module-rules-里的-loader"><a href="#解析-config-module-rules-里的-loader" class="headerlink" title="解析 config module rules 里的 loader"></a>解析 config module rules 里的 loader</h2><p>在回调里执行:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">this</span>.ruleSet.exec(&#123;</span><br><span class="line">  resource: resourcePath,</span><br><span class="line">  realResource: matchResource !== <span class="literal">undefined</span> ? resource.replace(<span class="regexp">/\?.*/</span>, <span class="string">''</span>) : resourcePath,</span><br><span class="line">  resourceQuery, <span class="comment">// module 路径上所带的 query 参数</span></span><br><span class="line">  issuer: contextInfo.issuer, <span class="comment">// 所解析的 module 的发布者</span></span><br><span class="line">  compiler: contextInfo.compiler</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>exec</code>（上一章已经介绍过）过滤 <code>webpack.config.js</code> 中得到 <code>module</code> 所需要的 <code>loader</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"result"</span>: [</span><br><span class="line">    &#123; <span class="attr">"type"</span>: <span class="string">"type"</span>, <span class="attr">"value"</span>: <span class="string">"javascript/auto"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">"type"</span>: <span class="string">"resolve"</span>, <span class="attr">"value"</span>: &#123;&#125; &#125;,</span><br><span class="line">    &#123; <span class="attr">"type"</span>: <span class="string">"use"</span>, <span class="attr">"value"</span>: &#123; <span class="attr">"loader"</span>: <span class="string">"babel-loader"</span> &#125; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并，排序-loader"><a href="#合并，排序-loader" class="headerlink" title="合并，排序 loader"></a>合并，排序 loader</h2><p>接着处理了 <code>inline loader</code> 如果带有前缀<code>!</code>,<code>!!</code>,<code>-!</code>（注意，这部分的 <code>API</code> 在中文文档上没有写，要在官方原版文档里才有<a href="https://webpack.js.org/concepts/loaders/#inline" target="_blank" rel="noopener">链接</a>）和 <code>result</code> 项带有 <code>enforce</code> 参数的情况，用来对 <code>loader</code>的禁用和排序。</p><p>最后得到 <code>useLoadersPost</code>, <code>useLoadersPre</code>, <code>useLoaders</code>, <code>settings:{type: &quot;javascript/auto&quot;, resolve: {}}</code>，并通过 <code>asyncLib.parallel</code> 与 <code>this.resolveRequestArray</code> 并行处理 <code>useLoadersPost</code>, <code>useLoadersPre</code>, <code>useLoaders</code> 得到对应的 <code>resolve</code> 结果即路径信息，在回调里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (matchResource === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  loaders = results[<span class="number">0</span>].concat(loaders, results[<span class="number">1</span>], results[<span class="number">2</span>]); <span class="comment">//参数 loaders 为inline loader</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  loaders = results[<span class="number">0</span>].concat(results[<span class="number">1</span>], loaders, results[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序、合并 <code>loader</code>，即 <code>loaders</code> 顺序为 <code>postLoader，inlineLoader，loader（normal config loader），preLoader</code>。因为 <code>loader</code> 是从右至左执行，即执行顺序为 <code>preLoader，loader（normal config loader），inlineLoader，postLoader</code>。</p><h2 id="得到-data"><a href="#得到-data" class="headerlink" title="得到 data"></a>得到 data</h2><p>最后输出以下组合对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">callback(<span class="literal">null</span>, &#123;</span><br><span class="line">  context: context,</span><br><span class="line">  request: loaders</span><br><span class="line">    .map(loaderToIdent)</span><br><span class="line">    .concat([resource])</span><br><span class="line">    .join(<span class="string">'!'</span>),</span><br><span class="line">  dependencies: data.dependencies,</span><br><span class="line">  userRequest,</span><br><span class="line">  rawRequest: request,</span><br><span class="line">  loaders,</span><br><span class="line">  resource,</span><br><span class="line">  matchResource,</span><br><span class="line">  resourceResolveData,</span><br><span class="line">  settings,</span><br><span class="line">  type,</span><br><span class="line">  parser: <span class="keyword">this</span>.getParser(type, settings.parser),</span><br><span class="line">  generator: <span class="keyword">this</span>.getGenerator(type, settings.generator),</span><br><span class="line">  resolveOptions</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中：</p><h2 id="getParser"><a href="#getParser" class="headerlink" title="getParser"></a>getParser</h2><p>主要作用是为该 <code>module</code> 提供 <code>parser</code>，用于解析模块为 <code>ast</code>。</p><p><code>this.getParser(type, settings.parser)</code> 创建 <code>parser</code> 并缓存。</p><p>执行 <code>createParser</code>，方法里触发 <code>NormalModuleFactory.hooks:createParser for (type)</code>，该事件注册在 <code>JavascriptModulesPlugin</code> 插件，根据 <code>type</code> 不同返回不同的 <code>parser</code> 实例。</p><p>实例化之后，触发 <code>NormalModuleFactory.hooks:parser for (type)</code>，会去注册一些在 <code>parser</code> 阶段（遍历解析 <code>ast</code> 的时候）被触发的 <code>hooks</code>。</p><h2 id="getGenerator"><a href="#getGenerator" class="headerlink" title="getGenerator"></a>getGenerator</h2><p>主要作用是为该 <code>module</code> 提供 <code>generator</code>，用于模版生成时提供方法。</p><p>与 <code>parser</code> 类似，<code>this.getGenerator(type, settings.generator)</code> 创建 <code>generator</code> 并缓存。</p><p>执行 <code>createGenerator</code>，方法里触发 <code>NormalModuleFactory.hooks:createGenerator for (type)</code>,该事件注册在 <code>JavascriptModulesPlugin</code> 插件，根据 <code>type</code> 不同返回不同的 <code>generator</code> 实例（目前代码里都是返的一致的 <code>new JavascriptGenerator()</code> ）。</p><p>实例化之后，触发 <code>NormalModuleFactory.hooks:generator for (type)</code>。</p><p>得到这个组合对象 <code>data</code> 后，跳出 <code>resolver</code> 函数，执行 <code>resolver</code> 函数回调，到此 <code>resolve</code> 流程结束，开启创建 <code>module</code> 流程！</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>在 <code>resolver</code> 里，先通过 <code>enhanced-resolve</code> 获取 <code>resolver</code>，提供 <code>resolve</code> 方法。</li><li>解析 <code>inline loader</code> 和 <code>resource</code> 和项目配置的 <code>loader</code>，然后根据配置对其进行合并，排序。</li><li>调用 <code>getParser</code> 和 <code>getGenerator</code> 得到 <code>module</code> 对应的 <code>parser</code> 和 <code>generator</code>，用于后面的 <code>ast</code> 解析及模板生成。</li><li>最后输出一个组合对象 <code>data</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（四）：reslove 前的准备</title>
      <link href="/375.html"/>
      <url>/375.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><h2 id="compiler-run"><a href="#compiler-run" class="headerlink" title="compiler.run"></a>compiler.run</h2><p><code>compiler.run</code>是整个编译过程启动的入口，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.beforeRun.callAsync(<span class="keyword">this</span>, err =&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">this</span>.hooks.run.callAsync(<span class="keyword">this</span>, err =&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// recordsInputPath是webpack配置中指定的读取上一组records的文件路径</span></span><br><span class="line">    <span class="keyword">this</span>.readRecords(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">this</span>.compile(onCompiled);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在方法中先触发 <code>compiler.hooks</code>: <code>beforeRun</code>，执行之前注册的 <code>NodeEnvironmentPlugin</code>（该插件此时判断 <code>inputFileSystem</code> 是否被配置，如未配置则执行 <code>purge</code> 清理方法），然后在回调里触发 <code>compiler.hooks</code>: <code>run</code>，然后回调里 <code>this.readRecords</code> 是用于读取之前的 <code>records</code> 的方法，再在它的回调里执行 <code>this.compile(onCompiled)</code>。</p><p><code>onCompiled</code> 在 <code>compile</code> 过程后调用，主要用于输出构建资源。</p><h2 id="compiler-compile"><a href="#compiler-compile" class="headerlink" title="compiler.compile"></a>compiler.compile</h2><p><code>compile</code> 是真正进行编译的过程，最终会把所有原始资源编译为目标资源。实例化了一个 <code>compilation</code>，并将 <code>compilation</code> 传给 <code>make</code> 钩子上的方法，注册在这些钩子上的方法会调用 <code>compilation</code> 上的 <code>addEntry</code>，执行构建。</p><h3 id="获取-compilation-所需-params"><a href="#获取-compilation-所需-params" class="headerlink" title="获取 compilation 所需 params"></a>获取 compilation 所需 params</h3><p><code>this.compile</code> 先执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">this</span>.newCompilationParams();</span><br></pre></td></tr></table></figure><p>即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">newCompilationParams() &#123;</span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">        normalModuleFactory: <span class="keyword">this</span>.createNormalModuleFactory(),</span><br><span class="line">        contextModuleFactory: <span class="keyword">this</span>.createContextModuleFactory(),</span><br><span class="line">        compilationDependencies: <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法先实例化了 <code>NormalModuleFactory</code> 类和 <code>ContextModuleFactory</code> 类，两个类均扩展于 <code>tapable</code>。接下来具体说明这两个类。</p><h4 id="实例化-NormalModuleFactory"><a href="#实例化-NormalModuleFactory" class="headerlink" title="实例化 NormalModuleFactory"></a>实例化 NormalModuleFactory</h4><p><code>NormalModuleFactory</code> 类用于创建一个 <code>normalModule</code> 实例。</p><h5 id="实例化-RuleSet"><a href="#实例化-RuleSet" class="headerlink" title="实例化 RuleSet"></a>实例化 RuleSet</h5><p>在实例化 <code>NormalModuleFactory</code> 执行 <code>constructor</code> 的过程中，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.ruleSet = <span class="keyword">new</span> RuleSet(options.defaultRules.concat(options.rules));</span><br></pre></td></tr></table></figure><ul><li><code>options.defaultRules</code> 是在之前文件 <code>WebpackOptionsDefaulter.js</code> 中被初始化，然后与项目配置的 <code>module.rules</code> 合并；</li><li>每个<a href="https://webpack.docschina.org/configuration/module/#rule" target="_blank" rel="noopener">规则</a>可以分为三部分 - 条件<code>condition</code>(如 <code>test, include, exclude</code>)，结果<code>result</code>(如应用的 <code>loader，parse</code> 选项) 和嵌套规则<code>nested rule</code>（如 <code>rules</code>）；</li><li><a href="https://webpack.docschina.org/configuration/module/#%E6%9D%A1%E4%BB%B6" target="_blank" rel="noopener">条件</a>可接受 正则表达式，字符串，函数等。</li><li><code>new RuleSet</code> 实例化过程中，会对每一项 <code>rule</code> 进行进行处理，递归调用静态方法 <code>normalizeCondition</code> 处理 <code>condition</code> 相关，最终每一个 <code>condition</code> 都处理为一个 <code>newRule.resource</code> 函数；递归调用 <code>normalizeUse</code> 处理 <code>result</code> 相关，最终每一个 <code>result</code> 都处理为一个 <code>use</code> 数组，数组的每一项包含 <code>loader</code> 和 <code>options</code>；</li><li>调用 <code>ruleSet</code> 的实例 <code>exec</code> 时，传入目标路径和相关信息后，在内部 <code>_run</code> 里，进行递归过滤匹配出对应的 <code>loader</code>，最终得到 <code>result</code> 数组，数组每一项包含 <code>type，value（loader 和 options）</code> 等；</li></ul><h5 id="注册-normalModuleFactory-hooks-factory"><a href="#注册-normalModuleFactory-hooks-factory" class="headerlink" title="注册 normalModuleFactory.hooks:factory"></a>注册 <code>normalModuleFactory.hooks</code>:<code>factory</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.factory.tap(<span class="string">'NormalModuleFactory'</span>, () =&gt; <span class="function">(<span class="params">result, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> resolver = <span class="keyword">this</span>.hooks.resolver.call(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resolver(result, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时注册了 <code>normalModuleFactory.hooks</code>:<code>factory</code>，当后面触发该 <code>hooks</code> 时，该回调返回一个函数。函数内的运行须先触发 <code>normalModuleFactory.hooks</code>:<code>resolver</code>，然后执行其回调结果。</p><h5 id="注册-normalModuleFactory-hooks-resolver"><a href="#注册-normalModuleFactory-hooks-resolver" class="headerlink" title="注册 normalModuleFactory.hooks:resolver"></a>注册 <code>normalModuleFactory.hooks</code>:<code>resolver</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks.resolver.tap(<span class="string">'NormalModuleFactory'</span>, () =&gt; <span class="function">(<span class="params">data, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时注册了 <code>normalModuleFactory.hooks</code>:<code>resolver</code>，跟<code>normalModuleFactory.hooks</code>:<code>factory</code> 相同，当后面触发该 <code>hooks</code> 时，该回调返回一个函数。</p><h4 id="实例化-ContextModuleFactory"><a href="#实例化-ContextModuleFactory" class="headerlink" title="实例化 ContextModuleFactory"></a>实例化 ContextModuleFactory</h4><p>除了兼容老版本之外的代码，没有什么特别需要注意的。</p><p>在这两个类实例化完成后，分别触发 <code>compiler.hooks</code>: <code>normalModuleFactory</code> ，<code>contextModuleFactory</code>。</p><h3 id="实例化-compilation"><a href="#实例化-compilation" class="headerlink" title="实例化 compilation"></a>实例化 compilation</h3><p><code>this.compile</code> 继续执行,触发 <code>compiler.hooks</code>: <code>beforeCompile</code>，<code>compile</code>, 然后在回调中执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compilation = <span class="keyword">this</span>.newCompilation(params);</span><br></pre></td></tr></table></figure><p>该方法实例化了一个 <code>Compilation</code>，也是扩展于 <code>tapable</code>。<strong>一个 <code>compilation</code> 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息，代表了一次资源的构建</strong>。</p><p>在添加了一些属性后，触发<code>compiler.hooks</code>:<code>thisCompilation</code>,<code>compilation</code>。回忆在 <code>编译前的准备 - 注册plugins阶段 - WebpackOptionsApply.js</code> 的文件里注册了大量该 <code>hooks</code> 的事件，在此时拿到 <code>compilation</code> 对象后，开始执行这一系列事件。</p><ul><li><code>compiler.hooks</code>:<code>thisCompilation</code> 会在 <code>compilation</code> 对象的 <code>hooks</code> 里注册一些新的事件；</li><li><code>compiler.hooks</code>:<code>compilation</code> 会在 <code>compilation</code>、<code>normalModuleFactory</code> 对象的 <code>hooks</code> 里注册一些新的事件，同时还会往 <code>compilation.dependencyFactories</code>（工厂类），<code>compilation.dependencyTemplates</code>（模板类） 增加依赖模块。</li></ul><blockquote><p>为什么这里需要 <code>thisCompilation，compilation</code> 两个钩子？原因是跟子编译器有关。在 <code>Compiler</code> 的 <code>createChildCompiler</code> 方法里创建子编译器，其中 <code>thisCompilation</code> 钩子不会被复制，而 <code>compilation</code> 会被复制。<br>子编译器拥有完整的 <code>module</code> 和 <code>chunk</code> 生成，通过子编译器可以独立于父编译器执行一个核心构建流程，额外生成一些需要的 <code>module</code> 和 <code>chunk</code>。</p></blockquote><h2 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h2><p><code>this.compile</code> 继续执行，触发 <code>compiler.hooks</code> : <code>make</code> ,执行之前在 <code>SingleEntryPlugin | MultiEntryPlugin</code> 注册的的 <code>make</code> 事件，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compilation.addEntry(context, dep, name, callback);</span><br></pre></td></tr></table></figure><h3 id="compilation-addEntry"><a href="#compilation-addEntry" class="headerlink" title="compilation.addEntry"></a>compilation.addEntry</h3><p>来到 <code>Compilation.js</code> 文件，<code>addEntry</code> 触发了 <code>compilation.hooks</code>:<code>addEntry</code>，定义了入口对象 <code>_preparedEntrypoints</code> 之后，直接执行了 <code>this._addModuleChain</code>。</p><p>在该方法里，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">const</span> Dep = <span class="comment">/** @type &#123;DepConstructor&#125; */</span> (dependency.constructor);</span><br><span class="line"><span class="keyword">const</span> moduleFactory = <span class="keyword">this</span>.dependencyFactories.get(Dep);</span><br></pre></td></tr></table></figure><p>因 <code>dependency = SingleEntryPlugin.createDependency(entry, name)</code> 即 <code>new SingleEntryDependency(entry)</code>，则 <code>Dep</code> 则为 <code>SingleEntryDependency</code> 类，而在之前 <code>compiler.hooks:compilation</code> 的注册事件中添加了依赖： <code>compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory)</code>，所以 <code>moduleFactory</code> 为 <code>normalModuleFactory</code>。</p><h3 id="开始创建-module"><a href="#开始创建-module" class="headerlink" title="开始创建 module"></a>开始创建 module</h3><h4 id="编译队列控制：semaphore-acquire"><a href="#编译队列控制：semaphore-acquire" class="headerlink" title="编译队列控制：semaphore.acquire"></a>编译队列控制：semaphore.acquire</h4><p>执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.semaphore.acquire(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  moduleFactory.create(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    (err, <span class="built_in">module</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>this.semaphore</code> 这个类是一个编译队列控制，原理很简单，对执行进行了并发控制，默认并发数为 <code>100</code>，超过后存入 <code>semaphore.waiters</code>，根据情况再调用 <code>semaphore.release</code> 去执行存入的事件 <code>semaphore.waiters</code>。</p><h4 id="moduleFactory-create"><a href="#moduleFactory-create" class="headerlink" title="moduleFactory.create"></a>moduleFactory.create</h4><p><code>this.semaphore.acquire</code> 里执行了 <code>moduleFactory.create</code>。（<strong>注：递归解析依赖的重复也从此处开始</strong>）</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>从编译过程启动的入口 <code>compiler.run</code> 开始，触发了一系列的生命周期钩子后，执行 <code>compiler.compile</code>。</li><li>获取 <code>compilation</code> 所需 <code>params</code>，实例化 <code>NormalModuleFactory</code> 类（插件会去注册其钩子） 及 <code>ContextModuleFactory</code> 类，在实例化 <code>NormalModuleFactory</code> 的过程中，会实例化 <code>RuleSet</code> 及注册钩子 <code>factory</code> 和 <code>resolver</code>。</li><li>实例化 <code>Compilation</code>，传入 <code>params</code> 参数，触发之前在注册 <code>plugin</code> 阶段所注册的 <code>NormalModuleFactory</code> 下的 <code>hooks</code>。</li><li>触发 <code>make</code> 钩子执行 <code>compilation.addEntry</code>，通过编译队列控制 <code>semaphore.acquire</code> 执行 <code>moduleFactory.create</code> 开始创建 <code>module</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（三）：编译前的准备</title>
      <link href="/374.html"/>
      <url>/374.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><h2 id="Compiler-简述"><a href="#Compiler-简述" class="headerlink" title="Compiler 简述"></a>Compiler 简述</h2><ul><li><code>webpack/lib/Compiler.js</code> 该文件是 <code>webpack</code> 的核心, <code>Compiler</code> 类定义了整个构建的流程，而后文的 <code>Compilation</code> 类则负责如何具体去构建;</li><li><code>new Compiler</code> 执行 <code>constructor</code>，首先扩展了 <code>Tapable</code>，在 <code>constructor</code> 里定义了一堆钩子 <code>done,beforeRun,run,emit</code> 等等;</li><li>然后注册了<code>this._pluginCompat.tap(&quot;Compiler&quot;)</code>，这个用来兼容之前的老版 <code>webpack</code> 的 <code>plugin</code> 的钩子，触发时机在<code>tapable/lib/Tapable.js</code>里调用<code>plugin</code> 的时候;</li><li>该 <code>Compiler</code> 类的 <code>run</code> 即为整个打包的主流程函数；</li></ul><h2 id="封装-FS"><a href="#封装-FS" class="headerlink" title="封装 FS"></a>封装 FS</h2><p>继续执行 <code>webpack.js</code>，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> NodeEnvironmentPlugin(&#123;</span><br><span class="line">  infrastructureLogging: options.infrastructureLogging</span><br><span class="line">&#125;).apply(compiler);</span><br></pre></td></tr></table></figure><p>该类主要对文件系统做了一些封装，包括<code>输入，输出，缓存，监听</code>等等，这些扩展后的方法全部挂载在 <code>compiler</code> 对象下。</p><h2 id="注册-plugins"><a href="#注册-plugins" class="headerlink" title="注册 plugins"></a>注册 plugins</h2><h3 id="项目配置的-plugins"><a href="#项目配置的-plugins" class="headerlink" title="项目配置的 plugins"></a>项目配置的 plugins</h3><p>然后对自己 <code>config</code> 文件里的 <code>plugins</code> 进行了注册：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.plugins &amp;&amp; <span class="built_in">Array</span>.isArray(options.plugins)) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> options.plugins) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.call(compiler, compiler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      plugin.apply(compiler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，会把 <code>compiler</code> 实例传进去供 <code>plugin</code> 使用，<code>compiler</code> 包含整个构建流程的全部钩子，通过它可以把控整个 <code>webpack</code> 构建周期。</p><p>掌握流程里各对象（如 <code>compiler</code>，<code>compilation</code>）的事件钩子触发的时机，就是掌握如何写一个插件的关键。<a href="https://webpack.docschina.org/contribute/writing-a-plugin/" target="_blank" rel="noopener">如何写一个 webpack 插件？</a></p><p>接着触发了 <code>compiler</code> 的 <code>hooks</code>: <code>environment，afterEnvironment</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler.options = <span class="keyword">new</span> WebpackOptionsApply().process(options, compiler);</span><br></pre></td></tr></table></figure><h3 id="项目默认的-plugins"><a href="#项目默认的-plugins" class="headerlink" title="项目默认的 plugins"></a>项目默认的 plugins</h3><p>该 <code>WebpackOptionsApply</code> 类的 <code>process</code> 除了把配置里的一些属性添加到 <code>compiler</code> 对象下，更主要的是根据 <code>options</code> 的配置不同，注册激活一些默认自带的插件和 <code>resolverFactory.hooks</code>，大部分插件的作用是往 <code>compiler.hooks:compilation,thisCompilation</code> 里注册一些事件（此时该钩子已经获取到 <code>normalModuleFactory</code> 等参数），如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> JavascriptModulesPlugin().apply(compiler); <span class="comment">//给normalModuleFactory的js模块提供Parser、JavascriptGenerator对象 ，并给seal阶段的template提供renderManifest数组（包含render方法）</span></span><br><span class="line"><span class="keyword">new</span> JsonModulesPlugin().apply(compiler); <span class="comment">//给normalModuleFactory的json模块提供Parser、JavascriptGenerator对象</span></span><br><span class="line"><span class="keyword">new</span> WebAssemblyModulesPlugin(&#123;</span><br><span class="line">  mangleImports: options.optimization.mangleWasmImports</span><br><span class="line">&#125;).apply(compiler); <span class="comment">// 同理，webassembly模块</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> EntryOptionPlugin().apply(compiler);</span><br><span class="line">compiler.hooks.entryOption.call(options.context, options.entry); <span class="comment">//创建多入口还是单入口 SingleEntryPlugin | MultiEntryPlugin，两者均会在 apply 方法里注册 Compiler.hooks:compilation, make</span></span><br></pre></td></tr></table></figure><p>插件处理完毕后，触发 <code>compiler.hooks</code>: <code>afterPlugins</code>。</p><h2 id="注册-resolverFactory-hooks"><a href="#注册-resolverFactory-hooks" class="headerlink" title="注册 resolverFactory.hooks"></a>注册 resolverFactory.hooks</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">compiler.resolverFactory.hooks.resolveOptions.for(<span class="string">'normal'</span>).tap(<span class="string">'WebpackOptionsApply'</span>, resolveOptions =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(</span><br><span class="line">    &#123;</span><br><span class="line">      fileSystem: compiler.inputFileSystem</span><br><span class="line">    &#125;,</span><br><span class="line">    cachedCleverMerge(options.resolve, resolveOptions) <span class="comment">//配置项 options.resolve</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">compiler.resolverFactory.hooks.resolveOptions.for(<span class="string">'context'</span>).tap(<span class="string">'WebpackOptionsApply'</span>, resolveOptions =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(</span><br><span class="line">    &#123;</span><br><span class="line">      fileSystem: compiler.inputFileSystem,</span><br><span class="line">      resolveToContext: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    cachedCleverMerge(options.resolve, resolveOptions) <span class="comment">//配置项 options.resolve</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">compiler.resolverFactory.hooks.resolveOptions.for(<span class="string">'loader'</span>).tap(<span class="string">'WebpackOptionsApply'</span>, resolveOptions =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(</span><br><span class="line">    &#123;</span><br><span class="line">      fileSystem: compiler.inputFileSystem</span><br><span class="line">    &#125;,</span><br><span class="line">    cachedCleverMerge(options.resolveLoader, resolveOptions) <span class="comment">//配置项 options.resolveLoader</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后注册 <code>compiler.resolverFactory.hooks: resolveOptions for (normal/context/loader)</code>，目的是为 <code>Factory.createResolver</code> 提供默认的参数对象（含有相关的 <code>resolve</code> 项目配置项）。</p><p>注册完成后，触发 <code>compiler.hooks</code>: <code>afterResolvers</code>，到此 <code>compiler</code> 初始化完毕。</p><h2 id="回到-cli-js"><a href="#回到-cli-js" class="headerlink" title="回到 cli.js"></a>回到 cli.js</h2><p>回到<code>cli.js</code>，处理配置项 <code>progress</code> 和 <code>infoVerbosity</code>，然后判断 <code>options</code> 里是否有 <code>watch</code>，有则走 <code>compiler.watch</code>，无则走 <code>compiler.run</code>，这里我们走<code>compiler.run</code>，进入 <code>webpack</code> 核心构建流程！</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>实例化了 <code>Compiler</code>，它扩展于<code>Tapable</code>，是 <code>webapck</code> 的核心；</li><li>封装了输入输出等方法 <code>FS</code> ，然后注册了 <code>plugins</code>，包括项目配置的和项目默认的；</li><li>注册 <code>resolverFactory.hooks</code> 用于 <code>Factory.createResolver</code> 方法提供参数对象；</li><li>最后根据配置是否有 <code>watch</code> 来决定程序走向。</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（二）：配置初始化</title>
      <link href="/373.html"/>
      <url>/373.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><p>通过在 <code>cli</code> 执行命令 <code>webpack</code> 开始，以 <code>development</code> 模式为例，暂时忽略支线剧情（错误响应，缓存等等），只分析探索 <code>webpack</code> 的打包主流程。</p><h2 id="选择-cli"><a href="#选择-cli" class="headerlink" title="选择 cli"></a>选择 cli</h2><p>根据 <code>npm</code> 的<a href="https://docs.npmjs.com/files/package.json#bin" target="_blank" rel="noopener">规则</a>，<code>cli</code> 执行 <code>webpack</code> 后，就会去执行 <code>node_modules/.bin/webpack</code> 文件即 <code>node_modules/webpack/bin/webpack.js</code>。所以这里我们的 <code>npm scripts</code> 中的 <code>debug</code> 直接调试的 <code>node_modules/.bin/webpack</code> 的代码。 代码中通过:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.resolve(packageName);</span><br></pre></td></tr></table></figure><p>判断是否安装了包 <code>webpack-cli</code> 或者 <code>webpack-command</code>，通过安装的数量处理后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(path.resolve(path.dirname(pkgPath), pkg.bin[installedClis[<span class="number">0</span>].binName]));</span><br></pre></td></tr></table></figure><p>即执行 <code>node_modules/webpack-cli/bin/cli.js</code>，</p><h2 id="webpack-cli"><a href="#webpack-cli" class="headerlink" title="webpack-cli"></a>webpack-cli</h2><p>该文件为一个自执行函数，<code>import-local</code> 包用于优先选用本地包，<code>v8-compile-cache</code> 包用于 <code>v8</code> <a href="https://github.com/flyyang/blog/issues/13" target="_blank" rel="noopener">缓存优化</a>。</p><h3 id="配置-yargs"><a href="#配置-yargs" class="headerlink" title="配置 yargs"></a>配置 yargs</h3><p>接下来配置了 <code>yargs</code>的帮助等信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"./config/config-yargs"</span>)(yargs)；</span><br></pre></td></tr></table></figure><p>在文件 <code>node_modules/webpack-cli/bin/config/config-yargs.js</code> 里可以查阅具体的配置内容。</p><p>然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yargs.parse(process.argv.slice(<span class="number">2</span>), (err, argv, output) =&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 <code>yargs.parse</code> 的回调里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options = <span class="built_in">require</span>(<span class="string">'./utils/convert-argv'</span>)(argv);</span><br></pre></td></tr></table></figure><h2 id="合并-cli-参数与项目配置参数"><a href="#合并-cli-参数与项目配置参数" class="headerlink" title="合并 cli 参数与项目配置参数"></a>合并 cli 参数与项目配置参数</h2><p><code>convert-argv.js</code> 主要做了对 <code>cli</code> 所传的参数与项目配置进行融合，并处理部分参数，最终得到一个 <code>options</code>。</p><p>先处理了部分特定参数后（可能会有多个项目配置），然后通过一系列（<code>findup</code>,<code>interpret</code>）的处理，得到配置文件的路径值: <code>/nice/wpDemo/webpack.config.js</code>。然后读取 <code>webpack.config.js</code> 这个文件后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processConfiguredOptions(options[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>方法里先对 <code>options</code> 的类型进行了验证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validateOptions(options);</span><br></pre></td></tr></table></figure><p>验证无误后，对项目配置文件进行了一系列的判断，包括是否是多数组，函数等等。最后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processOptions(options);</span><br></pre></td></tr></table></figure><p>在该方法里，通过 <code>ifArg</code> 对融合了 <code>cli</code> 参数配置和项目配置（<code>cli</code> 参数优先级更高），包括 <code>mode</code>，<code>entry</code> 等等，然后跳出 <code>processOptions</code> 继续执行，根据 <code>cli</code> 参数有没有 <code>watch</code> 相关而做一些处理。</p><h2 id="统计数据-stats-配置"><a href="#统计数据-stats-配置" class="headerlink" title="统计数据 stats 配置"></a>统计数据 stats 配置</h2><p><code>processOptions</code> 执行完后，回到 <code>cli.js</code> 文件执行同名方法 <code>processOptions</code> ，传入了融合了后的配置 <code>options</code>，然后对配置中的统计信息（<code>options.stats</code>）进行了处理。</p><h2 id="webpack-js"><a href="#webpack-js" class="headerlink" title="webpack.js"></a>webpack.js</h2><p>最后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  compiler = webpack(options);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里引入了<code>webpack</code>（<code>node_modules/webpack/lib/webpack.js</code>）, <code>webpack</code> 挂载了很多内置的插件，如 <code>BannerPlugin</code> 等等, 然后执行 <code>webpack</code>。</p><p>先通过 <code>ajv</code> 验证配置的每一项是否合法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackOptionsValidationErrors = validateSchema(webpackOptionsSchema, options);</span><br></pre></td></tr></table></figure><p>然后判断如果 <code>options</code> 是数组则执行多个<code>webpack(options)</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options = <span class="keyword">new</span> WebpackOptionsDefaulter().process(options);</span><br></pre></td></tr></table></figure><p>该方法在文件 <code>WebpackOptionsDefaulter.js</code> 里，初始化默认的 <code>config</code> 配置后，然后通过 <code>WebpackOptionsDefaulter</code> 的原始类 <code>OptionsDefaulter</code> 上的 <code>process</code> 方法 <code>merge</code> 了项目配置。然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler = <span class="keyword">new</span> Compiler(options.context); <span class="comment">// options.context为当前项目绝对路径</span></span><br></pre></td></tr></table></figure><p><code>options</code> 是系统默认的配置与项目自定义配置两种融合的结果，此时<code>项目配置</code>与<code>默认配置</code>都已处理完毕，进入编译前的准备。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li><code>webpack</code> 先选择了 <code>cli</code> 后，配置了 <code>yargs</code> 相关信息；</li><li>通过 <code>yarg</code> 解析了 <code>cli</code> 相关参数后，与读取到的配置文件的配置相融合；</li><li>统计数据 <code>stats</code> 配置后，执行方法 <code>webpack</code>，融合了项目配置与默认配置，最终得到 <code>options</code> 挂载到变量 <code>compiler</code> 下。</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（一）：前言及总流程概览</title>
      <link href="/372.html"/>
      <url>/372.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此系列文章作为笔记，用于记录分析 <code>webpack</code> 源码主流程的过程。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>根据 <code>webpack</code> 构建流程及相关，本系列文章一共分为以下章节：</p><ol><li>配置初始化</li><li>编译前的准备</li><li>reslove 前的准备</li><li>reslove 流程</li><li>构建 module（上）</li><li>构建 module（下）</li><li>生成 chunk</li><li>优化 chunk</li><li>资源的构建</li><li>文件的生成</li><li>打包后文件解析</li><li>watch</li><li>webpack 优化</li></ol><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><code>webpack</code> 构建流程图：</p><p><img src="http://cdn.flqin.com/p372-1.jpeg" alt="webpack 构建流程"></p><h2 id="本系列代码环境"><a href="#本系列代码环境" class="headerlink" title="本系列代码环境"></a>本系列代码环境</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"devDependencies": &#123;</span><br><span class="line">  "@babel/core": "^7.7.5",</span><br><span class="line">  "@babel/preset-env": "^7.7.6",</span><br><span class="line">  "@fe_korey/test-loader": "^1.0.0",</span><br><span class="line">  "babel-loader": "^8.0.6",</span><br><span class="line">  "html-webpack-plugin": "^3.2.0"</span><br><span class="line">&#125;,</span><br><span class="line">"dependencies": &#123;</span><br><span class="line">  "webpack": "^4.41.2",</span><br><span class="line">  "webpack-cli": "^3.3.10"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本不同，源码略微有差异。</p><p>本项目 <code>demo</code> 开源在<a href="https://github.com/zhaoky/webpack-demo" target="_blank" rel="noopener">github</a>，欢迎交流学习。</p><h2 id="分析源码前的一系列准备工作"><a href="#分析源码前的一系列准备工作" class="headerlink" title="分析源码前的一系列准备工作"></a>分析源码前的一系列准备工作</h2><p>采用 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vscode</a> 来打断点调试分析。</p><h3 id="配置-vscode"><a href="#配置-vscode" class="headerlink" title="配置 vscode"></a>配置 vscode</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//launch.json</span><br><span class="line">  "configurations": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Launch Program"</span>,</span><br><span class="line">      <span class="attr">"runtimeExecutable"</span>: <span class="string">"npm"</span>,</span><br><span class="line">      <span class="attr">"runtimeArgs"</span>: [<span class="string">"run"</span>, <span class="string">"debug"</span>],</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">5858</span>,</span><br><span class="line">      <span class="attr">"console"</span>: <span class="string">"externalTerminal"</span>,</span><br><span class="line">      <span class="attr">"skipFiles"</span>: [<span class="string">"&lt;node_internals&gt;/**/*.js"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p><a href="https://code.visualstudio.com/docs/nodejs/nodejs-debugging" target="_blank" rel="noopener">这些配置是怎么来的？</a></p><h3 id="配置-npm-script"><a href="#配置-npm-script" class="headerlink" title="配置 npm script"></a>配置 npm script</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "debug": "node --inspect-brk=5858 ./node_modules/.bin/webpack"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="了解-webpack-的插件架构"><a href="#了解-webpack-的插件架构" class="headerlink" title="了解 webpack 的插件架构"></a>了解 webpack 的插件架构</h3><p><code>webpack</code> 从配置初始化到打包完成定义了一个生命周期，在这个生命周期中的每一个阶段定义一些不同的功能。<code>webpack</code> 的流程同样也是一个事件驱动的架构，利用插件系统 <code>tabpable</code>，通过 <code>发布订阅事件</code> 来实现所有内部的，外部扩展的功能。</p><h3 id="了解-webpack-的核心模块"><a href="#了解-webpack-的核心模块" class="headerlink" title="了解 webpack 的核心模块"></a>了解 webpack 的核心模块</h3><p><code>webpack</code> 的构建是通过 <code>Compiler</code> 控制构建流程，<code>Compilation</code> 解析，<code>ModuleFactory</code> 生成模块，<code>Parser</code> 解析源码，<code>Template</code> 渲染代码，最后输出打包后的文件。</p><h3 id="了解-tapable"><a href="#了解-tapable" class="headerlink" title="了解 tapable"></a>了解 tapable</h3><p><code>tabpable</code> 本质就是一个事件发布订阅机制，支持同步异步，使用<code>xxx.tap</code>之类的来<strong>事件订阅</strong>，使用<code>xxx.call</code>之类的来进行<strong>事件发布</strong>。相关文档查阅：</p><ul><li><a href="https://github.com/webpack/tapable" target="_blank" rel="noopener">git 仓库</a></li><li><a href="https://www.cnblogs.com/tugenhua0707/p/11317557.html" target="_blank" rel="noopener">用法解析</a></li><li><a href="https://juejin.im/post/5c12046af265da612b1377aa" target="_blank" rel="noopener">源码分析</a></li><li><a href="https://www.jianshu.com/p/c2a5457c1c95" target="_blank" rel="noopener">伪代码实现</a></li></ul><h3 id="demo-准备"><a href="#demo-准备" class="headerlink" title="demo 准备"></a>demo 准备</h3><h4 id="npm-安装"><a href="#npm-安装" class="headerlink" title="npm 安装"></a>npm 安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-cli webpack</span><br><span class="line">npm i @babel/core @babel/preset-env babel-loader -D</span><br><span class="line">npm i @fe_korey/<span class="built_in">test</span>-loader -D</span><br></pre></td></tr></table></figure><h4 id="demo-文件"><a href="#demo-文件" class="headerlink" title="demo 文件"></a>demo 文件</h4><p>我们以 <code>development</code> 模式为例，暂时忽略支线剧情，只分析探索 <code>webpack</code> 的打包主流程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">'Src/b'</span>;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./c.js'</span>).then(<span class="function"><span class="params">m</span> =&gt;</span> m.sub(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">add(<span class="number">3</span>, <span class="number">2</span> + a);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mul &#125; <span class="keyword">from</span> <span class="string">'@fe_korey/test-loader?number=20!Src/e'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + mul(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addddd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/c.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mul &#125; <span class="keyword">from</span> <span class="string">'Src/d'</span>;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./b.js'</span>).then(<span class="function"><span class="params">m</span> =&gt;</span> m.add(<span class="number">200</span>, <span class="number">100</span>));</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b + mul(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/d.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> d = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    bundle: <span class="string">'./src/a.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'none'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span>,</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash:4].js'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'[name].[chunkhash:8].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      Src: path.resolve(__dirname, <span class="string">'src/'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'babel-loader'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//babel.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [<span class="string">'@babel/env'</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="一颗坚定且耐操的心"><a href="#一颗坚定且耐操的心" class="headerlink" title="一颗坚定且耐操的心"></a>一颗坚定且耐操的心</h3><p>为什么要阅读它？</p><ul><li>因为可以让我们更好的理解海量配置，知道每一个配置在打包的具体哪个环节</li><li>在对构建流程进行优化时能更清楚的根据过程思考优化点</li><li>还可以学习下在这种大型项目里，如何实现稳定的架构和良好的扩展性</li><li>对自定义开发一些 <code>plugin</code> 和 <code>loader</code> 有更深刻的理解</li><li>了解它的一些代码设计方式能给我们的日常搬砖带来一些新的启发</li></ul><p>最重要的还是想满足自己的好奇欲，想知道在这犀利的打包背后，到底是怎么实现的。</p><p><code>webpack</code> 里包含数不清的变量和钩子，海量插件，这些足以让你怀疑人生，请务必保持一颗耐操的心。 一切准备就绪后，进入 <code>vscode</code> 的调试模式！</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>proxy适用场景</title>
      <link href="/371.html"/>
      <url>/371.html</url>
      
        <content type="html"><![CDATA[<p><code>proxy</code> 在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">文档查阅</a></p><p><code>Proxy</code> 是一种代理模式，常用于三个方面：</p><ul><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul><p>正因为此，可以做一些<code>中间件</code>相关的事情。</p><h2 id="抽离校验模块"><a href="#抽离校验模块" class="headerlink" title="抽离校验模块"></a>抽离校验模块</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  pickyMethodOne: <span class="function"><span class="keyword">function</span>(<span class="params">obj, str, num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  pickyMethodTwo: <span class="function"><span class="keyword">function</span>(<span class="params">num, obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> argTypes = &#123;</span><br><span class="line">  pickyMethodOne: [<span class="string">'object'</span>, <span class="string">'string'</span>, <span class="string">'number'</span>],</span><br><span class="line">  pickyMethodTwo: [<span class="string">'number'</span>, <span class="string">'object'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, key, proxy) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> checkArgs = argChecker(key, args, argTypes[key]);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(value, target, args);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argChecker</span>(<span class="params">name, args, checkers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> idx = <span class="number">0</span>; idx &lt; args.length; idx++) &#123;</span><br><span class="line">    <span class="keyword">var</span> arg = args[idx];</span><br><span class="line">    <span class="keyword">var</span> type = checkers[idx];</span><br><span class="line">    <span class="keyword">if</span> (!arg || <span class="keyword">typeof</span> arg !== type) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`You are incorrectly implementing the signature of <span class="subst">$&#123;name&#125;</span>. Check param <span class="subst">$&#123;idx + <span class="number">1</span>&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.pickyMethodOne();</span><br><span class="line">obj.pickyMethodTwo(<span class="string">'wopdopadoo'</span>, &#123;&#125;);</span><br><span class="line">obj.pickyMethodOne(&#123;&#125;, <span class="string">'a little string'</span>, <span class="number">123</span>);</span><br><span class="line">obj.pickyMethodOne(<span class="number">123</span>, &#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> api = &#123;</span><br><span class="line">  _apiKey: <span class="string">'123abc456def'</span>,</span><br><span class="line">  getUsers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  getUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId</span>) </span>&#123;&#125;,</span><br><span class="line">  setUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId, config</span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> RESTRICTED = [<span class="string">'_apiKey'</span>];</span><br><span class="line">api = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key, proxy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (RESTRICTED.indexOf(key) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is restricted. Please see api documentation for further info.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, proxy);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, key, value, proxy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (RESTRICTED.indexOf(key) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is restricted. Please see api documentation for further info.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, value, proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 以下操作都会抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(api._apiKey);</span><br><span class="line">api._apiKey = <span class="string">'987654321'</span>;</span><br></pre></td></tr></table></figure><h2 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> api = &#123;</span><br><span class="line">  _apiKey: <span class="string">'123abc456def'</span>,</span><br><span class="line">  getUsers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  setUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId, config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMethodAsync</span>(<span class="params">timestamp, method</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;timestamp&#125;</span> - Logging <span class="subst">$&#123;method&#125;</span> request asynchronously.`</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">api = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, key, proxy) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...arguments</span>) </span>&#123;</span><br><span class="line">      logMethodAsync(<span class="keyword">new</span> <span class="built_in">Date</span>(), key);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(value, target, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">api.getUsers();</span><br></pre></td></tr></table></figure><h2 id="预警和拦截"><a href="#预警和拦截" class="headerlink" title="预警和拦截"></a>预警和拦截</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataStore = &#123;</span><br><span class="line">  noDelete: <span class="number">1235</span>,</span><br><span class="line">  oldMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  doNotChange: <span class="string">'tried and true'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> NODELETE = [<span class="string">'noDelete'</span>];</span><br><span class="line"><span class="keyword">const</span> NOCHANGE = [<span class="string">'doNotChange'</span>];</span><br><span class="line"><span class="keyword">const</span> DEPRECATED = [<span class="string">'oldMethod'</span>];</span><br><span class="line">dataStore = <span class="keyword">new</span> <span class="built_in">Proxy</span>(dataStore, &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value, proxy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (NOCHANGE.includes(key)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`Error! <span class="subst">$&#123;key&#125;</span> is immutable.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, proxy);</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteProperty(target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (NODELETE.includes(key)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`Error! <span class="subst">$&#123;key&#125;</span> cannot be deleted.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, key);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>(target, key, proxy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEPRECATED.includes(key)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`Warning! <span class="subst">$&#123;key&#125;</span> is deprecated.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> val = target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'function'</span></span><br><span class="line">      ? <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">Reflect</span>.apply(target[key], target, args);</span><br><span class="line">        &#125;</span><br><span class="line">      : val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// these will throw errors or log warnings, respectively</span></span><br><span class="line">dataStore.doNotChange = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">delete</span> dataStore.noDelete;</span><br><span class="line">dataStore.oldMethod();</span><br></pre></td></tr></table></figure><h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  getGiantFile: <span class="function"><span class="keyword">function</span>(<span class="params">fileId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key, proxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> id = args[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">let</span> isEnroute = checkEnroute(id);</span><br><span class="line">      <span class="keyword">let</span> isDownloading = checkStatus(id);</span><br><span class="line">      <span class="keyword">let</span> cached = getCached(id);</span><br><span class="line">      <span class="keyword">if</span> (isEnroute || isDownloading) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cached) &#123;</span><br><span class="line">        <span class="keyword">return</span> cached;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(target[key], target, args);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="中断代理"><a href="#中断代理" class="headerlink" title="中断代理"></a>中断代理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  username: <span class="string">'korey'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(data, &#123;&#125;);</span><br><span class="line"><span class="comment">// logs 'devbryce'</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.username);</span><br><span class="line">revoke();</span><br><span class="line"><span class="comment">// TypeError: Revoked</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.username);</span><br></pre></td></tr></table></figure><h2 id="解决对象属性为-undefined-的问题"><a href="#解决对象属性为-undefined-的问题" class="headerlink" title="解决对象属性为 undefined 的问题"></a>解决对象属性为 undefined 的问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> handlers = &#123;</span><br><span class="line">    <span class="keyword">get</span>: (target, property) =&gt; &#123;</span><br><span class="line">      target[property] = property <span class="keyword">in</span> target ? target[property] : &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> target[property] === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target[property], handlers);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target[property];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handlers);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'z'</span> <span class="keyword">in</span> proxy.x.y); <span class="comment">// false (其实这一步已经针对`target`创建了一个x.y的属性)</span></span><br><span class="line">  proxy.x.y.z = <span class="string">'hello'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'z'</span> <span class="keyword">in</span> proxy.x.y); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(target.x.y.z); <span class="comment">// hello</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="普通函数与构造函数的兼容处理"><a href="#普通函数与构造函数的兼容处理" class="headerlink" title="普通函数与构造函数的兼容处理"></a>普通函数与构造函数的兼容处理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(a, b) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>, a, b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test(1, 2) // throw an error</span></span><br><span class="line"><span class="keyword">let</span> proxyClass = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Test, &#123;</span><br><span class="line">  apply(target, thisArg, argumentsList) &#123;</span><br><span class="line">    <span class="comment">// 如果想要禁止使用非new的方式来调用函数，直接抛出异常即可</span></span><br><span class="line">    <span class="comment">// throw new Error(`Function $&#123;target.name&#125; cannot be invoked without 'new'`)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> (target.bind(thisArg, ...argumentsList))();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxyClass(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// constructor 1 2</span></span><br></pre></td></tr></table></figure><h2 id="包装-fetch"><a href="#包装-fetch" class="headerlink" title="包装 fetch"></a>包装 fetch</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handlers = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, property) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target.init) &#123;</span><br><span class="line">      <span class="comment">// 初始化对象</span></span><br><span class="line">      [<span class="string">'GET'</span>, <span class="string">'POST'</span>].forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">        target[method] = <span class="function">(<span class="params">url, params = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> fetch(url, &#123;</span><br><span class="line">            headers: &#123;</span><br><span class="line">              <span class="string">'content-type'</span>: <span class="string">'application/json'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            mode: <span class="string">'cors'</span>,</span><br><span class="line">            credentials: <span class="string">'same-origin'</span>,</span><br><span class="line">            method,</span><br><span class="line">            ...params</span><br><span class="line">          &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json());</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target[property];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> API = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handlers);</span><br></pre></td></tr></table></figure><h2 id="断言工具"><a href="#断言工具" class="headerlink" title="断言工具"></a>断言工具</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> assert = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, message, value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!value) <span class="built_in">console</span>.error(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">assert[<span class="string">"Isn't true"</span>] = <span class="literal">false</span>; <span class="comment">// Error: Isn't true</span></span><br><span class="line">assert[<span class="string">'Less than 18'</span>] = <span class="number">18</span> &gt;= <span class="number">19</span>; <span class="comment">// Error: Less than 18</span></span><br></pre></td></tr></table></figure><h2 id="统计函数调用次数"><a href="#统计函数调用次数" class="headerlink" title="统计函数调用次数"></a>统计函数调用次数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orginFunction</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyFunction = <span class="keyword">new</span> <span class="built_in">Proxy</span>(orginFunction, &#123;</span><br><span class="line">  apply (target, thisArg. argumentsList) &#123;</span><br><span class="line">    log(XXX)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target.apply(thisArg, argumentsList)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实现双绑比-Object-defineProperty-的优势"><a href="#实现双绑比-Object-defineProperty-的优势" class="headerlink" title="实现双绑比 Object.defineProperty 的优势"></a>实现双绑比 Object.defineProperty 的优势</h2><ul><li>可以直接监听对象而非属性</li><li>可以直接监听数组的变化</li><li>有多达 13 种拦截方法,不限于 <code>apply、ownKeys、deleteProperty、has</code> 等等</li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）了解HTML5中的MutationObserver</title>
      <link href="/370.html"/>
      <url>/370.html</url>
      
        <content type="html"><![CDATA[<p><code>MutationObserver</code> 翻译过来就是变动观察器，字面上就可以理解这是用来观察 <code>Node</code>（节点）变化的。<code>MutationObserver</code> 是在 <code>DOM4</code> 规范中定义的，它的前身是 <code>MutationEvent</code> 事件，该事件最初在 <code>DOM2</code> 事件规范中介绍，到来了 <code>DOM3</code> 事件规范中正式定义，但是由于该事件存在兼容性以及性能上的问题被弃用。<a href="https://caniuse.com/#search=MutationObserver" target="_blank" rel="noopener">兼容性查阅</a></p><p><code>MutationObserver</code> 是一个构造器，接受一个 <code>callback</code> 参数，用来处理节点变化的回调函数。返回两个参数:</p><ul><li><code>mutations</code>：节点变化记录列表（<code>sequence&lt;MutationRecord&gt;</code>）</li><li><code>observer</code>：构造 <code>MutationObserver 对象</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observe = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations, observer</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p><code>MutationObserver</code> 对象有三个方法，分别如下：</p><ul><li><code>observe</code>：设置观察目标，接受两个参数: (<code>target</code>：观察目标，<code>options</code>：通过对象成员来设置观察选项)</li><li><code>disconnect</code>：阻止观察者观察任何改变</li><li><code>takeRecords</code>：清空记录队列并返回里面的内容</li></ul><p>关于 <code>observe</code> 方法中 <code>options</code> 参数有已下几个选项：</p><ul><li><code>childList</code>：设置 <code>true</code>，表示观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化</li><li><code>attributes</code>：设置 <code>true</code>，表示观察目标属性的改变</li><li><code>characterData</code>：设置 <code>true</code>，表示观察目标数据的改变</li><li><code>subtree</code>：设置为 <code>true</code>，目标以及目标的后代改变都会观察</li><li><code>attributeOldValue</code>：如果属性为 <code>true</code> 或者省略，则相当于设置为 <code>true</code>，表示需要记录改变前的目标属性值，设置了 <code>attributeOldValue</code> 可以省略 <code>attributes</code> 设置</li><li><code>characterDataOldValue</code>：如果 <code>characterData</code> 为 <code>true</code> 或省略，则相当于设置为 <code>true</code>,表示需要记录改变之前的目标数据，设置了 <code>characterDataOldValue</code> 可以省略 <code>characterData</code> 设置</li><li><code>attributeFilter</code>：如果不是所有的属性改变都需要被观察，并且 <code>attributes</code> 设置为 <code>true</code> 或者被忽略，那么设置一个需要观察的属性本地名称（不需要命名空间）的列表</li></ul><p>下表描述了 <code>MutationObserver</code> 选项与 <code>MutationEvent</code> 名称之间的对应关系：</p><table><thead><tr><th>MutationEvent</th><th>MutationObserver options</th></tr></thead><tbody><tr><td>DOMNodeInserted</td><td>{ childList: true, subtree: true }</td></tr><tr><td>DOMNodeRemoved</td><td>{ childList: true, subtree: true }</td></tr><tr><td>DOMSubtreeModified</td><td>{ childList: true, subtree: true }</td></tr><tr><td>DOMAttrModified</td><td>{ attributes: true, subtree: true }</td></tr><tr><td>DOMCharacterDataModified</td><td>{ characterData: true, subtree: true }</td></tr></tbody></table><p>从上表我们也可以看出相比与 <code>MutationEvent</code> 而言 <code>MutationObserver</code> 极大地增加了灵活性，可以设置各种各样的选项来满足程序员对目标的观察。</p><p>我们简单看几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"target"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"block"</span> name=<span class="string">"target"</span>&gt;</span><br><span class="line">  target的第一个子节点</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;span&gt;target的后代&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>1.callback 的回调次数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(<span class="string">'target'</span>);</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> observe = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations, observe</span>) </span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;);</span><br><span class="line">observe.observe(target, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.appendChild(docuemnt.createTextNode(<span class="string">'1'</span>));</span><br><span class="line">target.appendChild(docuemnt.createTextNode(<span class="string">'2'</span>));</span><br><span class="line">target.appendChild(docuemnt.createTextNode(<span class="string">'3'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p><code>MutationObserver</code> 的 <code>callback</code> 回调函数是异步的，只有在全部 <code>DOM</code> 操作完成之后才会调用 <code>callback。</code></p><p>2.当只设置<code>{ childList: true}</code>时,表示观察目标子节点的变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observe = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations, observe</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(mutations);</span><br><span class="line">  <span class="comment">//observe.discount();</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observe.observe(target, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'新增 Text 节点'</span>)); <span class="comment">//增加节点，观察到变化</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].remove(); <span class="comment">//删除节点，可以观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].textContent = <span class="string">'改变子节点的后代'</span>; <span class="comment">//不会观察到</span></span><br></pre></td></tr></table></figure><p>如果想要观察到子节点以及后代的变化需设置<code>{childList: true, subtree: true}</code></p><p><code>attributes</code> 选项用来观察目标属性的变化，用法类似与 <code>childList</code>,目标属性的删除添加以及修改都会被观察到。</p><p>3.我们需要注意的是 <code>characterData</code> 这个选项，它是用来观察 <code>CharacterData</code> 类型的节点的，只有在改变节点数据时才会观察到，如果你删除或者增加节点都不会进行观察，还有如果对不是 <code>CharacterData</code> 类型的节点的改变不会观察到，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observe.observe(target, &#123; <span class="attr">characterData</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.childNodes[<span class="number">0</span>].textContent = <span class="string">'改变 Text 节点'</span>; <span class="comment">//观察到</span></span><br><span class="line">target.childNodes[<span class="number">1</span>].textContent = <span class="string">'改变 p 元素内容'</span>; <span class="comment">//不会观察到</span></span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'新增 Text 节点'</span>)); <span class="comment">//不会观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].remove(); <span class="comment">//删除 TEXT 节点也不会观察到</span></span><br></pre></td></tr></table></figure><p>我们只需要记住只有对 <code>CharacterData</code> 类型的节点的数据改变才会被 <code>characterData</code> 为 <code>true</code> 的选项所观察到。</p><p>4.最后关注一个特别有用的选项 <code>attributeFilter</code>，这个选项主要是用来筛选要观察的属性，比如你只想观察目标 <code>style</code> 属性的变化，这时可以如下设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">observe.observe(target, &#123; <span class="attr">attributeFilter</span>: [<span class="string">'style'</span>], <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.style = <span class="string">'color:red'</span>; <span class="comment">//可以观察到</span></span><br><span class="line">target.removeAttribute(<span class="string">'name'</span>); <span class="comment">//删除 name 属性，无法观察到</span></span><br></pre></td></tr></table></figure><p><code>disconnect</code> 方法是用来阻止观察的，当你不再想观察目标节点的变化时可以调用 <code>observe.disconnect()</code> 方法来取消观察。</p><p><code>takeRecords</code> 方法是用来取出记录队列中的记录。它的一个作用是，比如你对一个节点的操作你不想马上就做出反应，过段时间在显示改变了节点的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observe = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">observe.observe(target, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'新增 Text 节点'</span>));</span><br><span class="line"><span class="keyword">var</span> record = observe.takeRecords(); <span class="comment">//此时 record 保存了改变记录列表</span></span><br><span class="line"><span class="comment">//当调用 takeRecords 方法时，记录队列被清空因此不会触发 MutationObserver 中的 callback 回调方法。</span></span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'span'</span>));</span><br><span class="line">observe.disconnect(); <span class="comment">//停止对 target 的观察。</span></span><br><span class="line"><span class="comment">//MutationObserver 中的回调函数只有一个记录，只记录了新增 span 元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//之后可以对 record 进行操作</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><code>MutationRecord</code> 变动记录中的属性如下：</p><ul><li><code>type</code>：如果是属性变化，返回”attributes”，如果是一个 CharacterData 节点（Text 节点、Comment 节点）变化，返回”characterData”，节点树变化返回”childList”</li><li><code>target</code>：返回影响改变的节点</li><li><code>addedNodes</code>：返回添加的节点列表</li><li><code>removedNodes</code>：返回删除的节点列表</li><li><code>previousSibling</code>：返回分别添加或删除的节点的上一个兄弟节点，否则返回 null</li><li><code>nextSibling</code>：返回分别添加或删除的节点的下一个兄弟节点，否则返回 null</li><li><code>attributeName</code>：返回已更改属性的本地名称，否则返回 null</li><li><code>attributeNamespace</code>：返回已更改属性的名称空间，否则返回 null</li><li><code>oldValue</code>：返回值取决于 type。对于”attributes”，它是更改之前的属性的值。对于”characterData”，它是改变之前节点的数据。对于”childList”，它是 null</li></ul><p>其中 <code>type</code>、<code>target</code> 这两个属性不管是哪种观察方式都会有返回值，其他属性返回值与观察方式有关，比如只有当 <code>attributeOldValue</code> 或者 <code>characterDataOldValue</code> 为 <code>true</code> 时 <code>oldValue</code> <code>才有返回值，只有改变属性时，attributeName</code> 才有返回值等。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unable to preventDefault inside passive event listener due to target being treated as passive</title>
      <link href="/369.html"/>
      <url>/369.html</url>
      
        <content type="html"><![CDATA[<h2 id="事件现象"><a href="#事件现象" class="headerlink" title="事件现象"></a>事件现象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>chrome</code> 控制台报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Intervention] Unable to preventDefault inside passive event listener due to target being treated as passive. See https://www.chromestatus.com/features/5093566007214080</span><br></pre></td></tr></table></figure><p>在 <code>document</code> 上监听 <code>touch</code> 类事件时，如果在 <code>handler</code> 里调用了 <code>e.preventDefault()</code>，则会报错：<code>不能给passive(被动的)事件监听器 preventDefault，因为它被认为是 passive</code></p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p><code>addEventListener()</code> 的第三个参数（可选）为以下二选一:</p><ul><li><code>useCapture</code> （<code>boolean</code>，默认值<code>false</code>）为 <code>true</code> 表示 <code>listener</code> 会在该类型的事件<code>捕获</code>阶段传播到该 <code>EventTarget</code> 时触发</li><li><code>options</code> （<code>object</code>）<ul><li><code>capture</code> （<code>boolean</code>，默认值 <code>false</code>,同 <code>useCapture</code>）</li><li><code>once</code> (<code>boolean</code>，默认值 <code>false</code>) 为 <code>true</code> 表示 <code>listener</code> 在添加之后最多只调用一次</li><li><code>passive</code> (<code>boolean</code>，默认值 <code>false</code> ) 为 <code>true</code> 表示 <code>listener</code> 调用 <code>preventDefault()</code> 无效并报错</li></ul></li></ul><h2 id="事件原因"><a href="#事件原因" class="headerlink" title="事件原因"></a>事件原因</h2><p>从 <code>Chrome 56</code> 开始，如果我们给 <code>document</code> 绑定 <code>touchmove</code> 或者 <code>touchstart</code> 事件的监听器，这个 <code>passive</code> 是会被默认设置为<code>true</code> 以提高性能<a href="https://www.chromestatus.com/feature/5093566007214080" target="_blank" rel="noopener">查阅</a></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>避免在 <code>handler</code> 里调用 <code>e.preventDefault()</code>,提高性能</li><li><code>addEventListener</code> 里第三个参数设置为 <code>{passive:false}</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">'touchstart'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    passive: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）javascript中的装箱和拆箱</title>
      <link href="/368.html"/>
      <url>/368.html</url>
      
        <content type="html"><![CDATA[<h2 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h2><p>把 <code>基本数据类型</code> 转换为对应的 <code>引用类型</code> 的操作称为 <code>装箱</code>，把 <code>引用类型</code> 转换为 <code>基本数据类型</code> 称为 <code>拆箱</code>。</p><blockquote><p>每当读取一个基本类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。 –《javascript 高级程序设计》</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'some text'</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>如上所视，变量 <code>s1</code> 是一个基本类型值，它不是对象，所以它不应该有方法。但是 <code>js</code> 内部为我们完成了一系列处理（即我们称之为<code>装箱</code>），使得它能够调用方法,实现的机制如下：</p><ul><li>创建 <code>String</code> 类型的一个实例</li><li>在实例上调用指定的方法</li><li>销毁这个实例</li></ul><p>这个过程也可以用代码来展现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'some text'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>我在很多地方都看到过说装箱操作会泄露内存，可是这里明明是销毁了实例的，哎，我还是相信《javascript 高级程序设计》吧，认为它不会泄露~</p><h2 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h2><p>将 <code>引用类型</code> 对象转换为对应的 <code>基本数据类型</code>，它是通过 <code>引用类型</code> 的 <code>valueOf()</code> 或者 <code>toString()</code> 方法来实现的。如果是自定义的对象，你也可以自定义它的 <code>valueOf()/tostring()</code> 方法，实现对这个对象的 <code>拆箱</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objNum = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">var</span> objStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objNum); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objStr); <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objNum.valueOf()); <span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objStr.valueOf()); <span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objNum.toString()); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objStr.toString()); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ast简介</title>
      <link href="/367.html"/>
      <url>/367.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>抽象语法树（Abstract Syntax Tree，AST）</code>是源代码语法结构的一种抽象表示。它以<strong>树状的形式表现编程语言的语法结构</strong>，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>优化变更代码，改变代码结构达到想要的结构（<code>webpack</code> 等），代码语法、风格的检查（<code>eslint</code>），代码的格式化，代码的高亮，代码错误提示，代码自动补全（<code>IDE</code>）等等。</p><h2 id="如何转换"><a href="#如何转换" class="headerlink" title="如何转换"></a>如何转换</h2><p>可通过一些优秀的 <code>javascript Parser</code> 解析器，来实现源码转换为语法树，更改语法树，生成新的语法树。</p><h3 id="源码-gt-语法树"><a href="#源码-gt-语法树" class="headerlink" title="源码-&gt;语法树"></a>源码-&gt;语法树</h3><p>一般浏览器会把 <code>js</code> 源码通过解析器转化为抽象语法树，再进一步转化为字节码或直接生成机器码。</p><p>每一个 <code>js</code> 引擎都会有自己的抽象语法树格式，<code>chrome</code> 的 <code>v8</code> 引擎，<code>firefox</code> 的 <code>SpiderMonkey</code> 引擎等等，业界标准为：<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API#Node_objects" target="_blank" rel="noopener">AST 对象文档</a>，中文类似<a href="http://developer.51cto.com/art/201611/521405.htm" target="_blank" rel="noopener">讲解</a></p><p>在线解析点<a href="https://astexplorer.net/" target="_blank" rel="noopener">这里</a></p><p>常用的 <code>parser</code> 有：<a href="https://esprima.org/" target="_blank" rel="noopener">esprima</a>，<code>traceur</code>，<code>acorn</code>( <code>webpack</code> 使用)，<code>shift</code></p><h3 id="遍历更新语法树"><a href="#遍历更新语法树" class="headerlink" title="遍历更新语法树"></a>遍历更新语法树</h3><p>常用的 <code>parser</code> 为：<a href="https://github.com/estools/estraverse" target="_blank" rel="noopener">estraverse</a></p><h3 id="语法树-gt-新的源码"><a href="#语法树-gt-新的源码" class="headerlink" title="语法树-&gt;新的源码"></a>语法树-&gt;新的源码</h3><p>常用的 <code>parser</code> 为：<a href="https://github.com/estools/escodegen" target="_blank" rel="noopener">escodegen</a></p><p>使用 <code>esprima</code>, <code>estraverse</code>, <code>escodegen</code> 三板斧可完成源码编译解析，另有包 <a href="https://github.com/benjamn/recast" target="_blank" rel="noopener">recast</a> 可完成这一系列操作。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="箭头函数转换成普通函数"><a href="#箭头函数转换成普通函数" class="headerlink" title="箭头函数转换成普通函数"></a>箭头函数转换成普通函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> esprima = <span class="built_in">require</span>(<span class="string">'esprima'</span>);</span><br><span class="line"><span class="keyword">const</span> estraverse = <span class="built_in">require</span>(<span class="string">'estraverse'</span>);</span><br><span class="line"><span class="keyword">const</span> escodegen = <span class="built_in">require</span>(<span class="string">'escodegen'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> code = <span class="string">`var a = b=&gt;&#123;console.log(123);&#125;`</span>;</span><br><span class="line"><span class="keyword">let</span> tree = esprima.parseScript(code);</span><br><span class="line">estraverse.traverse(tree, &#123;</span><br><span class="line">  leave(node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="string">'ArrowFunctionExpression'</span>) &#123;</span><br><span class="line">      node.type = <span class="string">'FunctionDeclaration'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> r = escodegen.generate(tree);</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// var a = function(b)&#123;console.log(123);&#125;</span></span><br></pre></td></tr></table></figure><h3 id="babel-插件"><a href="#babel-插件" class="headerlink" title="babel 插件"></a>babel 插件</h3><p>待补充 <a href="https://segmentfault.com/a/1190000018753707" target="_blank" rel="noopener">参考</a></p><h3 id="vue-template-模板解析-AST"><a href="#vue-template-模板解析-AST" class="headerlink" title="vue template 模板解析 AST"></a>vue template 模板解析 AST</h3><p>待补充 <a href="https://segmentfault.com/a/1190000015432258" target="_blank" rel="noopener">参考</a> <a href="https://blog.csdn.net/violetjack0808/article/details/79354852" target="_blank" rel="noopener">参考 2</a></p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用proxy实现一个简单完整的MVVM库</title>
      <link href="/366.html"/>
      <url>/366.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>MVVM</code> 是当前时代前端日常业务开发中的必备模式（相关框架如<code>react</code>，<code>vue</code>，<code>angular</code> 等）， 使用 <code>MVVM</code> 可以将开发者的精力更专注于业务上的逻辑，而不需要关心如何操作 <code>dom</code>。虽然现在都 9012 年了，<code>mvvm</code> 相关原理的介绍已经烂大街了，但出于学习基础知识的目的（使用 <code>proxy</code> 实现的 <code>vue</code>3.0 还在开发中）， 在参考了之前 <code>vue.js</code> 的整体思路之后，自己动手实现了一个简易的通过 <code>proxy</code> 实现的 <code>mvvm</code>。</p><blockquote><p>本项目代码已经开源在<a href="https://github.com/zhaoky/mvvm" target="_blank" rel="noopener">github</a>，项目正在持续完善中，欢迎交流学习，喜欢请点个 star 吧！</p></blockquote><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MVVM <span class="keyword">from</span> <span class="string">'@fe_korey/mvvm'</span>;</span><br><span class="line"><span class="keyword">new</span> MVVM(&#123;</span><br><span class="line">  view: <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>),</span><br><span class="line">  model: &#123;</span><br><span class="line">    title: <span class="string">'hello mvvm!'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'主程编译完成,欢迎使用MVVM！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h2><ul><li><code>Complier</code> 模块实现解析、收集指令，并初始化视图</li><li><code>Observer</code> 模块实现了数据的监听，包括添加订阅者和通知订阅者</li><li><code>Parser</code> 模块实现解析指令，提供该指令的更新视图的更新方法</li><li><code>Watcher</code> 模块实现建立指令与数据的关联</li><li><code>Dep</code> 模块实现一个订阅中心，负责收集，触发数据模型各值的订阅列表</li></ul><p>流程为：<code>Complier</code>收集编译好指令后，根据指令不同选择不同的<code>Parser</code>，根据<code>Parser</code>在<code>Watcher</code>中订阅数据的变化并更新初始视图。<code>Observer</code>监听数据变化然后通知给 <code>Watcher</code> ，<code>Watcher</code> 再将变化结果通知给对应<code>Parser</code>里的 <code>update</code> 刷新函数进行视图的刷新。</p><p><img src="http://cdn.flqin.com/mvvm.jpeg" alt="mvvm.js整体流程图"></p><h2 id="模块详解"><a href="#模块详解" class="headerlink" title="模块详解"></a>模块详解</h2><h3 id="Complier"><a href="#Complier" class="headerlink" title="Complier"></a>Complier</h3><ul><li><p>将整个数据模型 <code>data</code> 传入<code>Observer</code>模块进行数据监听</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$data = <span class="keyword">new</span> Observer(option.model).getData();</span><br></pre></td></tr></table></figure></li><li><p>循环遍历整个 <code>dom</code>，对每个 <code>dom</code> 元素的所有指令进行扫描提取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectDir</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> children = element.childNodes;</span><br><span class="line">  <span class="keyword">const</span> childrenLen = children.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLen; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = children[i];</span><br><span class="line">    <span class="keyword">const</span> nodeType = node.nodeType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodeType !== <span class="number">1</span> &amp;&amp; nodeType !== <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasDirective(node)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$queue.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.hasChildNodes() &amp;&amp; !hasLateCompileChilds(node)) &#123;</span><br><span class="line">      collectDir(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对每个指令进行编译，选择对应的解析器<code>Parser</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parser = <span class="keyword">this</span>.selectParsers(&#123; node, dirName, dirValue, <span class="attr">cs</span>: <span class="keyword">this</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>将得到的解析器<code>Parser</code>传入<code>Watcher</code>，并初始化该 <code>dom</code> 节点的视图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(parser);</span><br><span class="line">parser.update(&#123; <span class="attr">newVal</span>: watcher.value &#125;);</span><br></pre></td></tr></table></figure></li><li><p>所有指令解析完毕后，触发 <code>MVVM</code> 编译完成回调<code>$mounted()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$mounted();</span><br></pre></td></tr></table></figure></li><li><p>使用文档碎片<code>document.createDocumentFragment()</code>来代替真实 <code>dom</code> 节点片段，待所有指令编译完成后，再将文档碎片追加回真实 <code>dom</code> 节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> child;</span><br><span class="line"><span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">while</span> ((child = <span class="keyword">this</span>.$element.firstChild)) &#123;</span><br><span class="line">  fragment.appendChild(child);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析完后</span></span><br><span class="line"><span class="keyword">this</span>.$element.appendChild(fragment);</span><br><span class="line"><span class="keyword">delete</span> $fragment;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><ul><li><p>在<code>Complier</code>模块编译后的指令，选择不同听解析器解析，目前包括<code>ClassParser</code>,<code>DisplayParser</code>,<code>ForParser</code>,<code>IfParser</code>,<code>StyleParser</code>,<code>TextParser</code>,<code>ModelParser</code>,<code>OnParser</code>,<code>OtherParser</code>等解析模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (name) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'text'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> TextParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'style'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> StyleParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'class'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> ClassParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'for'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> ForParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'on'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> OnParser(&#123; node, dirName, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'display'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> DisplayParser(&#123; node, dirName, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'if'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> IfParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'model'</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> ModelParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> OtherParser(&#123; node, dirName, dirValue, cs &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不同的解析器提供不同的视图刷新函数<code>update()</code>，通过<code>update</code>更新<code>dom</code>视图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//text.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.el.textContent = _toString(newVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>OnParser</code> 解析事件绑定，与数据模型中的 <code>methods</code>字段对应</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//详见 https://github.com/zhaoky/mvvm/blob/master/src/core/parser/on.ts</span></span><br><span class="line">el.addEventListener(handlerType, e =&gt; &#123;</span><br><span class="line">  handlerFn(scope, e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>ForParser</code> 解析数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//详见 https://github.com/zhaoky/mvvm/blob/master/src/core/parser/for.ts</span></span><br></pre></td></tr></table></figure></li><li><p><code>ModelParser</code> 解析双向绑定，目前支持<code>input[text/password] &amp; textarea</code>,<code>input[radio]</code>,<code>input[checkbox]</code>,<code>select</code>四种情况的双向绑定，双绑原理：</p><ul><li><p>数据变化更新表单：跟其他指令更新视图一样，通过<code>update</code>方法触发更新表单的<code>value</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">&#123; newVal &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.model.el.value = _toString(newVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表单变化更新数据：监听表单变化事件如<code>input</code>,<code>change</code>，在回调里<code>set</code>数据模型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.model.el.addEventListener(<span class="string">'input'</span>, e =&gt; &#123;</span><br><span class="line">  model.watcher.set(e.target.value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><ul><li><code>MVVM</code> 模型中的核心，一般通过 <code>Object.defineProperty</code> 的 <code>get</code>，<code>set</code> 方法进行数据的监听，在 <code>get</code> 里添加订阅者，<code>set</code> 里通知订阅者更新视图。在本项目采用 <code>Proxy</code> 来实现数据监听，好处有三：<ul><li><code>Proxy</code> 可以直接监听对象而非属性</li><li><code>Proxy</code> 可以直接监听数组的变化</li><li><code>Proxy</code> 有多达 13 种拦截方法，<a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">查阅</a><br>而劣势是兼容性问题,且无法通过 <code>polyfill</code> 磨平。查阅<a href="https://caniuse.com/#search=Proxy" target="_blank" rel="noopener">兼容性</a></li></ul></li><li>注意 <code>Proxy</code> 只会监听自身的每一个属性，如果属性是对象，则该对象不会被监听，所以需要递归监听</li><li>设置监听后，返回一个 <code>Proxy</code> 替代原数据对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, key, receiver) &#123;</span><br><span class="line">    <span class="comment">//如果满足条件则添加订阅者</span></span><br><span class="line">    dep.addDep(curWatcher);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(target, key, value, receiver) &#123;</span><br><span class="line">    <span class="comment">//如果满足条件则通知订阅者</span></span><br><span class="line">    dep.notfiy();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><ul><li><p>在 <code>Complier</code> 模块里对每一个解析后的 <code>Parser</code> 进行指令与数据模型直接的绑定，并触发 <code>Observer</code> 的 <code>get</code> 监听，添加订阅者（<code>Watcher</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._getter(<span class="keyword">this</span>.parser.dirValue)(<span class="keyword">this</span>.scope || <span class="keyword">this</span>.parser.cs.$data);</span><br></pre></td></tr></table></figure></li><li><p>当数据模型变化时，就会触发 -&gt; <code>Observer</code> 的 <code>set</code> 监听 -&gt; <code>Dep</code> 的 <code>notfiy</code> 方法(通知订阅者的所有订阅列表) -&gt; 执行订阅列表所有 <code>Watcher</code> 的 <code>update</code> 方法 -&gt; 执行对应 <code>Parser</code> 的 <code>update</code> -&gt; 完成更新视图</p></li><li><p><code>Watcher</code> 里的 <code>set</code> 方法用于设置双向绑定值，注意访问层级</p></li></ul><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><ul><li><code>MVVM</code> 的订阅中心，在这里收集数据模型的每个属性的订阅列表</li><li>包含添加订阅者，通知订阅者等方法</li><li>本质是一种发布/订阅模式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.dependList = [];</span><br><span class="line">  &#125;</span><br><span class="line">  addDep() &#123;</span><br><span class="line">    <span class="keyword">this</span>.dependList.push(dep);</span><br><span class="line">  &#125;</span><br><span class="line">  notfiy() &#123;</span><br><span class="line">    <span class="keyword">this</span>.dependList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.update();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>目前该 <code>mvvm</code> 项目只实现了<code>数据绑定</code>和<code>视图更新</code>的功能，通过这个简易轮子的实现，对 <code>dom</code> 操作，<code>proxy</code>，<code>发布订阅模式</code>等若干基础知识都进行了再次理解，查漏补缺。同时欢迎大家一起探讨交流，后面会继续完善！</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式的先行断言(lookahead)和后行断言(lookbehind)</title>
      <link href="/365.html"/>
      <url>/365.html</url>
      
        <content type="html"><![CDATA[<p>均是<strong>匹配位置</strong>，在匹配过程中，不占用字符，所以被称为<strong>零宽</strong>。</p><ul><li><p><code>(?=pattern)</code> 零宽<code>正向先行</code>断言(zero-width positive lookahead assertion)</p><ul><li><p>紧接该位置<strong>之后</strong>的字符序列<strong>能够</strong>匹配 <code>pattern</code></p></li><li><p>如替换后面紧跟<code>c</code>的<code>ab</code>为<code>xx</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abcabdabe'</span>.replace(<span class="regexp">/ab(?=c)/g</span>, <span class="string">'xx'</span>); <span class="comment">// xxcabdabe</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>(?!pattern)</code> 零宽<code>负向先行</code>断言(zero-width negative lookahead assertion)</p><ul><li><p>紧接该位置<strong>之后</strong>的字符序列<strong>不能</strong>匹配 <code>pattern</code></p></li><li><p>如替换后面不为<code>c</code>的<code>ab</code>为<code>xx</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abcabdabe'</span>.replace(<span class="regexp">/ab(?!c)/g</span>, <span class="string">'xx'</span>); <span class="comment">// abcxxdxxe</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>(?&lt;=pattern)</code> 零宽<code>正向后行</code>断言(zero-width positive lookbehind assertion)</p><ul><li><p>紧接该位置<strong>之前</strong>的字符序列<strong>能够</strong>匹配 <code>pattern</code></p></li><li><p>如替换前面为<code>a</code>的<code>bc</code>为<code>xx</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abcdbcebc'</span>.replace(<span class="regexp">/(?&lt;=a)bc/g</span>, <span class="string">'xx'</span>); <span class="comment">// axxdbcebc</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>(?&lt;!pattern)</code> 零宽<code>负向后行</code>断言(zero-width negative lookbehind assertion)</p><ul><li><p>紧接该位置<strong>之前</strong>的字符序列<strong>不能</strong>匹配 <code>pattern</code></p></li><li><p>如替换后面不为<code>a</code>的<code>bc</code>为<code>xx</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abcdbcebc'</span>.replace(<span class="regexp">/(?&lt;!a)bc/g</span>, <span class="string">'xx'</span>); <span class="comment">// abcdxxexx</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>另：非捕获分组<code>(?:p)</code></p><p><code>括号</code>是提供分组功能，如果只想要<code>括号</code>最原始的功能，但不会引用它，即既不在 API 里引用，也不在正则里反向引用。此时可以使用<code>非捕获分组(?:p)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abcde'</span>.replace(<span class="regexp">/(ab)c(de)/g</span>, <span class="string">'$1'</span>); <span class="comment">// ab</span></span><br><span class="line"><span class="string">'abcde'</span>.replace(<span class="regexp">/(?:ab)c(de)/g</span>, <span class="string">'$1'</span>); <span class="comment">// de</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）为什么JavaScript里面typeof(null)的值是&quot;object&quot;</title>
      <link href="/364.html"/>
      <url>/364.html</url>
      
        <content type="html"><![CDATA[<ol><li>null 不是一个空引用, 而是一个原始值, 参考 <a href="http://lzw.me/pages/ecmascript/#20" target="_blank" rel="noopener">ECMAScript5.1 中文版</a> 4.3.11 节; 它只是期望此处将引用一个对象, 注意是”期望”, 参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="noopener">null - JavaScript</a>.</li><li>typeof null 结果是 object, 这是个历史遗留 bug, 参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">typeof - JavaScript</a></li><li>在 ECMA6 中, 曾经有提案为历史平反, 将 type null 的值纠正为 null, 但最后提案被拒了. 理由是历史遗留代码太多, 不想得罪人, 不如继续将错就错当和事老, 参考 <a href="http://wiki.ecmascript.org/doku.php?id=harmony%3atypeof_null" target="_blank" rel="noopener">harmony:typeof_null -ES Wiki</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NFE（具名函数表达式）的问题</title>
      <link href="/363.html"/>
      <url>/363.html</url>
      
        <content type="html"><![CDATA[<p>群里小伙伴讨论了这么一个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;;</span><br><span class="line">a(); <span class="comment">//打印b为function()&#123;b=1;console.log(b);&#125;</span></span><br></pre></td></tr></table></figure><p>为什么这里打印的 <code>b</code> 为 <code>b</code> 函数，而不是 <code>1</code>？</p><p>答案是 <code>函数表达式</code> 如果有 <code>name</code> 的话，这个 <code>name</code> 是 <code>不可删除且为只读</code>。</p><p>资料查阅：</p><ul><li><a href="https://goddyzhao.tumblr.com/post/11273713920/functions" target="_blank" rel="noopener">函数（Functions）</a></li><li><a href="https://goddyzhao.tumblr.com/post/11259644092/scope-chain" target="_blank" rel="noopener">作用域链（Scope Chain）</a></li><li><a href="https://goddyzhao.tumblr.com/post/11141710441/variable-object" target="_blank" rel="noopener">变量对象（Variable object）</a></li><li><a href="https://goddyzhao.tumblr.com/post/10020230352/execution-context" target="_blank" rel="noopener">执行上下文（Execution Context）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义事件</title>
      <link href="/362.html"/>
      <url>/362.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建，触发，删除自定义事件"><a href="#创建，触发，删除自定义事件" class="headerlink" title="创建，触发，删除自定义事件"></a>创建，触发，删除自定义事件</h2><ul><li>创建自定义事件 文档<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events" target="_blank" rel="noopener">查阅</a></li><li>Event() 文档<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/Event" target="_blank" rel="noopener">查阅</a></li><li>Event 属性 文档<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank" rel="noopener">查阅</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'build'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for the event.</span></span><br><span class="line">elem.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; ... &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatch the event.</span></span><br><span class="line">elem.dispatchEvent(event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete the event.</span></span><br><span class="line">elem.removeEventListener(<span class="string">'build'</span>);</span><br></pre></td></tr></table></figure><h2 id="添加自定义数据"><a href="#添加自定义数据" class="headerlink" title="添加自定义数据"></a>添加自定义数据</h2><p>要向事件对象添加更多数据，可以使用 <code>CustomEvent</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'build'</span>, &#123; <span class="attr">detail</span>: elem.dataset.time &#125;);</span><br></pre></td></tr></table></figure><p>事件监听器中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  log(<span class="string">'The time is: '</span> + e.detail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="触发内置事件"><a href="#触发内置事件" class="headerlink" title="触发内置事件"></a>触发内置事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'input'</span>, &#123;</span><br><span class="line">  bubbles: <span class="literal">true</span>, <span class="comment">//能否冒泡</span></span><br><span class="line">  cancelable: <span class="literal">true</span> <span class="comment">//事件是否可以取消默认行为</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">element.dispatchEvent(event);</span><br></pre></td></tr></table></figure><h2 id="createEvent-amp-initEvent-（已废弃-IE-中可用）"><a href="#createEvent-amp-initEvent-（已废弃-IE-中可用）" class="headerlink" title="createEvent &amp; initEvent （已废弃,IE 中可用）"></a>createEvent &amp; initEvent （已废弃,IE 中可用）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'Event'</span>);</span><br><span class="line">event.initEvent(<span class="string">'build'</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用typescript下的项目架构最佳实践</title>
      <link href="/361.html"/>
      <url>/361.html</url>
      
        <content type="html"><![CDATA[<p>此贴记录下在 <code>typescript</code> 项目里的一些相关配置和包的选用，其中各种依赖包和最佳实践都在不断发展演变中，最新的配置以该仓库 <a href="https://github.com/zhaoky/mvvm" target="_blank" rel="noopener">MVVM</a> 为准。</p><h2 id="typescript-支持"><a href="#typescript-支持" class="headerlink" title="typescript 支持"></a>typescript 支持</h2><p>在<code>webpack</code>中使用 <code>babel 7.0 +</code>,摒弃了传统的 <code>ts-loader</code> 或 <code>awesome-typescript-loader</code> 方案。原因如下：</p><ul><li><a href="https://github.com/frontend9/fe9-library/issues/23" target="_blank" rel="noopener">参考 1</a></li><li><a href="https://juejin.im/post/5c822e426fb9a04a0a5ffb49" target="_blank" rel="noopener">参考 2</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add @babel/core babel-loader @babel/preset-env @babel/preset-typescript -D</span><br><span class="line">yarn add @babel/plugin-proposal-class-propertie -D //根据项目需求添加其他env未包含的转义插件</span><br></pre></td></tr></table></figure><p><code>babel</code> 只负责转换，并不会做对应的类型检查，所以需要安装 <a href="https://github.com/TypeStrong/fork-ts-checker-webpack-plugin" target="_blank" rel="noopener">fork-ts-checker-webpack-plugin</a> 来进行报错提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add fork-ts-checker-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>项目通用转 <code>ES5</code> 安装包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @babel/plugin-transform-runtime @babel/runtime-corejs3 -D</span><br></pre></td></tr></table></figure><p><code>babel.config.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/env'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: <span class="string">'&gt; 1%, not dead'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'@babel/preset-typescript'</span></span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/plugin-transform-runtime'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        corejs: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'@babel/plugin-proposal-class-properties'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>tsconfig.json</code> 配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"ESNext"</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">    <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"sourceMap"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"src/**/*"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webpack</code> 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(js|ts)$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: [<span class="string">'babel-loader'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码检查-amp-风格统一"><a href="#代码检查-amp-风格统一" class="headerlink" title="代码检查 &amp; 风格统一"></a>代码检查 &amp; 风格统一</h2><p><strong>代码检查</strong>使用 <code>eslint</code>（<a href="https://github.com/typescript-eslint/typescript-eslint" target="_blank" rel="noopener">官方未来推荐</a>），抛弃传统的 <code>tslint</code> 方案：<a href="https://ts.xcatliu.com/engineering/lint" target="_blank" rel="noopener">参考链接</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn add eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin -D</span><br><span class="line"></span><br><span class="line">//@typescript-eslint/parser :将 TypeScript 转换为 ESTree，使 eslint 可以识别</span><br><span class="line">//@typescript-eslint/eslint-plugin :只是一个可以打开或关闭的规则列表</span><br></pre></td></tr></table></figure><p><code>@typescript-eslint/parser</code> 作为 <code>babel</code> 的解析器，这时候就不需要安装 <code>babel</code> 默认推荐的 <code>eslint</code> 解析器(<code>babel-eslint</code>)了，规则列表<a href="https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/eslint-plugin" target="_blank" rel="noopener">查阅</a>。</p><p><strong>风格统一</strong>使用 <code>prettier</code>，在 <code>typescript</code> 项目里将配置文件 <code>prettier.config.js</code> 里添加 <code>parser: &quot;typescript&quot;</code> 即可(前提是已安装 <code>@typescript-eslint/parser</code>：<a href="https://prettier.io/docs/en/options.html#parser" target="_blank" rel="noopener">参考链接</a>)。</p><p>项目通用 <code>prettier</code> 的其他包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add prettier eslint-config-prettier eslint-plugin-prettier -D</span><br></pre></td></tr></table></figure><p>结合 <code>eslint+prettier</code>，得到：</p><p><code>prettier.config.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  singleQuote: <span class="literal">false</span>,</span><br><span class="line">  printWidth: <span class="number">200</span>,</span><br><span class="line">  parser: <span class="string">'typescript'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>.eslintrc.js</code> (这里使用的 <code>google</code> 默认规则 <code>eslint-config-google</code>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  root: <span class="literal">true</span>,</span><br><span class="line">  parser: <span class="string">'@typescript-eslint/parser'</span>,</span><br><span class="line">  plugins: [<span class="string">'@typescript-eslint'</span>],</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    es6: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  extends: [<span class="string">'plugin:@typescript-eslint/recommended'</span>, <span class="string">'google'</span>, <span class="string">'prettier'</span>, <span class="string">'prettier/@typescript-eslint'</span>],</span><br><span class="line">  globals: &#123;</span><br><span class="line">    Atomics: <span class="string">'readonly'</span>,</span><br><span class="line">    SharedArrayBuffer: <span class="string">'readonly'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: <span class="number">2018</span>,</span><br><span class="line">    sourceType: <span class="string">'module'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'@typescript-eslint/no-explicit-any'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'@typescript-eslint/no-use-before-define'</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="jest"><a href="#jest" class="headerlink" title="jest"></a>jest</h3><p>这里选用 <code>jest</code> 框架来测试。<a href="http://www.fly63.com/article/detial/170" target="_blank" rel="noopener">jest 的优势？</a>。</p><p>在 <code>ts</code> 项目里，摒弃了传统的 <code>ts-jest</code>，只需如上安装 <code>@babel/preset-typescript</code>，并在 <code>babel.config.js</code> 里的 <code>presets</code> 添加即可。<a href="https://jestjs.io/docs/en/getting-started.html#using-typescript" target="_blank" rel="noopener">参考链接</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn jest @types/jest -D  //@types/jest 是 jest 的 ts 类型定义文件，而 vscode 便是基于 ts 进行代码提示的</span><br></pre></td></tr></table></figure><ul><li>经查 <code>jest</code> 依赖包里发现，<code>jest</code> 依赖 <code>babel-jest</code> (用于支持 <code>es6</code> 语法)，故不需要在单独引入依赖包 <code>babel-jest</code>。</li><li>因为引入了 <code>@types/jest</code>，也就不需要引入 <code>eslint-plugin-jest</code> 来消除 <code>jest</code> 变量的报错。</li><li><code>jest config</code> 采用默认配置即可，更多个性化配置<a href="https://jestjs.io/docs/en/configuration" target="_blank" rel="noopener">参见</a>。</li></ul><h3 id="coveralls"><a href="#coveralls" class="headerlink" title="coveralls"></a>coveralls</h3><p>这里选用了 <a href="https://coveralls.io/" target="_blank" rel="noopener">coveralls</a> 作为自动测试代码覆盖率的在线工具。由于项目走 <code>travis.com</code> 的持续集成，所以配置为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add coveralls -D</span><br></pre></td></tr></table></figure><p><code>.coveralls.yml</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">service_name:</span> <span class="string">travis-pro</span></span><br><span class="line"><span class="attr">repo_token:</span> <span class="string">COVERALLS_TOKEN</span> <span class="comment"># COVERALLS_TOKEN为加密变量</span></span><br></pre></td></tr></table></figure><p><code>package.json</code> 添加 <code>scripts</code> (测试框架为 <code>jest</code>，<a href="https://github.com/nickmerwin/node-coveralls" target="_blank" rel="noopener">更多方法查阅</a>):</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "coveralls": "jest --coverage &amp;&amp; cat ./coverage/lcov.info | coveralls"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>.travis.yml</code> 添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">sed</span> <span class="bullet">-i</span> <span class="string">"s/COVERALLS_TOKEN/$COVERALLS_TOKEN/"</span> <span class="string">.coveralls.yml</span> <span class="comment">#$COVERALLS_TOKEN为在travis.com项目里配置的加密变量</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">yarn</span> <span class="string">run</span> <span class="string">coveralls</span></span><br></pre></td></tr></table></figure><h3 id="在-vscode-里调试-jest-webpack-等-node-js"><a href="#在-vscode-里调试-jest-webpack-等-node-js" class="headerlink" title="在 vscode 里调试 jest/webpack 等 node.js"></a>在 vscode 里调试 jest/webpack 等 node.js</h3><p><code>调试</code> -&gt; <code>添加配置</code> -&gt; 选择<code>node.js</code>，自动生成<code>.vscode/launch.json</code>，修改配置为：</p><p><a href="https://code.visualstudio.com/docs/nodejs/nodejs-debugging" target="_blank" rel="noopener">文档</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">"configurations": [</span><br><span class="line">    &#123;</span><br><span class="line">      "type": "node", //系统默认，不可更改，标识要使用的调试器的类型</span><br><span class="line">      "request": "launch", //系统默认，不可更改，在指定的文件上启动调试器 program. attach: 将调试器附加到已经运行的进程。</span><br><span class="line">      "name": "Launch Program", //调试配置的名称</span><br><span class="line">      "program": "$&#123;workspaceFolder&#125;/index.js", //要调试的Node.js程序的绝对路径</span><br><span class="line">      "args": ["--runInBand", "--env=jsdom", "$&#123;fileBasename&#125;"], //传递给程序进行调试的参数[array]</span><br><span class="line">      "runtimeExecutable": "npm", // 要使用的运行时可执行文件的绝对路径。默认是node (https://code.visualstudio.com/docs/nodejs/nodejs-debugging#_launch-configuration-support-for-npm-and-other-tools)</span><br><span class="line">      "runtimeArgs": ["run-script", "debug"], // 传递给运行时可执行文件的可选参数</span><br><span class="line">      "runtimeVersion":"7.10.1", //使用nvm可以用此属性控制node.js版本</span><br><span class="line">      "port": 5858, //要使用的调试端口</span><br><span class="line">      "console": "externalTerminal", //指定如何显示程序输出: externalTerminal:独立控制台窗口,integratedTerminal(默认):VS代码集成终端</span><br><span class="line">      "stopOnEntry": true, // 设置为true时，在调试程序的第一行中断开调试器。如果省略（默认）或设置为false，则调试器将程序运行到第一个断点。</span><br><span class="line">      "skipFiles": ["&lt;node_internals&gt;/**/*.js","$&#123;workspaceFolder&#125;/lib/**/*.js"] // 跳过不感兴趣的代码, Node.js的内置核心模块定义为：&lt;node_internals&gt;，其他变量定义(https://code.visualstudio.com/docs/editor/variables-reference)</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>调试单一 <code>node</code> 文件：<ul><li><code>launch.json</code> 配置：<ul><li><code>program:${workspaceFolder}/index.js</code></li><li><code>args:[&#39;--dev&#39;]</code></li></ul></li></ul></li><li>调试 <code>npm scripts</code> (包括普通 <code>node</code> 命令如 <code>index.js</code> 和非 <code>node</code> 命令如 <code>jest,webpack</code> 等)时：<ul><li><code>launch.json</code> 配置：<ul><li><code>runtimeExecutable:&quot;npm&quot;</code> //必须设置为<code>npm</code></li><li><code>runtimeArgs:[&quot;run&quot;, &quot;debug&quot;]</code> //第一个参数必须为<code>run</code></li><li><code>runtimeVersion:&quot;10.6.0&quot;</code> //可选</li></ul></li><li><code>package.json</code> 的 <code>npm scripts</code> 配置：<ul><li>必须加 <code>--inspect-brk=5858</code>，<code>5858</code> 与 <code>port</code> 设置须相同</li><li>非普通命令需要转换成 <code>node</code> 调用: <code>webpack=&gt;./node_modules/.bin/webpack</code> (因为 <code>npm run build</code> 实际调用的是 <code>node_modules/.bin/webpack</code>)</li><li>带参数的命令接在后面即可：<code>node --inspect-brk=5858 ./node_modules/.bin/jest --coverage</code></li></ul></li></ul></li></ul><p><code>npm scripts</code>:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "debug": "node --inspect-brk=5858 index.js",</span><br><span class="line">  "build": "node --inspect-brk=5858 ./node_modules/.bin/webpack --mode=development",</span><br><span class="line">  "test": "node --inspect-brk=5858 ./node_modules/.bin/jest --coverage"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="前端测试概念"><a href="#前端测试概念" class="headerlink" title="前端测试概念"></a>前端测试概念</h3><h4 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h4><ul><li>单元测试 (<code>Unit Test</code>) - 通过模拟输入和预测输出的方式测试独立的函数或者类。</li><li>集成测试 (<code>Integration Test</code>) - 测试多个模块间的联动是否和期望相同。</li><li><code>E2E</code> 测试 (也被称为 <code>Functional Test</code>) - 关注点不在内部实现方式，而是测试产品在真实使用场景（比如在浏览器）中是否可以达到预想的结果，属于黑盒测试。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/32702421" target="_blank" rel="noopener">更多</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Typescript-错误忽略"><a href="#Typescript-错误忽略" class="headerlink" title="Typescript 错误忽略"></a>Typescript 错误忽略</h3><ul><li>单行忽略 <code>// @ts-ignore</code></li><li>忽略全文 <code>// @ts-nocheck</code></li><li>取消忽略全文 <code>// @ts-check</code></li></ul><h3 id="github-徽章"><a href="#github-徽章" class="headerlink" title="github 徽章"></a>github 徽章</h3><p>在 <a href="https://shields.io/" target="_blank" rel="noopener">shields</a> 上面可生成任意徽章。</p><h3 id="d-ts-文件是什么"><a href="#d-ts-文件是什么" class="headerlink" title=".d.ts 文件是什么"></a>.d.ts 文件是什么</h3><p><code>d.ts</code> 就是 <code>TypedDefinition 类型定义文件</code>，用来定义类型信息以及接口规范。</p><p><code>ts</code>代码最终会编译成 <code>.js</code> 的 <code>js</code> 代码，供他人使用。这个时候类型信息就丢失了。所以 <code>ts</code> 编译器会自动根据 <code>.ts</code> 中的信息，可以自动生成对外的 <code>.d.ts</code> 文件，和生成的 <code>js</code> 文件搭配使用。其中，<code>js</code> 文件是给运行引擎用的，而 <code>.d.ts</code> 文件是给 <code>IDE（智能编辑器）</code> 写代码时参考用的。</p><h3 id="如何测试本地-node-包"><a href="#如何测试本地-node-包" class="headerlink" title="如何测试本地 node 包"></a>如何测试本地 node 包</h3><p>采用 <code>npm link</code></p><ul><li>在需要测试的包（如 <code>test</code> ）路径下执行：<code>npm link</code>，这时 <code>全局node_modules</code> 包下就可以看到这个 <code>test</code> 包。</li><li>在需引用的目标包的项目下安装该测试包：<code>npm link test</code>（如果有作用域需要加上作用域：<code>npm link @fe_korey/test</code>）,这时 test 包就被安装在了该目录下，在 <code>test</code> 包里的修改会同步到目标包里。</li><li>取消连接：在 <code>test</code> 包里执行：<code>npm unlink</code> 即可.</li></ul><p>注意：在 <code>webpack</code> 项目中，如果用 <code>npm link</code> 方式测试本地包，需要设置 <code>config</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  symlinks: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）点击穿透</title>
      <link href="/360.html"/>
      <url>/360.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>点击穿透这种现象算是移动 <code>web</code> 开发比较经典的问题，也常用来做面试题。本文目标是结合移动 <code>web</code> 开发的相关事件，介绍一下点击穿透现象形成的原因以及避免这种现象的解决方法。</p><h2 id="点击穿透现象"><a href="#点击穿透现象" class="headerlink" title="点击穿透现象"></a>点击穿透现象</h2><p>现象描述：</p><p>页面中存在上下两个层，上层元素具有表单，链接或者绑定相应事件，上层元素点击或触摸，导致上层 <code>DOM</code> 改变，下层中同样位置的元素触发点击事件。这种现象就是<code>点击穿透（Ghost Clicks）</code>。其实我觉得用“幽冥点击”称呼它更加带感。</p><p>要理解这种现象，首先要了解移动端的相关事件 —— <code>触摸(Touch)事件</code>，<code>点击(Click)事件</code>。</p><p><code>Touch</code> 事件中，常用的为 <code>touchstart</code>, <code>touchmove</code>, <code>touchend</code> 三种。除此之外还有 <code>touchcancel</code>。注意，原生事件中并没有 <code>tap</code> 事件。下面会解释 <code>tap</code> 事件怎么产生的。</p><p>事件描述如下：</p><table><thead><tr><th>事件</th><th>描述</th><th>触发时机</th></tr></thead><tbody><tr><td>touchstart</td><td>开始触摸</td><td>手指接触屏幕时立即触发</td></tr><tr><td>touchmove</td><td>移动或拖拽</td><td>取决于系统和浏览器</td></tr><tr><td>touchend</td><td>触摸结束</td><td>手指离开屏幕时立即出发</td></tr></tbody></table><p>而 <code>Touch</code> 事件的触发一般通过手指，还会存在多点触控，拖拽方向等情况。列出几个重要参数如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>touches</td><td>屏幕中每根手指信息列表</td></tr><tr><td>targetTouches</td><td>和 touches 类似，把同一节点的手指信息过滤掉</td></tr><tr><td>changedTouches</td><td>响应当前事件的每根手指的信息列表</td></tr></tbody></table><p>代码获取如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxDOM.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.touches, e.targetTouches, e.changedTouches);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>手指触发触摸事件的过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touchstart -&gt; touchmove -&gt; ... touchmove -&gt; touchend</span><br></pre></td></tr></table></figure><p>由此，我们可以在 <code>ontouchstart</code> 事件上记录开始触摸开始，<code>ontouchend</code> 记录触摸结束信息。</p><p>通过上述这些参数，很容易的去计算幽冥点击的时间，以及点击穿透的相关信息，包括响应的坐标情况。</p><h2 id="造成的原因"><a href="#造成的原因" class="headerlink" title="造成的原因"></a>造成的原因</h2><p>问题来了，<code>click 事件</code> 什么时候触发？</p><p>浏览器在 <code>touchend</code> 之后会等待约 <code>300ms</code> ，如果没有 <a href="https://www.cnblogs.com/zhuzhenwei918/p/7588553.html" target="_blank" rel="noopener">tap 行为</a>，则触发 <code>click</code> 事件。</p><p>而浏览器等待约 <code>300ms</code> 的原因是，判断用户是否是<code>双击（double tap）行为</code>，双击过程中就不适合触发 click 事件了。</p><p>由此可以看出 <code>click</code> 事件触发代表一轮触摸事件的结束。</p><p>上面说到原生事件中并没有 <code>tap</code> 事件，可以参考经典的 <code>zepto.js</code> 对 <code>singleTap</code> 事件的处理。<a href="https://github.com/madrobby/zepto/blob/master/src/touch.js#L136-L143" target="_blank" rel="noopener">见源码 136-143 行</a></p><p>可以看出，<code>singleTap</code> 事件的触发时机 —— 在 <code>touchend</code> 事件响应 <code>250ms</code> 无操作后，触发 <code>singleTap</code>。</p><p>因此，点击穿透的现象就容易理解了，在这 <code>300ms</code> 以内，因为上层元素隐藏或消失了，由于 <code>click</code> 事件的滞后性，同样位置的 <code>DOM</code> 元素触发了 <code>click</code> 事件（如果是 <code>input</code> 则触发了 <code>focus</code> 事件）。在代码中，给我们的感觉就是 <code>target</code> 发生了飘移。</p><h2 id="怎样避免点击穿透"><a href="#怎样避免点击穿透" class="headerlink" title="怎样避免点击穿透"></a>怎样避免点击穿透</h2><p>理解点击穿透的原因，我们从各种途径去阻止现象的产生。</p><p>毫无疑问，能想到的方法很多，比如中间的层添加一个 <code>300ms</code> 渐隐的动画，触摸结束后阻止 <code>click</code> 事件等。</p><ol><li><p>触摸开始时<br><code>touchstart</code> 事件触发时，<code>preventDefault()</code>。毫无疑问，很容易想到这一点，而且也从根本上解决了这个问题。但是，它有一个避免不了或者说引入了很大的缺陷，页面中 <code>DOM</code> 元素无法再进行滚动了。这个方法显然不能满足我们的需求，但是这个思路其实可以给我们更多的启发，比如说 <code>iscroll</code> 只允许横向滚动的实现，相关实现这里暂且不表。</p></li><li><p>触摸结束时<br><code>touchend</code> 事件触发时，<code>preventDefault()</code>。看上去好像没有什么问题，但是，很遗憾的是不是所有的浏览器都支持。</p></li><li><p>禁止页面缩放<br>通过设置 <code>meta</code> 标签，可以禁止页面缩放，部分浏览器不再需要等待 <code>300ms</code>，导致点击穿透。点击事件仍然会触发，但相对较快，所以 <code>click</code> 事件从某种意义上来说可以取代点击事件，<br>而代价是牺牲少数用户（<code>click</code> 事件触发仍然较慢）的体验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>IE 10</code> 可以用 <code>CSS</code> 取消点击穿透的延迟：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">-ms-touch-action</span>: manipulation;</span><br><span class="line">  <span class="attribute">touch-action</span>: manipulation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IE 11+</code> 可以用 <code>touch-action: manipulation;</code> 属性来阻止元素的双击缩放。</p></li><li><p>CSS3 的方法<br>虽然主要讲的是事件，但是有必要介绍一个 CSS3 的属性 —— <code>pointer-events</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer-events: auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit;</span><br></pre></td></tr></table></figure><p><code>pointer-events</code> 属性有很多值，有用的主要是 <code>auto</code> 和 <code>none</code>，其他属性为 <code>SVG</code> 服务。</p><p><a href="https://caniuse.com/#search=pointer-events" target="_blank" rel="noopener">查看浏览器支持情况</a> 可见移动端开发还是可以用的。</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>auto</td><td>默认值，鼠标或触屏事件不会穿透当前层</td></tr><tr><td>none</td><td>元素不再是 target，监听的元素变成了下层的元素（如果子元素设置成 auto，点击子元素会继续监听事件）</td></tr></tbody></table></li><li><p>处理点击事件 —— <code>Touch to Click</code><br>最靠谱的方案还是从点击事件的根源上解决问题。用 <code>js</code> 去判断幽冥点击，然后阻止点击穿透。这种方式显然可以实现，缺点是阻止点击穿透时需要小心，不要导致原生的 <code>HTML</code> 元素（如：链接，多选框，单选框）无法正常运行。</p><p>通过上文中介绍的 <code>touches，targetTouches，changedTouches</code> 参数，我们可以构建出这样的测试页面，可以统计出点击穿透的时间，以及已经响应的情况。</p><table><thead><tr><th></th><th>preventDefault()</th><th>preventDefault()</th><th>点击穿透时间</th><th>点击穿透时间</th><th>点击穿透区域</th><th>点击穿透区域</th></tr></thead><tbody><tr><td>Browser</td><td>touchstart</td><td>touchend</td><td>缩放页面</td><td>禁止缩放页面</td><td>缩放页面</td><td>禁止缩放页面</td></tr><tr><td>Safari Mobile iOS 5.1.1</td><td>Yes</td><td>Yes</td><td>370ms after end</td><td>370ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Safari Mobile iOS 6.1.3</td><td>Yes</td><td>Yes</td><td>370ms after end</td><td>370ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Safari Mobile iOS 7.1.1</td><td>Yes</td><td>Yes</td><td>370ms after end</td><td>370ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 2.3.7</td><td>Yes</td><td>No</td><td>410ms after end</td><td>410ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 4.0.4</td><td>Yes</td><td>No</td><td>300ms after end</td><td>10ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 4.1.2</td><td>Yes</td><td>No</td><td>300ms after end</td><td>300ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 4.2.2</td><td>Yes</td><td>No</td><td>300ms after start</td><td>10ms after end</td><td>touchstart</td><td>touchend</td></tr><tr><td>IE10 Windows Phone 8</td><td>No</td><td>No</td><td>310ms after end</td><td>10ms after end</td><td>touchend</td><td>touchend</td></tr><tr><td>Blackberry 10</td><td>Yes</td><td>Yes</td><td>260ms after end</td><td>10ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Chrome for iOS</td><td>Yes</td><td>Yes</td><td>360ms after end</td><td>360ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Chrome for Android</td><td>Yes</td><td>Yes</td><td>300ms after start</td><td>10ms after end</td><td>touchstart</td><td>touchend</td></tr><tr><td>Firefox for Android</td><td>Yes</td><td>No</td><td>300ms after end</td><td>10ms after end</td><td>touchstart</td><td>touchend</td></tr></tbody></table><p>由此可以看出：</p><ul><li>点击穿透受浏览器和页面是否缩放影响</li><li>点击穿透有两种情况：快速情况有 <code>10ms</code> 慢速情况有 <code>300ms</code></li><li>在 <code>touchend</code> 时间上调用 <code>preventDefault()</code> 可以阻止多数情况的点击穿透</li></ul><p>代码上处理建议如下：</p><ul><li>在 <code>touchend</code> 事件上调用 <code>preventDefault()</code></li><li>在一次成功的点击后，建议接下来的 <code>500ms</code> 以内取消所有的 <code>click</code> 事件。</li><li>分析点击事件，判断如果是慢速点击穿透，则取消所有 <code>click</code> 事件，如果是快速点击穿透，取消触摸事件 <code>50ms</code> 以内的 <code>click</code> 事件即可。</li></ul><p>有个好消息是，移动端开发已经有人写好相应的库，帮助我们处理点击穿透。</p><p><a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">fastclick</a> 可以参考和使用。</p><p>其实现思路是，取消 <code>click</code> 事件<a href="https://github.com/ftlabs/fastclick/blob/master/lib/fastclick.js#L521-L610" target="_blank" rel="noopener">（参看源码 164-173 行）</a>，用 <code>touchend</code> 模拟快速点击行为<a href="https://github.com/ftlabs/fastclick/blob/master/lib/fastclick.js#L164-L173" target="_blank" rel="noopener">（参看源码 521-610 行）</a>。</p></li></ol><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="http://liudong.me/conclusion/touch-defect/" target="_blank" rel="noopener">点击穿透</a></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise实现</title>
      <link href="/358.html"/>
      <url>/358.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">规范</a> | <a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">中文解析</a></p><p>相关术语及概念见上述链接，以下为 <code>promise</code> 实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunc = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Function]'</span>;</span><br><span class="line"><span class="keyword">const</span> isObj = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Object]'</span>;</span><br><span class="line"><span class="comment">// 等待态 规范 2.1.1</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="comment">// 执行态 规范 2.1.2</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="comment">// 拒绝态 规范 2.1.3</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">this</span>.filfulledQueues = [];</span><br><span class="line">    <span class="keyword">this</span>.rejectedQueues = [];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fn(<span class="keyword">this</span>._resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>._reject.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>._reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//传入 promise 的第一个参数 resolve</span></span><br><span class="line">  _resolve(val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      val.then(<span class="keyword">this</span>._resolve, <span class="keyword">this</span>._reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObj(val) || isFunc(val)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFunc(val.then)) &#123;</span><br><span class="line">          val.then(<span class="keyword">this</span>._resolve, <span class="keyword">this</span>._reject);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">this</span>._reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._execCallback(FULFILLED, <span class="keyword">this</span>.filfulledQueues, val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//传入 promise 的第二个参数 reject</span></span><br><span class="line">  _reject(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>._execCallback(REJECTED, <span class="keyword">this</span>.rejectedQueues, val);</span><br><span class="line">  &#125;</span><br><span class="line">  _execCallback(status, list, val) &#123;</span><br><span class="line">    <span class="comment">//规范 2.2.4 onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用，且被作为函数调用（即没有 this 值）</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status !== PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.status = status;</span><br><span class="line">      <span class="keyword">this</span>.value = val;</span><br><span class="line">      <span class="keyword">let</span> cb;</span><br><span class="line">      <span class="comment">//规范 2.2.6</span></span><br><span class="line">      <span class="keyword">while</span> ((cb = list.shift())) &#123;</span><br><span class="line">        cb(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//规范 2.3 Promise 解决过程 [[Resolve]](promise, x)</span></span><br><span class="line">  _resolvePromise(newPromise, x, resolve, reject) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newPromise === x) &#123;</span><br><span class="line">      <span class="comment">//规范 2.3.1</span></span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="comment">//规范 2.3.2</span></span><br><span class="line">      x.then(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObj(x) || isFunc(x)) &#123;</span><br><span class="line">      <span class="comment">//规范 2.3.3</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//规范 2.3.3.3</span></span><br><span class="line">        <span class="keyword">if</span> (isFunc(x.then)) &#123;</span><br><span class="line">          x.then(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//规范 2.3.3.4</span></span><br><span class="line">          resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">//规范 2.3.3.3.4</span></span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//规范 2.3.4</span></span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//规范 2.2</span></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">let</span> newPromise;</span><br><span class="line">    <span class="comment">//规范 2.2.1，2.2.7.3</span></span><br><span class="line">    onFulfilled = isFunc(onFulfilled) ? onFulfilled : <span class="function"><span class="params">val</span> =&gt;</span> val;</span><br><span class="line">    <span class="comment">//规范 2.2.1，2.2.7.4</span></span><br><span class="line">    onRejected = isFunc(onRejected)</span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">//规范 2.2.7 then 方法必须返回一个 promise 对象：promise2 = promise1.then(onFulfilled, onRejected);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">newPromise = <span class="keyword">new</span> MyPromise((onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// onFulfilledNext, onRejectedNext 即该 then 的下一个 then 里传的 resolve 和 reject</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED || <span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">        <span class="comment">//规范 2.2.4 onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 规范 2.2.7.1 不论 promise1 被 reject 还是被 resolve 时 promise2 都会被 resolve（走_resolvePromise方法），只有出现异常时才会被 rejected。</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//规范 2.2.2，2.2.3，2.2.5</span></span><br><span class="line">            <span class="keyword">const</span> x = <span class="keyword">this</span>.status === FULFILLED ? onFulfilled(<span class="keyword">this</span>.value) : onRejected(<span class="keyword">this</span>.value);</span><br><span class="line">            <span class="keyword">this</span>._resolvePromise(newPromise, x, onFulfilledNext, onRejectedNext);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">//规范 2.2.7.2  这里如果x为捕获的err（即 onRejected 不是函数 2.2.7.4）也会进入</span></span><br><span class="line">            onRejectedNext(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">//规范 2.2.6.1</span></span><br><span class="line">        <span class="keyword">this</span>.filfulledQueues.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//规范 2.2.2，2.2.5</span></span><br><span class="line">            <span class="keyword">const</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">            <span class="keyword">this</span>._resolvePromise(newPromise, x, onFulfilledNext, onRejectedNext);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">//规范 2.2.7.2</span></span><br><span class="line">            onRejectedNext(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//规范 2.2.6.2</span></span><br><span class="line">        <span class="keyword">this</span>.rejectedQueues.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//规范 2.2.3，2.2.5</span></span><br><span class="line">            <span class="keyword">const</span> x = onRejected(<span class="keyword">this</span>.value);</span><br><span class="line">            <span class="keyword">this</span>._resolvePromise(newPromise, x, onFulfilledNext, onRejectedNext);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">//规范 2.2.7.2</span></span><br><span class="line">            onRejectedNext(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//catch 方法</span></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//finally 方法</span></span><br><span class="line">  <span class="keyword">finally</span>(cb) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      val =&gt; &#123;</span><br><span class="line">        MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> val);</span><br><span class="line">      &#125;,</span><br><span class="line">      err =&gt; &#123;</span><br><span class="line">        MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//resolve 方法</span></span><br><span class="line">  <span class="keyword">static</span> resolve(params) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(params);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//reject 方法</span></span><br><span class="line">  <span class="keyword">static</span> reject(err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//all 方法</span></span><br><span class="line">  <span class="keyword">static</span> all(params) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> valueList = [];</span><br><span class="line">    <span class="keyword">const</span> promises = <span class="built_in">Array</span>.from(params);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promises.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!item <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          item = MyPromise.resolve(item);</span><br><span class="line">        &#125;</span><br><span class="line">        item.then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          valueList[index] = r;</span><br><span class="line">          <span class="keyword">if</span> (promises.length === ++count) &#123;</span><br><span class="line">            resolve(valueList);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//race 方法</span></span><br><span class="line">  <span class="keyword">static</span> race(params) &#123;</span><br><span class="line">    <span class="keyword">const</span> promises = <span class="built_in">Array</span>.from(params);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promises.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!item <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          item = MyPromise.resolve(item);</span><br><span class="line">        &#125;</span><br><span class="line">        item.then(resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：实践中要确保 <code>onFulfilled</code> 和 <code>onRejected</code> 方法异步执行，且应该在 <code>then</code> 方法被调用的那一轮事件循环之后的新执行栈中执行。 本实现代码采用 <code>setTimeout</code>（宏任务）来实现异步任务，而 <code>chrome</code> 里的 <code>promise</code> 实现则是采用微任务（<code>%EnqueueMicrotask</code>）的方式，故略有不同。</p><p><code>chrome</code> 的 <code>promise</code> 实现参考源码版本小于 <code>5.6.100</code> 的 <a href="https://chromium.googlesource.com/v8/v8/+/refs/tags/5.6.10/src/js/promise.js" target="_blank" rel="noopener">src/js/promise.js</a> 文件，其中 <code>PromiseEnqueue</code> 方法里的 <code>C</code> 函数 <code>%EnqueueMicrotask</code> 将 <code>PromiseHandle</code> 加入到 <code>JS运行时</code> 的微任务队列中。</p><p>其中因为 <code>chrome</code> 版本的不断迭代， 在版本 <a href="https://chromium.googlesource.com/v8/v8/+log/refs/tags/5.6.100" target="_blank" rel="noopener">5.6.100</a> 里的 <code>hash</code> 为 <a href="https://chromium.googlesource.com/v8/v8/+/6f94a8f1c7f0a94c74c5055b02b660d8e93fe5fe%5E%21/#F8" target="_blank" rel="noopener">6f94a8</a> 的提交里重写了整个 <code>PromiseEnqueue</code>，然后在后续版本 <a href="https://chromium.googlesource.com/v8/v8/+log/refs/tags/6.1.395" target="_blank" rel="noopener">6.1.395</a> 里的 <code>hash</code> 为 <a href="https://chromium.googlesource.com/v8/v8/+/bba473db7471a4dc3ea74035c270f68dbc0562de" target="_blank" rel="noopener">bba473</a> 的提交里完全删除了 <code>promise.js</code>），最终由 <code>JS</code> 实现完全迭代为 <code>C</code> 开发实现。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式和发布订阅模式的区别</title>
      <link href="/357.html"/>
      <url>/357.html</url>
      
        <content type="html"><![CDATA[<h2 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h2><p>观察者模式指的是一个对象（<code>Subject</code>）维持一系列依赖于它的对象（<code>Observer</code>），当有关状态发生变更时 <code>Subject</code> 对象则通知一系列 <code>Observer</code> 对象进行更新。</p><p>在观察者模式中，<code>Subject</code> 对象拥有添加、删除和通知一系列 <code>Observer</code> 的方法等等，而 <code>Observer</code> 对象拥有更新方法等等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.list = [];</span><br><span class="line">  &#125;</span><br><span class="line">  add(ob) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(ob);</span><br><span class="line">  &#125;</span><br><span class="line">  remove(ob) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.splice(<span class="keyword">this</span>.list.indexOf(<span class="keyword">this</span>.list.find(<span class="function"><span class="params">item</span> =&gt;</span> ob.id === item.id)), <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  notfiy() &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">      i.update(i.id);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  update(id) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;id&#125;</span>,我被通知了！`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> people1 = <span class="keyword">new</span> Observer(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">let</span> people2 = <span class="keyword">new</span> Observer(<span class="number">9527</span>);</span><br><span class="line"><span class="keyword">let</span> people3 = <span class="keyword">new</span> Observer(<span class="number">89757</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sub = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line">sub.add(people1);</span><br><span class="line">sub.add(people2);</span><br><span class="line">sub.add(people3);</span><br><span class="line"></span><br><span class="line">sub.notfiy();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  sub.remove(people2);</span><br><span class="line">  sub.notfiy();</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><h2 id="发布订阅模式（Publisher-amp-amp-Subscriber）"><a href="#发布订阅模式（Publisher-amp-amp-Subscriber）" class="headerlink" title="发布订阅模式（Publisher &amp;&amp; Subscriber）"></a>发布订阅模式（Publisher &amp;&amp; Subscriber）</h2><p>发布订阅模式指的是希望接收通知的对象（<code>Subscriber</code>）基于一个 <code>主题</code> 通过自定义事件订阅主题，被激活事件的对象（<code>Publisher</code>）通过发布主题事件的方式通知各个订阅该主题的 <code>Subscriber</code> 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发布订阅模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pub</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.list = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  subscribe(name, cb) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.list[name]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.list[name] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.list[name].push(cb);</span><br><span class="line">  &#125;</span><br><span class="line">  unSubscribe(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list[name] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  publish(...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="built_in">Array</span>.from(args).shift();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.list[name] || <span class="keyword">this</span>.list[name].length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>主题没有可发布的事件！`</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.list[name].forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item(args);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> publisher = <span class="keyword">new</span> Pub();</span><br><span class="line"></span><br><span class="line">publisher.subscribe(<span class="string">'event1'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br><span class="line">publisher.subscribe(<span class="string">'event1'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br><span class="line">publisher.subscribe(<span class="string">'event2'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br><span class="line">publisher.subscribe(<span class="string">'event3'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">publisher.publish(<span class="string">'event1'</span>, <span class="string">'额外参数1'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  publisher.unSubscribe(<span class="string">'event2'</span>);</span><br><span class="line">  publisher.publish(<span class="string">'event2'</span>, <span class="string">'额外参数2'</span>);</span><br><span class="line">  publisher.publish(<span class="string">'event3'</span>, <span class="string">'额外参数3'</span>, <span class="string">'额外参数4'</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>发布订阅模式是观察者模式的一种变体。发布订阅只是把一部分功能抽象成一个独立的 <code>ChangeManager</code>。</p><p>在「一对多」的场景下，发布者的某次更新只想通知它的部分订阅者？</p><p>在「多对一」或者「多对多」场景下。一个订阅者依赖于多个发布者，某个发布者更新后是否需要通知订阅者？还是等所有发布者都更新完毕再通知订阅者？</p><p>这些逻辑都可以放到 <code>ChangeManager</code> 里。</p><p>观察者模式中依赖于 <code>Subject</code> 对象的一系列 <code>Observer</code> 对象在被通知之后只能执行同一个特定的更新方法，而在发布订阅模式中则可以基于不同的主题去执行不同的自定义事件。相对而言，发布订阅模式比观察者模式要更加灵活多变。</p><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="http://cdn.flqin.com/p357-1.png" alt="关系图"></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环(Event Loop)</title>
      <link href="/359.html"/>
      <url>/359.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li>进程是系统分配的独立资源，是 <code>CPU</code> 资源分配的基本单位，进程是由一个或者多个线程组成的。</li><li>线程是进程的执行流，是 <code>CPU</code> 调度和分派的基本单位，同个进程之中的多个线程之间是共享该进程的资源的。</li></ul><h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><ul><li>browser 进程<ul><li>主进程，负责协调、控制其他进程</li><li>负责浏览器界面显示，用户交互（前进、后退等），网络资源下载</li><li>负责将 <code>渲染进程</code> 得到的在内存中的 <code>bitmap</code> 绘制到用户界面上</li></ul></li><li>第三方插件进程<ul><li>每个插件对应一个进程，仅当使用该插件时才创建</li></ul></li><li><code>GPU</code> 进程<ul><li>最多一个，用于 <code>3D</code> 绘制等</li></ul></li><li>浏览器内核渲染/<code>renderer</code> 进程<ul><li>浏览器每一个 <code>tab</code> 标签都代表一个独立的进程（也不一定，因为多个空白 <code>tab</code> 标签会合并成一个进程）</li><li>内部为多线程</li></ul></li></ul><p>多进程的好处可以避免单个 <code>page</code>、单个插件 <code>crash</code> 影响整个浏览器，也充分利用多核优势，提高浏览器稳定性。</p><h3 id="浏览器内核-renderer-进程-有多种线程在工作"><a href="#浏览器内核-renderer-进程-有多种线程在工作" class="headerlink" title="浏览器内核(renderer 进程)有多种线程在工作"></a>浏览器内核(renderer 进程)有多种线程在工作</h3><ul><li><code>GUI</code> 渲染线程<ul><li>负责渲染页面，解析 <code>HTML</code>，<code>CSS</code> 构成 <code>DOM</code> 树等，当页面重绘或者由于某种操作引起回流都会调起该线程。</li><li>和 <code>JS</code> 引擎线程是互斥的，当 <code>JS</code> 引擎线程在工作的时候，<code>GUI</code> 渲染线程会被挂起，<code>GUI</code> 更新被放入在 <code>JS</code> 任务队列中，等待 <code>JS</code> 引擎线程空闲的时候继续执行。</li></ul></li><li><code>JS</code> 引擎线程(解释器)<ul><li><strong>单线程工作</strong>，负责解析运行 <code>JavaScript</code> 脚本。</li><li>和 <code>GUI</code> 渲染线程互斥，<code>JS</code> 运行耗时过长就会导致页面阻塞。</li><li>一个浏览器 <code>Tab</code>（<code>renderer</code> 进程）只有一个 <code>js</code> 线程运行。</li></ul></li><li>事件触发线程<ul><li>该线程归属浏览器，不属于 <code>JS</code> 引擎，用来控制<strong>事件循环</strong>。</li><li>事件循环是一个程序结构，用于等待和发送消息和事件。</li><li>当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 <code>JS</code> 引擎处理。</li></ul></li><li>定时器触发线程<ul><li>浏览器定时计数器并不是由 <code>JS</code> 引擎计数的，阻塞会导致计时不准确。</li><li>开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 <code>JS</code> 引擎处理。</li></ul></li><li><code>http</code> 请求线程<ul><li>每次 <code>http</code> 请求的时候都会<strong>新开启一条请求线程</strong>。</li><li>请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 <code>JS</code> 引擎处理。</li></ul></li></ul><h3 id="browser-进程与-renderer-进程的通信过程"><a href="#browser-进程与-renderer-进程的通信过程" class="headerlink" title="browser 进程与 renderer 进程的通信过程"></a>browser 进程与 renderer 进程的通信过程</h3><ul><li><code>Browser</code> 进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过 <code>RendererHost</code> 接口传递给 <code>Render</code> 进程</li><li><code>Renderer</code> 进程的 <code>Renderer</code> 接口收到消息，简单解释后，交给渲染线程，然后开始渲染</li><li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要 <code>Browser</code> 进程获取资源和需要 <code>GPU</code> 进程来帮助渲染，当然可能会有 <code>JS</code> 线程操作 <code>DOM</code>（这样可能会造成回流并重绘）</li><li>最后 <code>Render</code> 进程将结果传递给 <code>Browser</code> 进程</li><li><code>Browser</code> 进程接收到结果并将结果绘制出来</li></ul><h3 id="web-workers"><a href="#web-workers" class="headerlink" title="web workers"></a>web workers</h3><ul><li>原理：<code>JS</code> 引擎向浏览器新申请开一个<strong>子线程</strong>，与子线程通过 <code>postMessage API</code> 通信。子线程完全受主线程控制</li><li>作用：后台运行计算，将结果发到主线程，解决单线程的 <code>JS</code> 引擎进行密集型计算会堵塞页面的问题</li><li>子线程不能影响用户界面，即不能操作 <code>dom</code> 等，在一个新的全局上下文</li><li>除了 <code>webworker</code>（属于 <code>renderer</code> 进程） 还有 <code>SharedWorker</code>（多个标签页、<code>iframe</code> 共享，不属于某个 <code>renderer</code> 进程，自己就是一个进程），<code>Service Workers</code>，<code>ChromeWorker</code> 等</li><li>更多<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API" target="_blank" rel="noopener">查阅 1</a>,<a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">查阅 2</a></li></ul><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>事件循环是通过 <code>任务队列</code> 的机制来进行协调的。一个 <code>Event Loop</code> 中，可以有一个或者多个任务队列<code>(task queue)</code>，一个任务队列便是一系列有序任务(<code>task</code>)的集合；每个任务都有一个任务源(<code>task source</code>)，源自同一个任务源的 <code>task</code> 必须放到同一个任务队列，从不同源来的则被添加到不同队列。</p><p><code>JavaScript</code> 单线程中的任务分为 <code>同步任务</code> 和 <code>异步任务</code>。同步任务会在 <code>调用栈</code> 中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到 <code>任务队列(消息队列)</code> 中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。<code>任务队列</code> 是 <code>先进先出</code> 的数据结构。</p><p>异步任务队列可分为 <code>task(macrotask)</code> 宏任务 和 <code>microtask(job)</code> 微任务 两类，不同的 <code>API</code> 注册的异步任务会依次进入自身对应的队列中，然后等待 <code>Event Loop</code> 将它们依次压入执行栈中执行，宏任务队列可以有多个，微任务队列只有一个。</p><ul><li><code>microtask</code> 主要包含：<code>Promise.then</code>、<code>MutaionObserver</code>、<code>process.nextTick(Node.js 环境)</code>、<code>Object.observe(已废弃)</code><a href="https://github.com/luokuning/blogs/issues/1" target="_blank" rel="noopener">查阅</a></li><li><code>(macro)task</code> 主要包含：<code>script(整体代码)</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>I/O</code>、<code>UI交互事件</code>、<code>postMessage</code>、<code>MessageChannel</code>、<code>setImmediate(Node.js 环境)</code></li></ul><h3 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环(Event Loop)"></a>事件循环(Event Loop)</h3><p><code>javascript</code> 从诞生之日起就是一门单线程的非阻塞的脚本语言。而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如 <code>I/O</code> 事件）的时候，主线程会挂起（<code>pending</code>）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。到底是如何实现非阻塞这一点呢？答案就是 <code>event loop（事件循环）</code>。</p><p><code>call stack 调用栈(执行栈)</code> 是一种 <code>后进先出</code> 的数据结构。所有的同步任务都会被放到 <code>调用栈</code> 等待 <code>主线程</code> 执行。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。每次栈内被清空，都会去读取 <code>任务队列</code> 有没有任务，有就按照顺序读取执行，这个时候栈中又出现了事件，这个事件又去调用了 <code>WebAPIs</code> 里的异步方法，那这些异步方法会在再被调用的时候放在队列里，一直循环读取-执行的操作，就形成了 <code>事件循环</code>。</p><h2 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h2><h3 id="总体图"><a href="#总体图" class="headerlink" title="总体图"></a>总体图</h3><p><img src="http://cdn.flqin.com/p359-1.png" alt="总体图"></p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>在事件循环中，每进行一次循环操作称为 <code>tick</code>，每一次 <code>tick</code> 的任务处理模型是比较复杂的，但关键步骤如下：</p><ul><li>在此次 <code>tick</code> 中选择最先进入队列的任务(<code>oldest task</code>)，如果有则执行(一个)，如果执行中有异步任务就放至各自的队列中</li><li>检查是否存在 <code>Microtasks</code>，如果存在则<strong>不停地执行</strong>，直至清空 <code>Microtasks Queue</code></li><li>更新 <code>render(update rendering)</code></li><li>取出下一个宏任务 <code>task</code>，主线程重复执行上述步骤</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li><code>await</code> 将直接使用 <code>Promise.resolve()</code> 相同语义<a href="https://www.zhihu.com/question/268007969/answer/339811998" target="_blank" rel="noopener">查阅</a>，即：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(async2()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Promise.resolve</code> 方法允许调用时不带参数，直接返回一个 <code>resolved</code> 状态的 <code>Promise</code> 对象。立即 <code>resolved</code> 的 <code>Promise</code> 对象，是在本轮“事件循环”（<code>event loop</code>）的结束时，而不是在下一轮 “事件循环” 的开始时。</li><li><code>Promises/A+规范</code>：实践中要确保 <code>onFulfilled</code> 和 <code>onRejected</code> 方法异步执行，且应该在 <code>then</code> 方法被调用的那一轮事件循环之后的新执行栈中执行。</li><li><code>update rendering（视图渲染）</code>发生在本轮事件循环的 <code>microtask</code> 队列被执行完之后，也就是说执行任务的耗时会影响视图渲染的时机。通常浏览器以每秒 60 帧（<code>60fps</code>）的速率刷新页面，这个帧率最适合人眼交互，大概 <code>16.7ms</code> 渲染一帧，所以如果要让用户觉得顺畅，单个 <code>macrotask</code> 及它相关的所有 <code>microtask</code> 最好能在 <code>16.7ms</code> 内完成。</li><li>也不是每轮事件循环都会执行 <code>视图更新</code>，浏览器有自己的优化策略,可能把几次的视图更新累积到一起重绘.重绘之前会通知 <code>requestAnimationFrame()</code> 执行回调函数.</li><li><code>requestAnimationFrame</code> 回调的执行时机是在一次或多次事件循环的 <code>UI render</code> 阶段。<a href="https://www.cnblogs.com/sunshq/p/5807575.html" target="_blank" rel="noopener">查阅 1</a>,<a href="https://blog.csdn.net/vhwfr2u02q/article/details/79492303" target="_blank" rel="noopener">查阅 2</a></li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h4><p>解析<a href="https://juejin.im/post/5afbc62151882542af04112d" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h4><p>解析<a href="https://github.com/dwqs/blog/issues/61" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">t</span> =&gt;</span> <span class="built_in">console</span>.log(t));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="例-3"><a href="#例-3" class="headerlink" title="例 3"></a>例 3</h4><p>解析<a href="https://segmentfault.com/q/1010000017801324" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">      resolve(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">t</span> =&gt;</span> <span class="built_in">console</span>.log(t));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">t</span> =&gt;</span> <span class="built_in">console</span>.log(t));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h4 id="例-4"><a href="#例-4" class="headerlink" title="例 4"></a>例 4</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise3'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><h4 id="例-5"><a href="#例-5" class="headerlink" title="例 5"></a>例 5</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intervalA = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'intervalA'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line"></span><br><span class="line">  clearInterval(intervalA);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intervalB = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'intervalB'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intervalC = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'intervalC'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    i === <span class="number">9999</span> &amp;&amp; resolve();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise after for-loop'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line"></span><br><span class="line">    clearInterval(intervalB);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise in timeout'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise after timeout'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise4'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise5'</span>);</span><br><span class="line"></span><br><span class="line">    clearInterval(intervalC);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise3'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><h4 id="例-6"><a href="#例-6" class="headerlink" title="例 6"></a>例 6</h4><p>解析<a href="https://zhuanlan.zhihu.com/p/46068171" target="_blank" rel="noopener">查阅</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'start'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'timeout1'</span>);</span></span><br><span class="line">  &#125;, 0);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'timeout2'</span>);</span></span><br><span class="line">  &#125;, 0);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  requestAnimationFrame(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'requestAnimationFrame'</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 输出：start promise1 end promise2 requestAnimationFrame timeout1 timeout2  --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p><img src="http://cdn.flqin.com/p359-2.png" alt="示意图"></p><h2 id="NODE-中的事件循环-适用于-NODE-11-以下"><a href="#NODE-中的事件循环-适用于-NODE-11-以下" class="headerlink" title="NODE 中的事件循环(适用于 NODE 11 以下)"></a>NODE 中的事件循环(适用于 NODE 11 以下)</h2><p><code>Node.js</code> 采用 <code>V8</code> 作为 <code>js</code> 的解析引擎，而 <code>I/O</code> 处理方面使用了自己设计的 <code>libuv</code>，<code>libuv</code> 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 <code>API</code>，<code>事件循环机制</code> 也是它里面的实现。</p><h3 id="事件循环模型"><a href="#事件循环模型" class="headerlink" title="事件循环模型"></a>事件循环模型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><ul><li><code>timers</code>: 执行 <code>定时器队列中的回调</code> 如 <code>setTimeout()</code> 和 <code>setInterval()</code>。</li><li><code>I/O callbacks</code>: 执行一些 <code>系统调用错误</code>，比如网络通信的错误回调。</li><li><code>idle, prepare</code>: 仅 <code>node</code> 内部使用。</li><li><code>poll</code>: 等待新的 <code>I/O</code> 事件，<code>node</code> 在一些特殊情况下会阻塞在这里。</li><li><code>check</code>: 执行 <code>setImmediate()的回调</code>。</li><li><code>close callbacks</code>: 执行 <code>socket 的 close 事件回调</code>，例如 <code>socket.on(&#39;close&#39;, ...)</code> 这种。</li></ul><h4 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h4><p><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code> 回调，并且是由 <code>poll</code> 阶段控制的。 同样，在 <code>Node</code> 中定时器指定的时间也不是准确时间，只能是尽快执行。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p><code>poll</code> 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p><ul><li>回到 <code>timer</code> 阶段执行回调</li><li>执行 <code>I/O</code> 回调<ul><li>如果 <code>poll</code> 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li><li>如果 <code>poll</code> 队列为空时<ul><li>如果有 <code>setImmediate</code> 回调需要执行，<code>poll</code> 阶段会停止并且进入到 <code>check</code> 阶段执行回调</li><li>如果没有 <code>setImmediate</code> 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li></ul></li></ul></li></ul><p>当然设定了 <code>timer</code> 的话且 <code>poll</code> 队列为空，则会判断是否有 <code>timer</code> 超时，如果有的话会回到 <code>timer</code> 阶段执行回调。</p><h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p><code>setImmediate()</code> 的回调会被加入 <code>check</code> 队列中</p><h3 id="node-事件循环流程"><a href="#node-事件循环流程" class="headerlink" title="node 事件循环流程"></a>node 事件循环流程</h3><p><code>外部输入数据</code>–&gt;<code>轮询阶段(poll)</code>–&gt;<code>检查阶段(check)</code>–&gt;<code>关闭事件回调阶段(close callback)</code>–&gt;<code>定时器检测阶段(timer)</code>–&gt;<code>I/O 事件回调阶段(I/O callbacks)</code>–&gt;<code>闲置阶段(idle, prepare)</code>–&gt;<code>轮询阶段</code>…</p><ul><li><code>event loop</code> 的每个阶段都有一个任务队列。</li><li>当 <code>event loop</code> 到达某个阶段时，将执行该阶段的任务队列，直到队列清空或执行的回调达到系统上限后，才会转入下一个阶段。</li><li>执行完 <code>nextTick队列</code> 里面的内容。</li><li>执行完 <code>微任务队列</code> 的内容。</li><li>当所有阶段被顺序执行一次后，称 <code>event loop</code> 完成了一个 <code>tick</code>。</li></ul><h3 id="node-注意点"><a href="#node-注意点" class="headerlink" title="node 注意点"></a>node 注意点</h3><ul><li><code>process.nextTick()</code>: 这个函数其实是独立于 <code>Event Loop</code> 之外的，它有一个自己的队列，当 <code>每个阶段</code> 完成后，如果存在 <code>nextTick 队列</code>，就会清空队列中的所有回调函数，并且 <code>优先于其他 microtask 执行</code>。</li><li>如果在 <code>timers</code> 阶段执行时创建了 <code>setImmediate</code> 则会在此轮循环的 <code>check</code> 阶段执行，如果在 <code>timers</code> 阶段创建了 <code>setTimeout</code>，由于 <code>timers</code> 已取出完毕，则会进入下轮循环，<code>check</code> 阶段创建 <code>timers</code> 任务同理。</li><li><code>setTimeout</code> 优先级比 <code>setImmediate</code> 高，但是由于 <code>setTimeout(fn,0)</code> 的真正延迟不可能完全为 0 秒，可能出现先创建的 <code>setTimeout(fn,0)</code> 而比 <code>setImmediate</code> 的回调后执行的情况。</li></ul><h3 id="node-举例"><a href="#node-举例" class="headerlink" title="node 举例"></a>node 举例</h3><h4 id="node-例-1"><a href="#node-例-1" class="headerlink" title="node 例 1"></a>node 例 1</h4><p>解析<a href="http://lynnelv.github.io/js-event-loop-nodejs" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'test.txt'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'readFile'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//readFile,immediate,timeout</span></span><br></pre></td></tr></table></figure><h4 id="node-例-2"><a href="#node-例-2" class="headerlink" title="node 例 2"></a>node 例 2</h4><p>解析<a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218#heading-14" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise3'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line"><span class="comment">//start=&gt;end=&gt;promise3=&gt;timer1=&gt;timer2=&gt;promise1=&gt;promise2</span></span><br></pre></td></tr></table></figure><h4 id="node-例-3"><a href="#node-例-3" class="headerlink" title="node 例 3"></a>node 例 3</h4><p>解析<a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218#heading-22" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>);</span><br><span class="line">      process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1</span></span><br></pre></td></tr></table></figure><h4 id="node-例-4"><a href="#node-例-4" class="headerlink" title="node 例 4"></a>node 例 4</h4><p>解析<a href="https://juejin.im/post/5aa5dcabf265da239c7afe1e#heading-9" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>() - startTime &lt; time) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1s over'</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout - 1'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout - 1 - 1'</span>);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout - 1 - then'</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setTimeout - 1 - then - then'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout - 2'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout - 2 - 1'</span>);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout - 2 - then'</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setTimeout - 2 - then - then'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout - 1</span></span><br><span class="line"><span class="comment">// 1s over</span></span><br><span class="line"><span class="comment">// setTimeout - 2 //1、2为单阶段task</span></span><br><span class="line"><span class="comment">// 1s over</span></span><br><span class="line"><span class="comment">// setTimeout - 1 - then</span></span><br><span class="line"><span class="comment">// setTimeout - 2 - then</span></span><br><span class="line"><span class="comment">// setTimeout - 1 - then - then</span></span><br><span class="line"><span class="comment">// setTimeout - 2 - then - then</span></span><br><span class="line"><span class="comment">// setTimeout - 1 - 1</span></span><br><span class="line"><span class="comment">// 1s over</span></span><br><span class="line"><span class="comment">// setTimeout - 2 - 1</span></span><br><span class="line"><span class="comment">// 1s over</span></span><br></pre></td></tr></table></figure><h3 id="node-示意图"><a href="#node-示意图" class="headerlink" title="node 示意图"></a>node 示意图</h3><p><img src="http://cdn.flqin.com/p359-3.png" alt="示意图"></p><h3 id="node-11-版本后"><a href="#node-11-版本后" class="headerlink" title="node 11 版本后"></a>node 11 版本后</h3><p><strong>和浏览器趋同，都是每执行一个宏任务就执行完微任务队列</strong>。<a href="https://zhuanlan.zhihu.com/p/54951550" target="_blank" rel="noopener">查阅 1</a>,<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/26" target="_blank" rel="noopener">查阅 2</a></p><h2 id="两者循环区别-NODE-11-之前"><a href="#两者循环区别-NODE-11-之前" class="headerlink" title="两者循环区别(NODE 11 之前)"></a>两者循环区别(NODE 11 之前)</h2><ul><li>浏览器环境下, <code>microtask</code> 的任务队列是每个 <code>macrotask</code> 执行完之后执行。</li><li>在 <code>Node.js</code> 中，<code>microtask</code> 会在事件循环的<code>各个阶段</code>之间执行，也就是一个阶段里所有的 <code>macrotask</code> 执行完毕，才会去执行 <code>microtask</code> 队列的任务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）nginx配置location总结及rewrite规则写法</title>
      <link href="/356.html"/>
      <url>/356.html</url>
      
        <content type="html"><![CDATA[<h2 id="nginx-介绍"><a href="#nginx-介绍" class="headerlink" title="nginx 介绍"></a>nginx 介绍</h2><p><code>nginx</code> 是一个高性能的 <code>web</code> 服务器，常用作反向代理服务器。<code>nginx</code> 作为反向代理服务器，就是把 <code>http</code> 请求转发到另一个或者一些服务器上。 通过把本地一个 <code>url</code> 前缀映射到要跨域访问的 <code>web</code> 服务器上，就可以实现跨域访问。 对于浏览器来说，访问的就是同源服务器上的一个 <code>url</code>。而 <code>nginx</code> 通过检测 <code>url</code> 前缀，把 <code>http</code> 请求转发到后面真实的物理服务器。并通过 <code>rewrite</code> 命令把前缀再去掉。这样真实的服务器就可以正确处理请求，并且并不知道这个请求是来自代理服务器的。 简单说，<code>nginx</code> 服务器欺骗了浏览器，让它认为这是同源调用，从而解决了浏览器的跨域问题。又通过重写 <code>url</code>，欺骗了真实的服务器，让它以为这个 <code>http</code> 请求是直接来自与用户浏览器的。 这样，为了解决跨域问题，只需要动一下 <code>nginx</code> 配置文件即可。简单、强大、高效!</p><h2 id="nginx-conf-配置文件"><a href="#nginx-conf-配置文件" class="headerlink" title="nginx.conf 配置文件"></a>nginx.conf 配置文件</h2><p><code>Nginx</code> 配置文件主要分成四部分：<code>main（全局设置）</code>、<code>server（主机设置）</code>、<code>upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）</code>和 <code>location（URL 匹配特定位置后的设置）</code>，每部分包含若干个指令。</p><p><code>main</code> 部分设置的指令将影响其它所有部分的设置；<code>server</code>部分的指令主要用于指定虚拟主机域名、IP 和端口；<code>upstream</code> 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；<code>location</code> 部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。</p><p>他们之间的关系是：<code>server</code> 继承 <code>main</code>，<code>location</code> 继承 <code>server</code>，<code>upstream</code> 既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。</p><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><p>下面的 <code>nginx.conf</code> 简单的实现 <code>nginx</code> 在前端做反向代理服务器的例子，处理 <code>js、png</code> 等静态文件，<code>jsp</code> 等动态请求转发到其它服务器 <code>tomcat</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">user  www www;</span><br><span class="line">worker_processes  2;</span><br><span class="line"></span><br><span class="line">error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  2048;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    # tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">  # gzip压缩功能设置</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_buffers    4 16k;</span><br><span class="line">    gzip_http_version 1.0;</span><br><span class="line">    gzip_comp_level 6;</span><br><span class="line">    gzip_types text/html text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">  # http_proxy 设置</span><br><span class="line">    client_max_body_size   10m;</span><br><span class="line">    client_body_buffer_size   128k;</span><br><span class="line">    proxy_connect_timeout   75;</span><br><span class="line">    proxy_send_timeout   75;</span><br><span class="line">    proxy_read_timeout   75;</span><br><span class="line">    proxy_buffer_size   4k;</span><br><span class="line">    proxy_buffers   4 32k;</span><br><span class="line">    proxy_busy_buffers_size   64k;</span><br><span class="line">    proxy_temp_file_write_size  64k;</span><br><span class="line">    proxy_temp_path   /usr/local/nginx/proxy_temp 1 2;</span><br><span class="line"></span><br><span class="line">  # 设定负载均衡后台服务器列表</span><br><span class="line">    upstream  backend  &#123;</span><br><span class="line">              #ip_hash;</span><br><span class="line">              server   192.168.10.100:8080 max_fails=2 fail_timeout=30s ;</span><br><span class="line">              server   192.168.10.101:8080 max_fails=2 fail_timeout=30s ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  # 很重要的虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  itoatest.example.com;</span><br><span class="line">        root   /apps/oaapp;</span><br><span class="line"></span><br><span class="line">        charset utf-8;</span><br><span class="line">        access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        #对 / 所有做负载均衡+反向代理</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /apps/oaapp;</span><br><span class="line">            index  index.jsp index.html index.htm;</span><br><span class="line"></span><br><span class="line">            proxy_pass        http://backend;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header  Host  $host;</span><br><span class="line">            proxy_set_header  X-Real-IP  $remote_addr;</span><br><span class="line">            proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #静态文件，nginx自己处理，不去backend请求tomcat</span><br><span class="line">        location  ~* /download/ &#123;</span><br><span class="line">            root /apps/oa/fs;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        location ~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$</span><br><span class="line">        &#123;</span><br><span class="line">            root /apps/oaapp;</span><br><span class="line">            expires      7d;</span><br><span class="line">        &#125;</span><br><span class="line">        location /nginx_status &#123;</span><br><span class="line">            stub_status on;</span><br><span class="line">            access_log off;</span><br><span class="line">            allow 192.168.10.0/24;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ ^/(WEB-INF)/ &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ## 其它虚拟主机，server 指令开始</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用指令说明"><a href="#常用指令说明" class="headerlink" title="常用指令说明"></a>常用指令说明</h3><h4 id="main-全局配置"><a href="#main-全局配置" class="headerlink" title="main 全局配置"></a>main 全局配置</h4><p><code>nginx</code> 在运行时与具体业务功能（比如 <code>http</code> 服务或者 <code>email</code> 服务代理）无关的一些参数，比如工作进程数，运行的身份等。</p><ul><li><p><code>woker_processes 2</code></p><p>在配置文件的顶级 <code>main</code> 部分，<code>worker</code> 角色的工作进程的个数，<code>master</code> 进程是接收并分配请求给 <code>worker</code> 处理。这个数值简单一点可以设置为 <code>cpu</code> 的核数 <code>grep ^processor /proc/cpuinfo | wc -l</code>，也是 <code>auto</code> 值，如果开启了 <code>ssl</code> 和 <code>gzip</code> 更应该设置成与逻辑 <code>CPU</code> 数量一样甚至为 2 倍，可以减少 <code>I/O</code> 操作。如果 <code>nginx</code> 服务器还有其它服务，可以考虑适当减少。</p></li><li><p><code>worker_cpu_affinity</code></p><p>也是写在 <code>main</code> 部分。在高并发情况下，通过设置 <code>cpu</code> 粘性来降低由于多 <code>CPU</code> 核切换造成的寄存器等现场重建带来的性能损耗。如 <code>worker_cpu_affinity 0001 0010 0100 1000</code>; （四核）。</p></li><li><p><code>worker_connections 2048</code></p><p>写在 <code>events</code> 部分。每一个 <code>worker</code> 进程能并发处理（发起）的最大连接数（包含与客户端或后端被代理服务器间等所有连接数）。<code>nginx</code> 作为反向代理服务器，计算公式 <code>最大连接数 = worker_processes \* worker_connections/4</code>，所以这里客户端最大连接数是 <code>1024</code>，这个可以增到到 <code>8192</code> 都没关系，看情况而定，但不能超过后面的 <code>worker_rlimit_nofile</code>。当 <code>nginx</code> 作为 <code>http</code> 服务器时，计算公式里面是除以 2。</p></li><li><p><code>worker_rlimit_nofile 10240</code></p><p>写在 <code>main</code> 部分。默认是没有设置，可以限制为操作系统最大的限制 65535。</p></li><li><p><code>use epoll</code></p><p>写在 <code>events</code> 部分。在 <code>Linux</code> 操作系统下，<code>nginx</code> 默认使用 <code>epoll</code> 事件模型，得益于此，<code>nginx</code> 在 <code>Linux</code> 操作系统下效率相当高。同时 <code>Nginx</code> 在 <code>OpenBSD</code> 或 <code>FreeBSD</code> 操作系统上采用类似于 <code>epoll</code> 的高效事件模型 <code>kqueue</code>。在操作系统不支持这些高效模型时才使用 <code>select</code>。</p></li></ul><h4 id="http-服务器"><a href="#http-服务器" class="headerlink" title="http 服务器"></a>http 服务器</h4><p>与提供 <code>http</code> 服务相关的一些配置参数。例如：是否使用 <code>keepalive</code> 啊，是否使用 <code>gzip</code> 进行压缩等。</p><ul><li><p><code>sendfile on</code></p><p>开启高效文件传输模式，<code>sendfile</code> 指令指定 <code>nginx</code> 是否调用 <code>sendfile</code> 函数来输出文件，减少用户空间到内核空间的上下文切换。对于普通应用设为 <code>on</code>，如果用来进行下载等应用磁盘 <code>IO</code> 重负载应用，可设置为 <code>off</code>，以平衡磁盘与网络 <code>I/O</code> 处理速度，降低系统的负载。</p></li><li><p><code>keepalive_timeout 65</code></p><p>长连接超时时间，单位是秒，这个参数很敏感，涉及浏览器的种类、后端服务器的超时设置、操作系统的设置，可以另外起一片文章了。长连接请求大量小文件的时候，可以减少重建连接的开销，但假如有大文件上传，65s 内没上传完成会导致失败。如果设置时间过长，用户又多，长时间保持连接会占用大量资源。</p></li><li><p><code>send_timeout</code></p><p>用于指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx 将会关闭连接。</p></li><li><p><code>client_max_body_size 10m</code></p><p>允许客户端请求的最大单文件字节数。如果有上传较大文件，请设置它的限制值</p></li><li><p><code>client_body_buffer_size 128k</code></p><p>缓冲区代理缓冲用户端请求的最大字节数</p></li></ul><h5 id="模块-http-proxy"><a href="#模块-http-proxy" class="headerlink" title="模块 http_proxy"></a>模块 http_proxy</h5><p>这个模块实现的是 <code>nginx</code> 作为反向代理服务器的功能，包括缓存功能（另见文章）</p><ul><li><p><code>proxy_connect_timeout 60</code></p><p>nginx 跟后端服务器连接超时时间(代理连接超时)</p></li><li><p><code>proxy_read_timeout 60</code></p><p>连接成功后，与后端服务器两个成功的响应操作之间超时时间(代理接收超时)</p></li><li><p><code>proxy_buffer_size 4k</code></p><p>设置代理服务器（nginx）从后端 realserver 读取并保存用户头信息的缓冲区大小，默认与 proxy_buffers 大小相同，其实可以将这个指令值设的小一点</p></li><li><p><code>proxy_buffers 4 32k</code></p><p>proxy_buffers 缓冲区，nginx 针对单个连接缓存来自后端 realserver 的响应，网页平均在 32k 以下的话，这样设置</p></li><li><p><code>proxy_busy_buffers_size 64k</code></p><p>高负荷下缓冲大小（proxy_buffers*2）</p></li><li><p><code>proxy_max_temp_file_size</code></p><p>当 proxy_buffers 放不下后端服务器的响应内容时，会将一部分保存到硬盘的临时文件中，这个值用来设置最大临时文件大小，默认 1024M，它与 proxy_cache 没有关系。大于这个值，将从 upstream 服务器传回。设置为 0 禁用。</p></li><li><p><code>proxy_temp_file_write_size 64k</code></p><p>当缓存被代理的服务器响应到临时文件时，这个选项限制每次写临时文件的大小。proxy_temp_path（可以在编译的时候）指定写到哪那个目录。</p></li></ul><h5 id="模块-http-gzip"><a href="#模块-http-gzip" class="headerlink" title="模块 http_gzip"></a>模块 http_gzip</h5><ul><li><p><code>gzip on</code> : 开启 gzip 压缩输出，减少网络传输。</p><ul><li><code>gzip_min_length 1k</code> ： 设置允许压缩的页面最小字节数，页面字节数从 header 头得 content-length 中进行获取。默认值是 20。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大。</li><li><code>gzip_buffers 4 16k</code> ： 设置系统获取几个单位的缓存用于存储 gzip 的压缩结果数据流。4 16k 代表以 16k 为单位，安装原始数据大小以 16k 为单位的 4 倍申请内存。</li><li><code>gzip_http_version 1.0</code> ： 用于识别 http 协议的版本，早期的浏览器不支持 Gzip 压缩，用户就会看到乱码，所以为了支持前期版本加上了这个选项，如果你用了 Nginx 的反向代理并期望也启用 Gzip 压缩的话，由于末端通信是 http/1.0，故请设置为 1.0。</li><li><code>gzip_comp_level 6</code> ： gzip 压缩比，1 压缩比最小处理速度最快，9 压缩比最大但处理速度最慢(传输快但比较消耗 cpu)</li><li><code>gzip_types</code> ：匹配 mime 类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。</li><li><code>gzip_proxied any</code> ： Nginx 作为反向代理的时候启用，决定开启或者关闭后端服务器返回的结果是否压缩，匹配的前提是后端服务器必须要返回包含”Via”的 header 头。</li><li><code>gzip_vary on</code> ： 和 http 头有关系，会在响应头加个 Vary: Accept-Encoding ，可以让前端的缓存服务器缓存经过 gzip 压缩的页面，例如，用 Squid 缓存经过 Nginx 压缩的数据。。</li></ul></li></ul><h4 id="server-虚拟主机"><a href="#server-虚拟主机" class="headerlink" title="server 虚拟主机"></a>server 虚拟主机</h4><p>http 服务上支持若干虚拟主机。每个虚拟主机一个对应的 server 配置项，配置项里面包含该虚拟主机相关的配置。在提供 mail 服务的代理时，也可以建立若干 server。每个 server 通过监听地址或端口来区分。</p><ul><li><code>listen</code>:监听端口，默认 80，小于 1024 的要以 root 启动。可以为 listen *:80、listen 127.0.0.1:80 等形式。</li><li><code>server_name</code>:服务器名，如 localhost、<a href="http://www.example.com，可以通过正则匹配。" target="_blank" rel="noopener">www.example.com，可以通过正则匹配。</a></li></ul><h5 id="模块-http-stream"><a href="#模块-http-stream" class="headerlink" title="模块 http_stream"></a>模块 http_stream</h5><p>这个模块通过一个简单的调度算法来实现客户端 IP 到后端服务器的负载均衡，upstream 后接负载均衡器的名字，后端 realserver 以 host:port options; 方式组织在 {} 中。如果后端被代理的只有一台，也可以直接写在 proxy_pass 。</p><h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p>http 服务中，某些特定的 URL 对应的一系列配置项。</p><ul><li><p><code>root /var/www/html</code></p><p>定义服务器的默认网站根目录位置。如果 locationURL 匹配的是子目录或文件，root 没什么作用，一般放在 server 指令里面或/下。</p></li><li><p><code>index.jsp index.html index.htm</code></p><p>定义路径下默认访问的文件名，一般跟着 root 放</p></li><li><p><code>proxy_pass http:/backend</code></p><p>请求转向 backend 定义的服务器列表，即反向代理，对应 upstream 负载均衡器。也可以 <code>proxy_pass http://ip:port</code>。</p></li><li><p><code>proxy_redirect off;</code></p><p><code>proxy_set_header Host \$host;</code></p><p><code>proxy_set_header X-Real-IP \$remote_addr;</code></p><p><code>proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;</code></p><p>这四个暂且这样设，如果深究的话，每一个都涉及到很复杂的内容，也将通过另一篇文章来解读。</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="访问控制-allow-deny"><a href="#访问控制-allow-deny" class="headerlink" title="访问控制 allow/deny"></a>访问控制 allow/deny</h4><p>Nginx 的访问控制模块默认就会安装，而且写法也非常简单，可以分别有多个 allow,deny，允许或禁止某个 ip 或 ip 段访问，依次满足任何一个规则就停止往下匹配。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location /nginx-status &#123;</span><br><span class="line">  stub_status on;</span><br><span class="line">  access_log off;</span><br><span class="line">#  auth_basic   &quot;NginxStatus&quot;;</span><br><span class="line">#  auth_basic_user_file   /usr/local/nginx-1.6/htpasswd;</span><br><span class="line"></span><br><span class="line">  allow 192.168.10.100;</span><br><span class="line">  allow 172.29.73.0/24;</span><br><span class="line">  deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也常用 httpd-devel 工具的 htpasswd 来为访问的路径设置登录密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># htpasswd -c htpasswd admin</span><br><span class="line">New passwd:</span><br><span class="line">Re-type new password:</span><br><span class="line">Adding password for user admin</span><br><span class="line"></span><br><span class="line"># htpasswd htpasswd admin    //修改admin密码</span><br><span class="line"># htpasswd htpasswd sean    //多添加一个认证用户</span><br></pre></td></tr></table></figure><p>这样就生成了默认使用 CRYPT 加密的密码文件。打开上面 nginx-status 的两行注释，重启 nginx 生效。</p><h4 id="列出目录-autoindex"><a href="#列出目录-autoindex" class="headerlink" title="列出目录 autoindex"></a>列出目录 autoindex</h4><p>Nginx 默认是不允许列出整个目录的。如需此功能，打开 nginx.conf 文件，在 location，server 或 http 段中加入 autoindex on;，另外两个参数最好也加上去:</p><ul><li><p><code>autoindex_exact_size off;</code></p><p>默认为 on，显示出文件的确切大小，单位是 bytes。改为 off 后，显示出文件的大概大小，单位是 kB 或者 MB 或者 GB</p></li><li><p><code>autoindex_localtime on;</code></p><p>默认为 off，显示的文件时间为 GMT 时间。改为 on 后，显示的文件时间为文件的服务器时间</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /images &#123;</span><br><span class="line">  root   /var/www/nginx-default/images;</span><br><span class="line">  autoindex on;</span><br><span class="line">  autoindex_exact_size off;</span><br><span class="line">  autoindex_localtime on;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="重新加载-nginx-配置文件"><a href="#重新加载-nginx-配置文件" class="headerlink" title="重新加载 nginx 配置文件"></a>重新加载 nginx 配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="location-正则写法"><a href="#location-正则写法" class="headerlink" title="location 正则写法"></a>location 正则写法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">location  = / &#123;</span><br><span class="line">  # 精确匹配 / ，主机名后面不能带任何字符串</span><br><span class="line">  [ configuration A ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location  / &#123;</span><br><span class="line">  # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求</span><br><span class="line">  # 但是正则和最长字符串会优先匹配</span><br><span class="line">  [ configuration B ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /documents/ &#123;</span><br><span class="line">  # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索</span><br><span class="line">  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span><br><span class="line">  [ configuration C ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /documents/Abc &#123;</span><br><span class="line">  # 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索</span><br><span class="line">  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span><br><span class="line">  [ configuration CC ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">  # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。</span><br><span class="line">  [ configuration D ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">  # 匹配所有以 gif,jpg或jpeg 结尾的请求</span><br><span class="line">  # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则</span><br><span class="line">  [ configuration E ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /images/ &#123;</span><br><span class="line">  # 字符匹配到 /images/，继续往下，会发现 ^~ 存在</span><br><span class="line">  [ configuration F ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /images/abc &#123;</span><br><span class="line">  # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在</span><br><span class="line">  # F与G的放置顺序是没有关系的</span><br><span class="line">  [ configuration G ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /images/abc/ &#123;</span><br><span class="line">  # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用</span><br><span class="line">    [ configuration H ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* /js/.*/\.js</span><br></pre></td></tr></table></figure><ul><li>以<code>=</code>开头表示精确匹配</li><li>如<code>A</code>中只匹配根目录结尾的请求，后面不能带任何字符串。</li><li><code>^~</code>开头表示<code>uri</code>以某个常规字符串开头，不是正则匹配</li><li><code>~</code>开头表示区分大小写的正则匹配;</li><li><code>~\*</code>开头表示不区分大小写的正则匹配</li><li><code>/</code>通用匹配, 如果没有其它匹配,任何请求都会匹配到</li><li>顺序<code>(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</code></li></ul><p>按照上面的 location 写法，以下的匹配示例成立:</p><ul><li>/ -&gt; config A<br>精确完全匹配，即使/index.html 也匹配不了</li><li>/downloads/download.html -&gt; config B<br>匹配 B 以后，往下没有任何匹配，采用 B</li><li>/images/1.gif -&gt; configuration D<br>匹配到 F，往下匹配到 D，停止往下</li><li>/images/abc/def -&gt; config D<br>最长匹配到 G，往下匹配 D，停止往下<br>你可以看到 任何以/images/开头的都会匹配到 D 并停止，FG 写在这里是没有任何意义的，H 是永远轮不到的，这里只是为了说明匹配顺序</li><li>/documents/document.html -&gt; config C<br>匹配到 C，往下没有任何匹配，采用 C</li><li>/documents/1.jpg -&gt; configuration E<br>匹配到 C，往下正则匹配到 E</li><li>/documents/Abc.jpg -&gt; config CC<br>最长匹配到 C，往下正则顺序匹配到 CC，不会往下到 E</li></ul><p>实际使用建议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">所以实际使用中，个人觉得至少有三个匹配规则定义，如下：</span><br><span class="line">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。</span><br><span class="line">#这里是直接转发给后端应用服务器了，也可以是一个静态首页</span><br><span class="line"># 第一个必选规则</span><br><span class="line">location = / &#123;</span><br><span class="line">    proxy_pass http://tomcat:8080/index</span><br><span class="line">&#125;</span><br><span class="line"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span><br><span class="line"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span><br><span class="line">location ^~ /static/ &#123;</span><br><span class="line">    root /webroot/static/;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">    root /webroot/res/;</span><br><span class="line">&#125;</span><br><span class="line">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span><br><span class="line">#非静态文件请求就默认是动态请求，自己根据实际把握</span><br><span class="line">#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://tomcat:8080/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Rewrite-规则"><a href="#Rewrite-规则" class="headerlink" title="Rewrite 规则"></a>Rewrite 规则</h2><p><code>rewrite</code>使用<code>nginx</code>提供的全局变量或自己设置的变量，结合<code>正则表达式</code>和<code>标志位</code>实现 url 重写以及重定向。</p><p><code>rewrite</code> 只能放在 <code>server{},location{},if{}</code>中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 <code>http://seanlook.com/a/we/index.php?id=1&amp;u=str</code> 只对<code>/a/we/index.php</code> 重写。</p><p>如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用 <code>proxy_pass</code> 反向代理。</p><p>表明看 <code>rewrite</code> 和 <code>location</code> 功能有点像，都能实现跳转，主要区别在于 <code>rewrite</code> 是在同一域名内更改获取资源的路径，而 <code>location</code> 是对一类路径做控制访问或反向代理，可以 <code>proxy_pass</code> 到其他机器。很多情况下 <code>rewrite</code> 也会写在 <code>location</code> 里，它们的执行顺序是：</p><ul><li>执行 <code>server</code> 块的 <code>rewrite</code> 指令</li><li>执行 location 匹配</li><li>执行选定的 location 中的 rewrite 指令</li></ul><p>如果其中某步 <code>URI</code> 被重写，则重新循环执行 <code>1-3</code>，直到找到真实存在的文件；循环超过 10 次，则返回 500 Internal Server Error 错误。</p><h3 id="flag-标志位"><a href="#flag-标志位" class="headerlink" title="flag 标志位"></a>flag 标志位</h3><ul><li><code>last</code> : 相当于 Apache 的<code>[L]</code>标记，表示完成 rewrite</li><li><code>break</code> : 停止执行当前虚拟主机的后续 rewrite 指令集</li><li><code>redirect</code> : 返回 302 临时重定向，地址栏会显示跳转后的地址</li><li><code>permanent</code> : 返回 301 永久重定向，地址栏会显示跳转后的地址</li></ul><p>因为 301 和 302 不能简单的只返回状态码，还必须有重定向的 URL，这就是 return 指令无法返回 301,302 的原因了。这里 last 和 break 区别有点难以理解：</p><ul><li>last 一般写在 server 和 if 中，而 break 一般使用在 location 中</li><li>last 不终止重写后的 url 匹配，即新的 url 会再从 server 走一遍匹配流程，而 break 终止重写后的匹配</li><li>break 和 last 都能阻止继续执行后面的 rewrite 指令</li></ul><h3 id="if-指令与全局变量"><a href="#if-指令与全局变量" class="headerlink" title="if 指令与全局变量"></a>if 指令与全局变量</h3><h4 id="if-判断指令"><a href="#if-判断指令" class="headerlink" title="if 判断指令"></a>if 判断指令</h4><p>语法为 <code>if(condition){...}</code>，对给定的条件 <code>condition</code> 进行判断。如果为真，大括号内的 <code>rewrite</code> 指令将被执行，if 条件(<code>conditon</code>)可以是如下任何内容：</p><ul><li>当表达式只是一个变量时，如果值为空或任何以 0 开头的字符串都会当做 false</li><li>直接比较变量和内容时，使用<code>=或!=</code></li><li><code>~</code>正则表达式匹配，<code>~\*</code>不区分大小写的匹配，<code>!~</code>区分大小写的不匹配</li><li><code>-f 和!-f</code> 用来判断是否存在文件</li><li>`-d 和!-d 用来判断是否存在目录</li><li><code>-e 和!-e</code> 用来判断是否存在文件或目录</li><li><code>-x 和!-x</code> 用来判断文件是否可执行</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125; //如果UA包含&quot;MSIE&quot;，rewrite请求到/msid/目录下</span><br><span class="line"></span><br><span class="line">if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) &#123;</span><br><span class="line">    set $id $1;</span><br><span class="line"> &#125; //如果cookie匹配正则，设置变量$id等于正则引用部分</span><br><span class="line"></span><br><span class="line">if ($request_method = POST) &#123;</span><br><span class="line">    return 405;</span><br><span class="line">&#125; //如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302</span><br><span class="line"></span><br><span class="line">if ($slow) &#123;</span><br><span class="line">    limit_rate 10k;</span><br><span class="line">&#125; //限速，$slow可以通过 set 指令设置</span><br><span class="line"></span><br><span class="line">if (!-f $request_filename)&#123;</span><br><span class="line">    break;</span><br><span class="line">    proxy_pass  http://127.0.0.1;</span><br><span class="line">&#125; //如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查</span><br><span class="line"></span><br><span class="line">if ($args ~ post=140)&#123;</span><br><span class="line">    rewrite ^ http://example.com/ permanent;</span><br><span class="line">&#125; //如果query string中包含&quot;post=140&quot;，永久重定向到example.com</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|png|swf|flv)$ &#123;</span><br><span class="line">    valid_referers none blocked www.jefflei.com www.leizhenfang.com;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        return 404;</span><br><span class="line">    &#125; //防盗链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>下面是可以用作 if 判断的全局变量:</p><ul><li><code>$args</code> ： #这个变量等于请求行中的参数，同$query_string</li><li><code>$content_length</code> ： 请求头中的 Content-length 字段。</li><li><code>$content_type</code> ： 请求头中的 Content-Type 字段。</li><li><code>$document_root</code> ： 当前请求在 root 指令中指定的值。</li><li><code>$host</code> ： 请求主机头字段，否则为服务器名称。</li><li><code>$http_user_agent</code> ： 客户端 agent 信息</li><li><code>$http_cookie</code> ： 客户端 cookie 信息</li><li><code>$limit_rate</code> ： 这个变量可以限制连接速率。</li><li><code>$request_method</code> ： 客户端请求的动作，通常为 GET 或 POST。</li><li><code>$remote_addr</code> ： 客户端的 IP 地址。</li><li><code>$remote_port</code> ： 客户端的端口。</li><li><code>$remote_user</code> ： 已经经过 Auth Basic Module 验证的用户名。</li><li><code>$request_filename</code> ： 当前请求的文件路径，由 root 或 alias 指令与 URI 请求生成。</li><li><code>$scheme</code> ： HTTP 方法（如 http，https）。</li><li><code>$server_protocol</code> ： 请求使用的协议，通常是 HTTP/1.0 或 HTTP/1.1。</li><li><code>$server_addr</code> ： 服务器地址，在完成一次系统调用后可以确定这个值。</li><li><code>$server_name</code> ： 服务器名称。</li><li><code>$server_port</code> ： 请求到达服务器的端口号。</li><li><code>$request_uri</code> ： 包含请求参数的原始 URI，不包含主机名，如：”/foo/bar.php?arg=baz”。</li><li><code>$uri</code> ： 不带请求参数的当前 URI，$uri 不包含主机名，如”/foo/bar.html”。</li><li><code>$document_uri</code> ： 与$uri 相同。</li></ul><p>例：<code>http://localhost:88/test1/test2/test.php</code></p><ul><li><code>$host</code>：<code>localhost</code></li><li><code>$server_port</code>：<code>88</code></li><li><code>$request_uri</code>：<code>http://localhost:88/test1/test2/test.php</code></li><li><code>$document_uri</code>：<code>/test1/test2/test.php</code></li><li><code>$document_root</code>：<code>/var/www/html</code></li><li><code>$request_filename</code>：<code>/var/www/html/test1/test2/test.php</code></li></ul><h4 id="rewrite-实例"><a href="#rewrite-实例" class="headerlink" title="rewrite 实例"></a>rewrite 实例</h4><p>例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">http &#123; # 定义 image 日志格式</span><br><span class="line">log_format imagelog &apos;[$time_local] &apos; $image_file &apos; &apos; $image_type &apos; &apos; $body_bytes_sent &apos; &apos; $status; # 开启重写日志</span><br><span class="line">rewrite_log on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        root /home/www;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                # 重写规则信息</span><br><span class="line">                error_log logs/rewrite.log notice;</span><br><span class="line">                # 注意这里要用‘’单引号引起来，避免&#123;&#125;</span><br><span class="line">                rewrite &apos;^/images/([a-z]&#123;2&#125;)/([a-z0-9]&#123;5&#125;)/(.*)\.(png|jpg|gif)$&apos; /data?file=$3.$4;</span><br><span class="line">                # 注意不能在上面这条规则后面加上“last”参数，否则下面的set指令不会执行</span><br><span class="line">                set $image_file $3;</span><br><span class="line">                set $image_type $4;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /data &#123;</span><br><span class="line">                # 指定针对图片的日志格式，来分析图片类型和大小</span><br><span class="line">                access_log logs/images.log mian;</span><br><span class="line">                root /data/images;</span><br><span class="line">                # 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最后一个url里</span><br><span class="line">                try_files /$arg_file /image404.html;</span><br><span class="line">        &#125;</span><br><span class="line">        location = /image404.html &#123;</span><br><span class="line">                # 图片不存在返回特定的信息</span><br><span class="line">                return 404 &quot;image not found\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对形如<code>/images/ef/uh7b3/test.png</code> 的请求，重写到<code>/data?file=test.png</code>，于是匹配到 <code>location /data</code>，先看<code>/data/images/test.png</code> 文件存不存在，如果存在则正常响应，如果不存在则重写 <code>tryfiles</code> 到新的 <code>image404 location</code>，直接返回 <code>404</code> 状态码。</p><p>例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^/images/(.\*)\_(\d+)x(\d+)\.(png|jpg|gif)$ /resizer/$1.$4?width=$2&amp;height=\$3? last;</span><br></pre></td></tr></table></figure><p>对形如<code>/images/bla_500x400.jpg</code> 的文件请求，重写到<code>/resizer/bla.jpg?width=500&amp;height=400</code> 地址，并会继续尝试匹配 <code>location</code>。</p><p>例 3：</p><p><a href="http://seanlook.com/2015/05/28/nginx-ssl/" target="_blank" rel="noopener">ssl 部分页面加密</a></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深浅拷贝总结</title>
      <link href="/355.html"/>
      <url>/355.html</url>
      
        <content type="html"><![CDATA[<h2 id="深浅拷贝的区分"><a href="#深浅拷贝的区分" class="headerlink" title="深浅拷贝的区分"></a>深浅拷贝的区分</h2><p>深浅拷贝，只针对复杂数据类型来说的。</p><h3 id="浅拷贝-ShallowCopy"><a href="#浅拷贝-ShallowCopy" class="headerlink" title="浅拷贝 (ShallowCopy)"></a>浅拷贝 (ShallowCopy)</h3><p>是一个对象的逐位副本。创建一个新对象，该对象具有原始对象中的精确副本。如果对象的任何字段是对其他对象的引用，则只复制引用地址，即只复制内存地址，而不复制对象本身，新旧对象还是共享同一块堆内存。改变其中一个对象，另一个也会受影响。如果有修改，会失去原始数据。</p><h3 id="深拷贝-DeepCopy"><a href="#深拷贝-DeepCopy" class="headerlink" title="深拷贝 (DeepCopy)"></a>深拷贝 (DeepCopy)</h3><p>复制出一个全新的对象实例，新对象跟原对象不共享内存，两者操作互不影响。</p><p><strong>深拷贝是一个很复杂的问题，边缘 case 太多，比如<code>环引</code>、<code>原生 DOM/BOM对象</code>、<code>RegExp</code>、<code>Date</code>、<code>包装类Number,String,Boolean</code> 、<code>函数</code>、<code>原型链</code>、<code>不可枚举的属性</code>、<code>set/map/weakset/weakmap</code>、<code>Symbol</code>等，很多深拷贝如<code>函数</code>、<code>RegExp</code>等在实际运用中都没有多大意义，如果在开发中遇到需要深拷贝的地方，首先考虑代码设计问题，它面对的问题往往可以用更优雅的方式解决。</strong></p><h2 id="浅拷贝方法"><a href="#浅拷贝方法" class="headerlink" title="浅拷贝方法"></a>浅拷贝方法</h2><h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">o1.a = <span class="number">2</span>;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o2.a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b === a); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Array-concat"><a href="#Array-concat" class="headerlink" title="Array.concat()"></a>Array.concat()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = [<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> o2 = o1.concat(); <span class="comment">// 这里会返回一个o1对象的浅拷贝对象</span></span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">//  [1, [2], 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(o1 === o2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Array-slice"><a href="#Array-slice" class="headerlink" title="Array.slice()"></a>Array.slice()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = [<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> o2 = o1.slice(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">// [1, [2], 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(o1 === o2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p><code>Object.assign()</code> 方法用于将所有可枚举的自有属性的值从一个或多个源对象复制到目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">3</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.assign(&#123;&#125;, o1);</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123; a : 1, b : &#123; c : 2, d : 3&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">// &#123; a : 1, b : &#123; c : 2, d : 3&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2 === o1); <span class="comment">// false    说明实现了浅拷贝</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝方法"><a href="#深拷贝方法" class="headerlink" title="深拷贝方法"></a>深拷贝方法</h2><h3 id="手动拷贝"><a href="#手动拷贝" class="headerlink" title="手动拷贝"></a>手动拷贝</h3><p>将每个引用对象都通过复制值来实现深拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">a</span>: o1.a, <span class="attr">b</span>: o1.b &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o2 === o1); <span class="comment">// false</span></span><br><span class="line">o1.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123;a: 2, b: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure><p>该方法只适合简单的对象，并且没有引用的属性，适用范围很窄。</p><h3 id="JSON-parse-JSON-stringify-（常用）"><a href="#JSON-parse-JSON-stringify-（常用）" class="headerlink" title="JSON.parse(JSON.stringify()) （常用）"></a>JSON.parse(JSON.stringify()) （常用）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(o1));</span><br><span class="line"><span class="built_in">console</span>.log(o1 === o2); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(o1.b === o2.b); <span class="comment">// false</span></span><br><span class="line">o1.b.c = <span class="number">22</span>;</span><br><span class="line">o1.a = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">//   &#123; a : 11, b : &#123; c : 22&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">//   &#123; a : 1, b : &#123; c : 2&#125; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>该方法只能深拷贝对象和数组，内部递归实现，毕竟 <code>JSON</code> 的两个方法本身就只是用来转换 <code>js</code> 内的对象为 <code>JSON</code> 格式</li><li><code>Set</code> 类型、<code>Map</code> 类型以及 <code>Buffer</code> 类型会被转换成 {}</li><li><code>undefined</code>、任意的函数以及 <code>symbol</code> 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 <code>null</code>（出现在数组中时）</li><li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误</li><li>所有以 <code>symbol</code> 为属性键的属性都会被完全忽略掉，即便 <code>replacer</code> 参数中强制指定包含了它们</li><li>不可枚举的属性会被忽略</li></ul><h3 id="迭代递归法（常用）"><a href="#迭代递归法（常用）" class="headerlink" title="迭代递归法（常用）"></a>迭代递归法（常用）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(x) === <span class="string">'[object Object]'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(obj)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'obj 不是一个对象！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isArray = <span class="built_in">Array</span>.isArray(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = isArray ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法存在的问题：</p><ul><li>适合一般 <code>对象</code> 和 <code>数组</code> 的拷贝</li><li>层级太深时容易爆栈</li><li>未考虑 <code>func,date,reg,err,Map,Set,Symbol,原型链，不可枚举</code> 等 <code>case</code></li><li>未考虑循环引用</li></ul><h3 id="循环法"><a href="#循环法" class="headerlink" title="循环法"></a>循环法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保持引用关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneForce</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// =============</span></span><br><span class="line">  <span class="keyword">const</span> uniqueList = []; <span class="comment">// 用来去重</span></span><br><span class="line">  <span class="comment">// =============</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环数组</span></span><br><span class="line">  <span class="keyword">const</span> loopList = [</span><br><span class="line">    &#123;</span><br><span class="line">      parent: root,</span><br><span class="line">      key: <span class="literal">undefined</span>,</span><br><span class="line">      data: x</span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (loopList.length) &#123;</span><br><span class="line">    <span class="comment">// 广度优先</span></span><br><span class="line">    <span class="keyword">const</span> node = loopList.pop();</span><br><span class="line">    <span class="keyword">const</span> parent = node.parent;</span><br><span class="line">    <span class="keyword">const</span> key = node.key;</span><br><span class="line">    <span class="keyword">const</span> data = node.data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class="line">    <span class="keyword">let</span> res = parent;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      res = parent[key] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =============</span></span><br><span class="line">    <span class="comment">// 数据已经存在</span></span><br><span class="line">    <span class="keyword">let</span> uniqueData = find(uniqueList, data);</span><br><span class="line">    <span class="keyword">if</span> (uniqueData) &#123;</span><br><span class="line">      parent[key] = uniqueData.target;</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// 中断本次循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据不存在</span></span><br><span class="line">    <span class="comment">// 保存源数据，在拷贝数据中对应的引用</span></span><br><span class="line">    uniqueList.push(&#123;</span><br><span class="line">      source: data,</span><br><span class="line">      target: res</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// =============</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> data[k] === <span class="string">'object'</span>) &#123;</span><br><span class="line">          <span class="comment">// 下一次循环</span></span><br><span class="line">          loopList.push(&#123;</span><br><span class="line">            parent: res,</span><br><span class="line">            key: k,</span><br><span class="line">            data: data[k]</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          res[k] = data[k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i].source === item) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该方法未采用递归，采用循环的方式遍历，不会爆栈。</li><li>解决了循环引用的问题。</li><li>未考虑 <code>func,date,reg,err,Map,Set,Symbol,原型链，不可枚举</code> 等 <code>case</code></li></ul><h3 id="结构化克隆方法"><a href="#结构化克隆方法" class="headerlink" title="结构化克隆方法"></a>结构化克隆方法</h3><p>结构化算法嗦支持的拷贝类型见<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/The_structured_clone_algorithm" target="_blank" rel="noopener">文档</a></p><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage()"></a>postMessage()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;port1, port2&#125; = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">    port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">const</span> clone = <span class="keyword">await</span> structuralClone(obj);</span><br></pre></td></tr></table></figure><p>特点：异步、兼容性 ok</p><h4 id="Notification-API"><a href="#Notification-API" class="headerlink" title="Notification API"></a>Notification API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Notification(<span class="string">''</span>, &#123;<span class="attr">data</span>: obj, <span class="attr">silent</span>: <span class="literal">true</span>&#125;).data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">const</span> clone = structuralClone(obj);</span><br></pre></td></tr></table></figure><p>特点：简洁、兼容性不佳（<code>safari</code> 全系列不支持）</p><h4 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldState = history.state;</span><br><span class="line">  history.replaceState(obj, <span class="built_in">document</span>.title);</span><br><span class="line">  <span class="keyword">const</span> copy = history.state;</span><br><span class="line">  history.replaceState(oldState, <span class="built_in">document</span>.title);</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">const</span> clone = structuralClone(obj);</span><br></pre></td></tr></table></figure><p>特点：<code>Safari</code> 对 <code>replaceState</code> 调用的限制数量为 30 秒内 100 次。</p><h2 id="深拷贝中其他类型的拷贝"><a href="#深拷贝中其他类型的拷贝" class="headerlink" title="深拷贝中其他类型的拷贝"></a>深拷贝中其他类型的拷贝</h2><h3 id="拷贝-Symbol"><a href="#拷贝-Symbol" class="headerlink" title="拷贝 Symbol"></a>拷贝 Symbol</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接 迭代递归法</span></span><br><span class="line"><span class="keyword">let</span> symKeys = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="keyword">if</span> (symKeys.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  symKeys.forEach(<span class="function"><span class="params">symKey</span> =&gt;</span> &#123;</span><br><span class="line">    cloneObj[symKey] = isObject(obj[symKey]) ? deepClone(obj[symKey]) : obj[symKey];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝原型上的属性"><a href="#拷贝原型上的属性" class="headerlink" title="拷贝原型上的属性"></a>拷贝原型上的属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj));</span><br></pre></td></tr></table></figure><h3 id="拷贝不可枚举的属性"><a href="#拷贝不可枚举的属性" class="headerlink" title="拷贝不可枚举的属性"></a>拷贝不可枚举的属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), <span class="built_in">Object</span>.getOwnPropertyDescriptors());</span><br></pre></td></tr></table></figure><h3 id="拷贝-Map-Set"><a href="#拷贝-Map-Set" class="headerlink" title="拷贝 Map,Set"></a>拷贝 Map,Set</h3><h3 id="拷贝原始值和包装类"><a href="#拷贝原始值和包装类" class="headerlink" title="拷贝原始值和包装类"></a>拷贝原始值和包装类</h3><h4 id="等号直接赋值"><a href="#等号直接赋值" class="headerlink" title="等号直接赋值"></a>等号直接赋值</h4><h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h4><h3 id="拷贝-Date-对象"><a href="#拷贝-Date-对象" class="headerlink" title="拷贝 Date 对象"></a>拷贝 Date 对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().valueOf());</span><br></pre></td></tr></table></figure><h3 id="拷贝正则"><a href="#拷贝正则" class="headerlink" title="拷贝正则"></a>拷贝正则</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneRegExp</span>(<span class="params">regexp</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回当前匹配的文本</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> regexp.constructor(regexp.source, reFlags.exec(regexp));</span><br><span class="line">  <span class="comment">// 下一次匹配的起始索引</span></span><br><span class="line">  result.lastIndex = regexp.lastIndex;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝函数，Err"><a href="#拷贝函数，Err" class="headerlink" title="拷贝函数，Err"></a>拷贝函数，Err</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cloneObj = <span class="built_in">eval</span>(obj[k].toString());</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">cloneObj = obj[k].bind();</span><br></pre></td></tr></table></figure><h3 id="拷贝-Map-WeakMap-Set-WeakSet"><a href="#拷贝-Map-WeakMap-Set-WeakSet" class="headerlink" title="拷贝 Map,WeakMap,Set,WeakSet"></a>拷贝 Map,WeakMap,Set,WeakSet</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用遍历for...of 或者 forEach</span></span><br><span class="line"><span class="comment">//如果是Map,WeakMap</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> newS = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  newS.add(item);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是Set,WeakSet</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'x'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'y'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'z'</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">let</span> newM = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">  newM.set(key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="更多参考-lodash"><a href="#更多参考-lodash" class="headerlink" title="更多参考 lodash"></a>更多参考 lodash</h2><p><a href="https://github.com/lodash/lodash/blob/master/.internal/baseClone.js" target="_blank" rel="noopener">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）line-height 3种设置方式的区别</title>
      <link href="/354.html"/>
      <url>/354.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载来源 <a href="https://www.jianshu.com/p/76071076a8f6" target="_blank" rel="noopener">line-height 3 种设置方式的区别</a></p></blockquote><p><code>line-height</code> 是具有继承性的，如果直接在某个元素上使用 <code>line-height</code>，那么这三种写法是没有区别的，比如给所有的 <code>p</code> 标签添加行高属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">150%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的效果是一样的。</p><p>这三种方式的区别在于，给父元素设置行高的时候子元素的继承方式。</p><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><ul><li>子元素字体大小的 <code>em</code> 是相对于父元素字体大小</li><li>元素的 <code>width/height/padding/margin/line-height等</code> 用 <code>em</code> 的话是相对于该元素的 <code>font-size</code></li></ul><p>假如我们有一个父 <code>div</code> 类名为 <code>parent1</code>，另一个父 <code>div</code> 类名为 <code>parent2</code>，均包含了一个类名为 <code>child</code> 的子 <code>div</code>，<code>HTML</code> 结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>line-height: 1.5em;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>line-height: 1.5;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS 如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">26px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的页面如下截图：</p><p><img src="http://cdn.flqin.com/p354-1.png" alt="line-height"></p><p>可以看到，当设置 <code>line-height: 1.5em</code> 时，很明显子 <code>div</code> 的文字已经超出自己的行高范围了，设置 <code>line-height: 1.5</code> 时子 <code>div</code> 的文字没有超出自己的行高。</p><p>这是由于 <code>CSS</code> 继承时的计算方式区别造成的，如示例，当我们给类名为 <code>parent1</code> 的父 div 设置 <code>line-height：1.5em</code> 时，该 <code>div</code> 的 <code>font-size</code> 为 <code>14</code>，此时经过计算父 <code>div</code> 的 <code>line-height</code> 为 <code>14px\*1.5=21px</code>，然后子 <code>div</code> 的 <code>line-height</code> 就会继承 <code>21px</code> 这个值，而子 <code>div</code> 的 <code>font-size</code> 为 <code>26px</code>，自然会超出自己的行高范围。</p><p>而当我们给类名为 <code>parent2</code> 的父 div 设置 <code>line-height：1.5</code> 时，子 <code>div</code> 会直接继承 <code>line-height：1.5</code>，然后计算 <code>26px\*1.5=39px</code>，不会超出自己的行高范围。</p><p>经过测试 <code>line-height: 150%</code> 和 <code>line-height: 1.5em</code> 相同，都是先计算然后把固定的行高继承给子元素，所以我们可以总结一下，<strong>继承 <code>line-height</code> 的时候，带单位的先计算再继承，不带单位的直接继承</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS Grid布局</title>
      <link href="/353.html"/>
      <url>/353.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-grid"><a href="#什么是-grid" class="headerlink" title="什么是 grid"></a>什么是 grid</h2><p>网格布局（<code>Grid</code>）是最强大的 <code>CSS</code> 布局方案。它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。浏览器支持程度<a href="https://www.caniuse.com/#search=grid" target="_blank" rel="noopener">查阅</a>。</p><p>设为网格布局以后，容器子元素的 <code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code> 和 <code>column-*</code>等设置都将失效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">display</span>: inline-grid; <span class="comment">/* 行内元素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>以下属性设置在 <code>grid</code> 布局中的父元素（即设有 <code>display:grid</code> 的元素），用来控制内部子元素的行为。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>grid-template-columns/grid-template-rows</code> 定义每一列的列宽/每一行的行宽</p><ul><li><code>none</code> 所有的列和其大小都将由 <code>grid-auto-columns</code> 属性隐式的指定。</li><li><code>fr</code> 表示比例关系,按比例分配剩余的可用空间</li><li><code>auto</code> 由浏览器自己决定长度</li><li><code>&lt;length&gt;</code> 非负值的长度大小</li><li><code>&lt;percentage&gt;</code> 非负值且相对于网格容器的百分比</li><li><code>repeat(&lt;number&gt;|auto-fill|auto-fit,value)</code> 重复设置。第一个参数是重复次数，第二个参数是重复的值。<code>auto-fill</code>指容纳尽可能多的子元素。</li><li><code>minmax(min, max)</code> 表示长度范围</li></ul></li><li><p><code>column-gap/row-gap/gap</code> 定义列间距/行间距/两者合并简写(<code>&lt;row-gap&gt; &lt;column-gap&gt;</code>,简写若省略第二个值，即表示跟第一个值一样)</p><ul><li><code>&lt;length&gt;</code> 非负值的长度大小</li><li><code>&lt;percentage&gt;</code> 非负值列之间的间隔大小</li></ul></li><li><p><code>grid-auto-flow</code> 定义子元素排列顺序是先行后列还是先列后行</p><ul><li><code>row(默认)</code> 先行后列</li><li><code>column</code> 先列后行</li><li><code>row dense</code> 先行后列,并且尽量填满空格</li><li><code>column dense</code> 先列后行,并且尽量填满空格</li></ul></li><li><p><code>justify-items/align-items/place-items</code> 定义子元素内容水平位置（左中右）/垂直位置（上中下）/两者合并简写（<code>&lt;align-items&gt; &lt;justify-items&gt;</code>,简写若省略第二个值，即表示跟第一个值一样）</p><ul><li><code>stretch(默认)</code> 拉伸，占满单元格的整个宽度</li><li><code>start</code> 对齐单元格的起始边缘</li><li><code>end</code> 对齐单元格的结束边缘</li><li><code>center</code> 单元格内部居中</li></ul></li><li><p><code>justify-content/align-content/place-content</code> 定义整个内容在容器里的水平位置（左中右）/垂直位置（上中下）/两者合并简写（<code>&lt;align-content&gt; &lt;justify-content&gt;</code>简写若省略第二个值，即表示跟第一个值一样）</p><ul><li><code>start</code> 对齐容器的起始边框</li><li><code>end</code> 对齐容器的结束边框</li><li><code>center</code> 容器内部居中</li><li><code>stretch</code> 项目大小没有指定时，拉伸占据整个网格容器</li><li><code>space-around</code> 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍</li><li><code>space-between</code> 项目与项目的间隔相等，项目与容器边框之间没有间隔</li><li><code>space-evenly</code> 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</li></ul></li><li><p><code>grid-auto-columns/grid-auto-rows</code> 定义浏览器自动创建的多余网格的列宽和行高，取值与<code>grid-template-columns/grid-template-rows</code>相同。</p></li><li><p><code>grid-template-areas</code> 定义区域，一个区域由单个或多个单元格组成。如果某些区域不需要利用，则使用”点”（<code>.</code>）表示。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-areas</span>:</span><br><span class="line">  'header header header'</span><br><span class="line">  'main main sidebar'</span><br><span class="line">  'footer footer footer';</span><br></pre></td></tr></table></figure><p>区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p></li></ul><h2 id="容器内子元素的属性"><a href="#容器内子元素的属性" class="headerlink" title="容器内子元素的属性"></a>容器内子元素的属性</h2><ul><li><p><code>grid-column-start/grid-column-end/grid-row-start/grid-row-end</code> 定义子元素的<code>左边框/右边框/上边框/下边框</code>的网格线。</p><ul><li><code>&lt;number&gt;</code> 指定第几根网格线</li><li><code>&lt;网格线名字&gt;</code> 直接指定网格线名字如（<code>区域名-start</code>）</li><li><code>span &lt;number&gt;</code> 指跨越多少个网格</li></ul></li><li><p><code>grid-column/grid-row</code> 分别是<code>grid-column-start,grid-column-end</code>,<code>grid-row-start,grid-row-end</code>的合并简写（<code>&lt;start&gt; / &lt;end&gt;</code>）,斜杠以及后面的部分可以省略，默认跨越一个网格。</p></li><li><p><code>grid-area</code> 指定子元素放在哪一个区域。也作为<code>grid-row-start、grid-column-start、grid-row-end、grid-column-end</code>的合并简写:<code>grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</code></p></li><li><p><code>justify-self/align-self/place-self</code>定义某个单独的子元素内容水平位置（左中右）/垂直位置（上中下）/两者合并简写（<code>&lt;align-items&gt; &lt;justify-items&gt;</code>,简写若省略第二个值，即表示跟第一个值一样）。</p><ul><li>用法取值跟<code>justify-items/align-items/place-items</code>一样，只是作用于单个子元素。</li></ul></li></ul><blockquote><p>参考：<a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">CSS Grid 网格布局教程</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）chrome provisional headers are shown 是什么意思</title>
      <link href="/352.html"/>
      <url>/352.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载来源 <a href="https://juejin.im/post/5c00980751882518805add83" target="_blank" rel="noopener">provisional headers are shown 知多少</a></p></blockquote><p>启发的一篇文章(<a href="https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger" target="_blank" rel="noopener">详情点击</a>)。</p><p>摘抄部分如下：</p><blockquote><p>The resource could be being blocked by an extension (AdBlock in my case).The message is there because the request to retrieve that resource was never made, so the headers being shown are not the real thing. As explained in the issue you referenced, the real headers are updated when the server responds, but there is no response if the request was blocked.</p></blockquote><p>资源可能被一些扩展程序拦截 。</p><p>另外还有一句：</p><blockquote><p>I believe it happens when the actual request is not sent. Usually happens when you are loading a cached resource.</p></blockquote><p>真正请求并未被发送，当使用缓存时经常发生。</p><p>之所以会出现这个信息是因为获取相关资源的请求并没有发出，所以 <code>headers</code> 被展示并不是真正的信息。</p><p>就像提到的那样，真正的 <code>header</code> 只有在服务端返回的时候会更新。当请求被拦截后，并没有返回。</p><p>基于这个情况开始猜测原因所在：</p><h3 id="猜测一、请求跨域被拦截"><a href="#猜测一、请求跨域被拦截" class="headerlink" title="猜测一、请求跨域被拦截"></a>猜测一、请求跨域被拦截</h3><p>虽然现在网站的静态资源都会存在专门的静态域名下面，和 <code>html</code> 域名可能不一致。</p><p>但是基本都是基于 <code>CORS</code> 来解决这个问题，所以不存在这个问题。</p><p>再有就是，我们这种情况首次请求的时候不会发生，如果有跨域，应该都被 <code>block</code>。</p><p>另外如果是被拦截，那么请求应该不会被响应的，我们这里显然得到了正确的响应。<br>这种被排除。</p><h3 id="猜测二、服务器未及时响应"><a href="#猜测二、服务器未及时响应" class="headerlink" title="猜测二、服务器未及时响应"></a>猜测二、服务器未及时响应</h3><p>这种猜测和一差不多，特定情况下才会出现，跟服务器关联不大。</p><h3 id="猜测三、被扩展程序拦截"><a href="#猜测三、被扩展程序拦截" class="headerlink" title="猜测三、被扩展程序拦截"></a>猜测三、被扩展程序拦截</h3><p>作为一个开发人员，大家的 <code>chrome</code> 上肯定装了不少的插件。这种原因还是有可能的。</p><p>我们可以通过 <code>chrome://net-export/</code> 来根据关键字查找相关请求，然后具体去看相关状态。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>结合上面的分析，我们可以缩小到缓存上面。冲着这个目标，我们继续去看下相关资料。</p><p>最后在一篇<a href="https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/" target="_blank" rel="noopener">日文资料</a>里找到了相关解释。</p><p>似乎只从缓存中获得的通信显示为“显示临时标题”（或“执行”）。</p><p>因为该文件是从缓存中获取的，并且未进行通信。</p><p>所以详细标头并不会显示。</p><h3 id="原因：未与服务端正确通信"><a href="#原因：未与服务端正确通信" class="headerlink" title="原因：未与服务端正确通信"></a>原因：未与服务端正确通信</h3><p>回过头来看，前面提到的那么多情况其实都是与服务器没有进行或者完成正确的通信，所以只展示临时信息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>provisional headers are shown</code> 出现的情况有这么几种：</p><ul><li>跨域，请求被浏览器拦截</li><li>请求被浏览器插件拦截</li><li>服务器出错或者超时，没有真正的返回</li><li>强缓存 <code>from disk cache</code> 或者 <code>from memory cache</code>，此时也不会显示</li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS遍历对象的方式</title>
      <link href="/351.html"/>
      <url>/351.html</url>
      
        <content type="html"><![CDATA[<h2 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for..in 循环"></a>for..in 循环</h2><ul><li>返回的是所有 <code>可枚举</code> 的属性，包括 <code>实例</code> 和 <code>原型</code> 上的属性。</li><li>如果只需要获取对象的实例属性，可以联合使用 <code>hasOwnProperty()</code> 进行过滤（过滤后等价 <code>Object.keys()</code>）。</li><li>不建议用来遍历 <code>数组</code> <a href="https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-a-bad-idea" target="_blank" rel="noopener">查阅</a></li></ul><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><ul><li>返回的<code>实例</code>里<code>可枚举</code>的<code>属性</code>的<code>数组</code>，不包括 <code>原型</code>。</li><li><code>Object.values()</code> 返回<code>实例</code>里<code>可枚举</code>的<code>属性值</code>的<code>数组</code>，不包括<code>原型</code>。</li><li><code>Object.entries()</code> 返回<code>实例</code>里<code>可枚举</code>的<code>键值对</code>的<code>数组</code>，不包括<code>原型</code>。</li></ul><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><ul><li>返回的<code>实例</code>里<code>所有</code>属性的数组，包括不可枚举属性，但不包括<code>Symbol</code>(注：<code>Symbol</code>可枚举)，但不会获取原型上的属性。</li><li><code>Object.getOwnPropertySymbols()</code> 返回自身的<code>Symol</code>属性。</li></ul><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h2><ul><li>返回的<code>实例</code>里<code>所有</code>属性的数组，包括不可枚举属性和<code>Symbol</code>。但不会获取原型上的属性。</li><li>基本等于 <code>Object.getOwnPropertySymbols</code>+<code>Object.getOwnPropertyNames</code></li></ul><h2 id="题外话：for-of"><a href="#题外话：for-of" class="headerlink" title="题外话：for..of"></a>题外话：for..of</h2><ul><li>适用范围：<code>iterable</code>（<code>Array, Map, Set, arguments</code> 等）</li><li>返回迭代器<code>属性值</code></li><li>扩展运算符<code>（...）</code>内部使用 <code>for...of</code> 循环</li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babel7.4配置总结</title>
      <link href="/350.html"/>
      <url>/350.html</url>
      
        <content type="html"><![CDATA[<h2 id="本文适用版本"><a href="#本文适用版本" class="headerlink" title="本文适用版本"></a>本文适用版本</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"@babel/core": "^7.4.4",</span><br><span class="line">"@babel/plugin-transform-runtime": "^7.4.4",</span><br><span class="line">"@babel/preset-env": "^7.4.5",</span><br><span class="line">"@babel/runtime": "^7.4.5",</span><br><span class="line">"@babel/runtime-corejs2": "^7.4.5",</span><br><span class="line">"@babel/runtime-corejs3": "^7.4.5",</span><br><span class="line">"babel-loader": "^8.0.6",</span><br><span class="line">"core-js": "^3.1.4",</span><br><span class="line">"regenerator-runtime": "^0.13.2",</span><br><span class="line">"webpack": "^4.17.1",</span><br><span class="line">"webpack-cli": "^3.1.0"</span><br></pre></td></tr></table></figure><h2 id="什么是-babel"><a href="#什么是-babel" class="headerlink" title="什么是 babel"></a>什么是 babel</h2><p><code>babel</code> 把 <code>JavaScript</code> 中 <code>es2015/2016/2017/2046</code> 的新语法转化为 <code>es5</code>，让低端运行环境(如浏览器和 <code>node</code>)能够认识并执行。</p><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p><code>babel</code> 总共分为三个阶段：解析，转换，生成。</p><p><code>babel</code> 本身不具有任何转化功能，它把转化的功能都分解到一个个 <code>plugin</code> 里面。因此当我们不配置任何插件时，经过 <code>babel</code> 的代码和输入是相同的。</p><h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><ol><li>语法插件(<code>@babel/parser</code>):使得 <code>babel</code> 能够解析更多的语法。</li><li>转译插件:源码转换并输出。</li></ol><h2 id="Preset"><a href="#Preset" class="headerlink" title="Preset"></a>Preset</h2><p><code>preset</code> 即一组官方推荐的预设插件的集合。目前推荐使用 <code>@babel/preset-env</code>。</p><h2 id="Plugin-和-Preset-执行顺序"><a href="#Plugin-和-Preset-执行顺序" class="headerlink" title="Plugin 和 Preset 执行顺序"></a>Plugin 和 Preset 执行顺序</h2><ul><li><code>Plugin</code> 会运行在 <code>Preset</code> 之前。</li><li><code>Plugin</code> 会从前到后顺序执行。</li><li><code>Preset</code> 的顺序则 刚好相反(从后向前)。</li></ul><h2 id="browserslist"><a href="#browserslist" class="headerlink" title="browserslist"></a>browserslist</h2><p><a href="https://github.com/browserslist/browserslist" target="_blank" rel="noopener">browserslist</a> 是在不同的前端工具之间共用目标浏览器和 <code>node</code> 版本的配置工具,中文<a href="https://juejin.im/post/5b8cff326fb9a019fd1474d6" target="_blank" rel="noopener">参阅</a>。浏览器特性支持可查询<a href="https://caniuse.com/" target="_blank" rel="noopener">caniuse</a>。</p><p>eg:package.json</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"browserslist": [</span><br><span class="line">  "last 1 version",</span><br><span class="line">  "&gt; 1%",</span><br><span class="line">  "maintained node versions",</span><br><span class="line">  <span class="string">"not dead"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="各-babel-包介绍"><a href="#各-babel-包介绍" class="headerlink" title="各 babel 包介绍"></a>各 babel 包介绍</h2><h3 id="babel-core"><a href="#babel-core" class="headerlink" title="@babel/core"></a>@babel/core</h3><p><code>babel</code> 的编译核心包，内置 <code>helpers</code> 插件模块，是语法转换的主要辅助工具，所谓 <code>babel</code> 版本多少就是指这个包的版本多少。</p><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p><code>webpack</code> 中使用 <code>babel</code> 加载文件。</p><h3 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="@babel/preset-env"></a>@babel/preset-env</h3><ol><li>文档<a href="https://babeljs.io/docs/en/next/babel-preset-env" target="_blank" rel="noopener">查阅</a></li><li><code>@babel/preset-env</code> 是一个智能预设，集合了一系列常用插件，会根据 <code>browserslist</code> 设置的目标浏览器，自动将代码中的新特性转换成目标浏览器支持的代码。</li><li>默认的 <code>@babel/preset-env</code> 是无法转换新的 <code>API</code>，比如 <code>Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise</code> 等全局对象，以及一些定义在全局对象上的方法(比如 <code>Object.assign</code>)都不会转码。需要根据需要添加 <code>core-js</code> 包和 <code>regenerator-runtime</code> 包支持。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i core-js egenerator-runtime</span><br></pre></td></tr></table></figure><p><code>babel.config.js</code>配置:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/env'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: &#123;</span><br><span class="line">          browsers: [<span class="string">'&gt; 1%'</span>, <span class="string">'last 2 versions'</span>, <span class="string">'not dead'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        modules: <span class="literal">false</span>, <span class="comment">//取值可以是 amd, umd, systemjs, commonjs 和 false,为false时可以用于webpack做tree shaking。</span></span><br><span class="line">        useBuiltIns: <span class="string">'usage'</span>, <span class="comment">// usage-按需引入 entry-入口引入（代码里需手动引入core-js） false-不引入</span></span><br><span class="line">        corejs: <span class="number">3</span> <span class="comment">// 2-corejs@2  3-corejs@3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="core-js"><a href="#core-js" class="headerlink" title="core-js"></a>core-js</h3><ol><li>文档<a href="https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md" target="_blank" rel="noopener">查阅</a></li><li><code>JavaScript</code> 标准库的 <code>polyfill</code>，目前提供 <code>core-js</code>，<code>core-js-pure</code>，<code>core-js-bundle</code> 3 个版本。</li><li>可直接项目里引用各种 <code>polyfill</code>。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polyfill all `core-js` features:</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js'</span>;</span><br><span class="line"><span class="comment">// polyfill only stable `core-js` features - ES and web standards:</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js/stable'</span>;</span><br></pre></td></tr></table></figure><h3 id="regenerator-runtime"><a href="#regenerator-runtime" class="headerlink" title="regenerator-runtime"></a>regenerator-runtime</h3><ol><li><code>regenerator-runtime</code> 模块来自 <code>facebook</code> 的 <code>regenerator</code> 模块。</li><li>生成器函数、<code>async</code>、<code>await</code> 函数经 <code>babel</code> 编译后，<code>regenerator-runtime</code> 模块用于提供功能实现。</li><li>源码<a href="https://schifred.iteye.com/blog/2369320" target="_blank" rel="noopener">查阅</a></li></ol><h3 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="@babel/polyfill"></a>@babel/polyfill</h3><p><code>babel</code> 7.4 版本已<a href="https://babeljs.io/docs/en/babel-polyfill" target="_blank" rel="noopener">废弃</a>，因为他仅仅依赖了 <code>core-js</code> 和 <code>regenerator-runtime</code>,安装这两个就可以了。</p><h3 id="babel-runtime-babel-runtime-corejs2-babel-runtime-corejs3"><a href="#babel-runtime-babel-runtime-corejs2-babel-runtime-corejs3" class="headerlink" title="@babel/runtime/@babel/runtime-corejs2/@babel/runtime-corejs3"></a>@babel/runtime/@babel/runtime-corejs2/@babel/runtime-corejs3</h3><ol><li><code>@babel/runtime</code> 提供 <code>helpers</code> 函数，并会去安装 <code>regenerator-runtime</code> 包，只做语法转换(<code>helpers</code> 和 <code>regenerator</code>)， 没有新 <code>api</code> 的实现。</li><li><code>@babel/runtime-corejs2</code> 包含 <code>@babel/runtime</code> 的全部并额外安装 <code>core-js@2</code></li><li><code>@babel/runtime-corejs3</code> 包含 <code>@babel/runtime</code> 的全部并额外安装 <code>core-js-pure@3</code></li><li>相比之下 <code>@babel/runtime-corejs3</code> 支持更多，包括实例，api 等。</li><li>三者均需要与 <code>@babel/plugin-transform-runtime</code> 搭配使用（但 <code>@babel/plugin-transform-runtime</code> 不一定要和他们用）。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [<span class="string">'@babel/env'</span>],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/plugin-transform-runtime'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        corejs: <span class="number">3</span> <span class="comment">//为false就安装 npm i @babel/runtime,为2就安装@babel/runtime-corejs2，为3就安装@babel/runtime-corejs3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="@babel/plugin-transform-runtime"></a>@babel/plugin-transform-runtime</h3><ol><li>对 <code>Babel</code> 编译过程中产生的 <code>helper</code> 方法进行重新利用(聚合)，以达到减少打包体积的目的.</li><li>避免全局补丁污染，对打包过的 <code>bundler</code> 提供”沙箱”式的补丁。</li><li>文档<a href="https://babeljs.io/docs/en/next/babel-plugin-transform-runtime" target="_blank" rel="noopener">查阅</a></li></ol><h2 id="两种最优方案"><a href="#两种最优方案" class="headerlink" title="两种最优方案"></a>两种最优方案</h2><h3 id="使用-corejs-useBuiltIns"><a href="#使用-corejs-useBuiltIns" class="headerlink" title="使用 corejs+useBuiltIns"></a>使用 corejs+useBuiltIns</h3><p><code>npm</code> 安装：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i @babel/core @babel/preset-env @babel/plugin-transform-runtime -D</span><br><span class="line">npm i core-js regenerator-runtime</span><br></pre></td></tr></table></figure><p><code>babel.config.js</code> 配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/env'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: &#123;</span><br><span class="line">          browsers: [<span class="string">'&gt; 1%'</span>, <span class="string">'last 2 versions'</span>, <span class="string">'not dead'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        useBuiltIns: <span class="string">'usage'</span>,</span><br><span class="line">        corejs: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  plugins: [[<span class="string">'@babel/plugin-transform-runtime'</span>]]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>该方案支持所有，包括转译语法，<code>API</code> 及实例方法的 <code>polyfill</code>。</li><li>该方案会污染全局。</li></ol><h3 id="使用-runtime-corejs3"><a href="#使用-runtime-corejs3" class="headerlink" title="使用 runtime-corejs3"></a>使用 runtime-corejs3</h3><p><code>npm</code> 安装：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i @babel/core @babel/preset-env @babel/plugin-transform-runtime -D</span><br><span class="line">npm i @babel/runtime-corejs3</span><br></pre></td></tr></table></figure><p><code>babel.config.js</code> 配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/env'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: &#123;</span><br><span class="line">          browsers: [<span class="string">'&gt; 1%'</span>, <span class="string">'last 2 versions'</span>, <span class="string">'not dead'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/plugin-transform-runtime'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        corejs: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>该方案支持所有，包括转译语法，<code>API</code> 及实例方法的 <code>polyfill</code>。</li><li>该方案不会污染全局。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>Babel</code> 版本号&lt; 7.4.0<ul><li>开发类库：<code>@babel/runtime</code></li><li>内部项目：@babel/polyfill</li></ul></li><li><code>Babel</code> 版本号&gt;= 7.4.0<ul><li><code>@babel/runtime-corejs3</code></li></ul></li><li>这文档都是坑爹的,网上的各种经验也都是之前的某个版本的总结，<code>babel</code> 包变化很快，最好的还是去看源码，和多测试不同包的效果，自己摸索体验。</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>var let const fn变量提升</title>
      <link href="/349.html"/>
      <url>/349.html</url>
      
        <content type="html"><![CDATA[<p><code>JS</code> 变量的声明分为 <code>创建create</code>、<code>初始化initialize</code> 和 <code>赋值assign</code>。</p><h2 id="var-声明的过程"><a href="#var-声明的过程" class="headerlink" title="var 声明的过程"></a>var 声明的过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><ol><li>进入 <code>fn</code>，为 <code>fn</code> 创建一个环境。</li><li>找到 <code>fn</code> 中所有用 <code>var</code> 声明的变量，在这个环境中「创建」这些变量（即 <code>x</code> 和 <code>y</code>）。</li><li>将这些变量「初始化」为 <code>undefined</code>。</li><li>开始执行代码</li><li><code>x = 1</code> 将 <code>x</code> 变量「赋值」为 <code>1</code></li><li><code>y = 2</code> 将 <code>y</code> 变量「赋值」为 <code>2</code></li></ol><h2 id="function-声明过程"><a href="#function-声明过程" class="headerlink" title="function 声明过程"></a>function 声明过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">fn2()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>找到所有用 <code>function</code> 声明的变量，在环境中「创建」这些变量。</li><li>将这些变量「初始化」并「赋值」为 <code>function(){ console.log(2) }</code>。</li><li>开始执行代码 <code>fn2()</code></li></ol><h2 id="let-声明过程"><a href="#let-声明过程" class="headerlink" title="let 声明过程"></a>let 声明过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>找到所有用 <code>let</code> 声明的变量，在环境中「创建」这些变量</li><li>开始执行代码（注意现在还没有初始化）</li><li>执行 <code>x = 1</code>，将 <code>x</code> 「初始化」为 1（这并不是一次赋值，如果代码是 <code>let x</code>，就将 <code>x</code> 初始化 <code>4</code>.为 <code>undefined</code>）</li><li>执行 <code>x = 2</code>，对 <code>x</code> 进行「赋值」</li></ol><h3 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">'global'</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>console.log(x)</code> 中的 <code>x</code> 指的是下面的 <code>x</code>，而不是全局的 <code>x</code></li><li>执行 <code>log</code> 时 <code>x</code> 还没「初始化」，所以不能使用（也就是所谓的暂时死区）</li></ol><h3 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> liList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>); <span class="comment">// 共5个li</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">  liList[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>for( let i = 0; i&lt; 5; i++)</code> 这句话的圆括号之间，有一个隐藏的作用域</li><li><code>for( let i = 0; i&lt; 5; i++) { 循环体 }</code> 在每次执行循环体之前，<code>JS</code> 引擎会把 <code>i</code> 在循环体的上下文中重新声明及初始化一次（即 <code>let/const</code> 在与 <code>for</code> 一起用时，会有一个 <code>perIterationBindings</code> 的概念）。</li></ol><p>可理解为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> liList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>); <span class="comment">// 共5个li</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = 隐藏作用域中的i;</span><br><span class="line">  liList[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例-3"><a href="#例-3" class="headerlink" title="例 3"></a>例 3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = x; <span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br><span class="line"><span class="keyword">let</span> x; <span class="comment">//Identifier 'x' has already been declared</span></span><br></pre></td></tr></table></figure><ol><li>如果 <code>let x</code> 的初始化过程失败了,<code>x</code> 变量就将永远处于 <code>created</code> 状态。</li><li>无法再次对 <code>x</code> 进行初始化, <code>x</code> 永远处在暂时性死区.</li></ol><blockquote><p>当程序的控制流程在新的作用域（module function 或 block 作用域）进行实例化时，在此作用域中用 let/const 声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定，所以是不能被访问的，如果访问就会抛出错误。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时性死区。</p></blockquote><h2 id="const-声明过程"><a href="#const-声明过程" class="headerlink" title="const 声明过程"></a>const 声明过程</h2><p><code>const</code> 过程跟 <code>let</code> 一样，但 <code>const</code> 只有「创建」和「初始化」，没有「赋值」过程。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>let、const</code> 的「创建」过程被提升了，但是初始化没有提升。</li><li><code>var</code> 的「创建」和「初始化」都被提升了。</li><li><code>function</code> 的「创建」「初始化」和「赋值」都被提升了。</li></ol><p><img src="http://cdn.flqin.com/p349-1.jpg" alt="git命令总结"></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/28140450" target="_blank" rel="noopener">我用了两个月的时间才理解 let</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>amd,umd,commonJs,ES6模块的相关总结</title>
      <link href="/348.html"/>
      <url>/348.html</url>
      
        <content type="html"><![CDATA[<h2 id="AMD-CMD-模块（requireJS-seaJs）（即将退出历史舞台）"><a href="#AMD-CMD-模块（requireJS-seaJs）（即将退出历史舞台）" class="headerlink" title="AMD/CMD 模块（requireJS/seaJs）（即将退出历史舞台）"></a>AMD/CMD 模块（requireJS/seaJs）（即将退出历史舞台）</h2><ul><li><code>AMD</code>（<code>Asynchronous Module Definition</code> 异步模块定义）和 <code>CMD</code>（<code>Common Module Definition</code> 通用模块定义）是基于浏览器使用并且是<code>异步执行</code></li><li><code>AMD</code> 推崇依赖前置，在定义模块的时候就要声明其依赖的模块</li><li><code>CMD</code> 推崇就近依赖，只有在用到某个模块的时候再去 <code>require</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMD</span></span><br><span class="line"><span class="comment">// 定义模块 myModule.js</span></span><br><span class="line">define([<span class="string">'dependency'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Byron'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    printName: printName</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'myModule'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>) </span>&#123;</span><br><span class="line">  my.printName();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CMD</span></span><br><span class="line"><span class="comment">// 定义模块  myModule.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>);</span><br><span class="line">  $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>AMD</code> 在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入 <code>require</code> 的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。</li><li><code>CMD</code> 加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到 <code>require</code> 语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。</li></ul><h2 id="commonJS-模块（nodejs）"><a href="#commonJS-模块（nodejs）" class="headerlink" title="commonJS 模块（nodejs）"></a>commonJS 模块（nodejs）</h2><ul><li>使用 <code>require</code> 来引入其他模块的代码，使用 <code>module.exports</code> 来引出。</li><li><code>exports</code> 与 <code>module.exports</code> 的初始指针相同，即 <code>module.exports === exports</code>,如果 <code>exports</code> 一旦指向了其他对象，即不能用于导出。</li><li>运行时加载，输出的是一个值的拷贝。</li></ul><h3 id="值的拷贝"><a href="#值的拷贝" class="headerlink" title="值的拷贝"></a>值的拷贝</h3><p><code>require</code> 引入的是值的拷贝(基本类型拷贝值，引用类型拷贝地址)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.js</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line">exports.age = age;</span><br><span class="line">exports.getAge = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  age = age + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">//1 原本的会改变</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./4'</span>);</span><br><span class="line"><span class="keyword">var</span> age = a.age;</span><br><span class="line"><span class="keyword">var</span> getAge = a.getAge;</span><br><span class="line">getAge();</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">//0 不会改变age，一旦生成缓存后就会从缓存里读这个值</span></span><br></pre></td></tr></table></figure><h3 id="commonjs-循环加载"><a href="#commonjs-循环加载" class="headerlink" title="commonjs 循环加载"></a>commonjs 循环加载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4开始执行'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  exports.name = <span class="string">'qxq1'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">exports.name = <span class="string">'qxq'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4执行一半'</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./5'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in 4, b.done ='</span>, b.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4执行结束'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5开始执行'</span>);</span><br><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./4'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in 5, a.name ='</span>, a.name);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in 5, a.done ='</span>, a.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5执行结束'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">666</span>, a);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">4</span>开始执行</span><br><span class="line"><span class="number">4</span>执行一半</span><br><span class="line"><span class="number">5</span>开始执行</span><br><span class="line"><span class="keyword">in</span> <span class="number">5</span>, a.name = qxq</span><br><span class="line"><span class="keyword">in</span> <span class="number">5</span>, a.done = <span class="literal">undefined</span></span><br><span class="line"><span class="number">5</span>执行结束</span><br><span class="line"><span class="keyword">in</span> <span class="number">4</span>, b.done = <span class="literal">true</span></span><br><span class="line"><span class="number">4</span>执行结束</span><br><span class="line"><span class="number">666</span> <span class="built_in">Object</span> &#123;<span class="attr">name</span>: <span class="string">"qxq1"</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>执行到 <code>require</code> 那行才会去加载该脚本</li><li><code>require</code> 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象，本质就是一个一次性赋值操作。</li><li>再次执行 <code>require</code> 命令，也不会再次执行该模块，而是到缓存之中取值。</li><li>一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</li></ul><h2 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h2><ul><li><code>import/export</code> 命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，则会报错。</li><li><code>ES6</code> 模块输入是 <code>export</code> 的动态 <code>只读视图（live read-only views）</code></li></ul><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>使用 <code>import</code> 命令加载其他模块，<code>import</code> 命令输入的变量都是 <code>只读</code> 的，因为它的本质是 <code>输入接口</code>。</p><ol><li><p>语法<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认导出的导入</span></span><br><span class="line"><span class="keyword">import</span> defaultExport <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整体导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入单个接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重命名接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入多个接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo , bar &#125; <span class="keyword">from</span> <span class="string">"module-name/path/to/specific/un-exported/file"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 <span class="keyword">as</span> alias2 , [...] &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;个接口</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时导入默认和多个接口</span></span><br><span class="line"><span class="keyword">import</span> defaultExport, &#123; <span class="keyword">export</span> [ , [...] ] &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> defaultExport, * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只运行模块代码不导入接口</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"module-name"</span>;</span><br></pre></td></tr></table></figure></li><li><p>如果多次重复执行同一句 <code>import</code> 语句，那么只会执行一次.</p></li><li><p><code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p></li></ol><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><ol><li><p>使用 <code>export</code> 命令规定对外的 <code>接口</code>，必须与模块内部的变量建立一一对应关系。<code>export</code> 语句输出的接口，与其对应的值是 <code>动态绑定</code> 关系，即通过该接口，可以取到模块内部实时的值。</p></li><li><p>语法<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export" target="_blank" rel="noopener">查阅</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出单个特性</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1, name2, …, nameN; <span class="comment">// also var, const</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1 = …, name2 = …, …, nameN; <span class="comment">// also var, const</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">FunctionName</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导处列表</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1, name2, …, nameN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; variable1 <span class="keyword">as</span> name1, variable2 <span class="keyword">as</span> name2, …, nameN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> expression;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">…</span>) </span>&#123; … &#125; <span class="comment">// also class, function*</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">name1</span>(<span class="params">…</span>) </span>&#123; … &#125; <span class="comment">// also class, function*</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1 <span class="keyword">as</span> <span class="keyword">default</span>, … &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> …;</span><br><span class="line"><span class="keyword">export</span> &#123; name1, name2, …, nameN &#125; <span class="keyword">from</span> …;</span><br><span class="line"><span class="keyword">export</span> &#123; import1 <span class="keyword">as</span> name1, import2 <span class="keyword">as</span> name2, …, nameN &#125; <span class="keyword">from</span> …;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> …;</span><br></pre></td></tr></table></figure></li><li><p>默认导出 <code>export default</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> k;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> k = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>因为 <code>export default</code> 命令的本质是将后面的值，赋给 <code>default</code> 变量，所以可以直接将一个值写在 <code>export default</code> 之后。</p></li></ol><h3 id="值的引用"><a href="#值的引用" class="headerlink" title="值的引用"></a>值的引用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; age, getAge &#125; <span class="keyword">from</span> <span class="string">'./5.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">//原本为0</span></span><br><span class="line">getAge();</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">//因为是值的引用，所以要变，为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  age = age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">//要变，为1</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><h3 id="ES6-循环加载"><a href="#ES6-循环加载" class="headerlink" title="ES6 循环加载"></a>ES6 循环加载</h3><ul><li><code>import</code> 命令会被 JavaScript 引擎静态分析，具有提升效果，会提升到整个模块的头部，首先执行。</li><li><code>export</code> 命令会有变量声明提前的效果。</li><li><code>ES6</code> 模块遇到模块加载命令 <code>import</code> 时，不会去执行模块，而是只生成一个 <code>引用</code>。等到真的需要用到时，再到模块里面去取值。</li><li><code>ES6</code> 根本不会关心是否发生了”循环加载”，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</li><li>通常存在强耦合，应避免出现。</li></ul><h4 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar2'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar3'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> a <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// 注意函数表达式和函数声明的区别（提升）</span></span><br></pre></td></tr></table></figure><h4 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a starting'</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in b, foo:'</span>, foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a done'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b starting'</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in a, bar:'</span>, bar);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'in a, setTimeout bar:'</span>, bar);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b done'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel-node a.js</span></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// b starting</span></span><br><span class="line"><span class="comment">// in a, bar: undefined</span></span><br><span class="line"><span class="comment">// b done</span></span><br><span class="line"><span class="comment">// a starting</span></span><br><span class="line"><span class="comment">// in b, foo: foo</span></span><br><span class="line"><span class="comment">// a done</span></span><br><span class="line"><span class="comment">// in a, setTimeout bar: 2</span></span><br><span class="line"><span class="comment">// 注意该例不能用const或let，否则报错:Cannot access 'bar' before initialization 暂时性死区</span></span><br><span class="line"><span class="comment">// export变量声明提升</span></span><br></pre></td></tr></table></figure><h3 id="高版本浏览器可以直接使用-es6-module"><a href="#高版本浏览器可以直接使用-es6-module" class="headerlink" title="高版本浏览器可以直接使用 es6 module"></a>高版本浏览器可以直接使用 es6 module</h3><p><a href="https://caniuse.com/#search=module" target="_blank" rel="noopener">点此查询版本支持</a></p><ol><li><p><code>script</code> 标签加 <code>type=&#39;module&#39;</code> 属性启动支持</p></li><li><p>支持相对路径和绝对路径</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; getName &#125; <span class="keyword">from</span> <span class="string">'utils.js'</span>; <span class="comment">// error</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; getName &#125; <span class="keyword">from</span> <span class="string">'./utils.js'</span>; <span class="comment">// right</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>nomodule</code> 向下兼容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"module.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">"fallback.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因老版本不识别 <code>type=&quot;module&quot;</code> 即不会执行 <code>module.js</code>，同时不识别 <code>nomodule</code> 即忽略该属性 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script" target="_blank" rel="noopener">参考</a></p></li><li><p>加载方式默认使用 <code>defer</code></p></li><li><p>只执行一次</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.js 只会被加载执行一次--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> <span class="string">'./1.js'</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  普通JS 也只会被加载一次，但是会被执行多次--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>type=&quot;module&quot;</code> 默认不支持跨域,需要服务器设置 <code>cors</code></p></li><li><p>服务器必须要设置有效的 <code>MIME types</code>：<code>text/javascript</code></p></li></ol><h3 id="动态异步加载-import"><a href="#动态异步加载-import" class="headerlink" title="动态异步加载 import()"></a>动态异步加载 import()</h3><ul><li><code>import()</code>返回一个<code>promise对象</code>,可以用在任何地方，运行时加载</li><li>主要用在<code>按需加载</code>及<code>条件加载</code></li><li>使用 babel 编译时，需要添加<code>syntax-dynamic-import</code>插件</li></ul><h2 id="UMD-模块"><a href="#UMD-模块" class="headerlink" title="UMD 模块"></a>UMD 模块</h2><p>实际上就是 <code>amd/cmd + commonjs + 全局变量</code> 这三种风格的结合，对当前运行环境的判断，如果是 <code>Node</code> 环境 就是使用 <code>CommonJs</code> 规范， 如果不是就判断是否为 <code>AMD</code> 环境， 最后导出全局变量。（<code>AMD</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> ? (<span class="built_in">module</span>.exports = factory()) : <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ? define(factory) : (global.libName = factory());</span><br><span class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog从wordpress迁移至hexo+next，并通过travis自动部署到ftp及github</title>
      <link href="/346.html"/>
      <url>/346.html</url>
      
        <content type="html"><![CDATA[<p>因 wordpress 后台臃肿反应慢，外加上本人作为前端代码狗，基于 nodejs 的 hexo 对我非常友好。所以花了 2 天时间终于把 blog 从 wordpress 迁移至 hexo， 通过直接在 md 里面来写博客，简直爽到飞起。特此记录一下我在迁移搭建中做了哪些操作，以便后面遗忘。</p><hr><p><strong>博客效果:</strong></p><ul><li><a href="https://blog.flqin.com">blog</a></li><li><a href="https://zhaoky.github.io" target="_blank" rel="noopener">github.io</a></li></ul><hr><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>安装 node.js</li><li>安装 git</li><li>全局安装 Hexo-cli（生成 hexo 项目用）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="生成静态网站"><a href="#生成静态网站" class="headerlink" title="生成静态网站"></a>生成静态网站</h3><p>打开目标文件夹，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexo-demo</span><br><span class="line"><span class="built_in">cd</span> hexo-demo</span><br><span class="line">yarn //也可以用npm i，个人喜好</span><br></pre></td></tr></table></figure><p>通过命令 <code>hexo s</code>可本地预览</p><p>通过命令 <code>hexo g</code>可本地生成建站资源 public 包，用来部署</p><p>相关文件夹的作用及配置<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">点此查阅</a>,命令<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">点此查阅</a></p><h3 id="从-wordpress-迁移"><a href="#从-wordpress-迁移" class="headerlink" title="从 wordpress 迁移"></a>从 wordpress 迁移</h3><p>hexo-demo 里安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-migrator-wordpress -D</span><br></pre></td></tr></table></figure><p>同时在<code>WordPress仪表盘</code>中导出数据(“Tools” → “Export” → “WordPress”)</p><p>安装好后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo migrate wordpress &lt;source&gt; #source为 WordPress 导出的文件路径或网址</span><br></pre></td></tr></table></figure><p>转换后再自己检查修改下就可以了，因为这个转换插件我只需要用一次，然后我就把<code>hexo-migrator-wordpress</code>删掉了。</p><h3 id="hexo-优化"><a href="#hexo-优化" class="headerlink" title="hexo 优化"></a>hexo 优化</h3><p>项目有两个_config.yml 文件，分别是<code>项目_config.yml</code>和<code>主题_config.yml</code>。</p><h4 id="项目增强"><a href="#项目增强" class="headerlink" title="项目增强"></a>项目增强</h4><ul><li>添加<a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">页面 2d 萌宠</a>插件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-helper-live2d -D</span><br><span class="line">yarn add live2d-widget-model-koharu -D</span><br></pre></td></tr></table></figure><p><code>项目config</code>添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  scriptFrom:</span> <span class="string">jsdelivr</span> <span class="comment"># 默认</span></span><br><span class="line"><span class="attr">  pluginRootPath:</span> <span class="string">live2dw/</span> <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line"><span class="attr">  pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line"><span class="attr">  pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line"><span class="attr">  tagMode:</span> <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line"><span class="attr">  debug:</span> <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    use:</span> <span class="string">live2d-widget-model-koharu</span> <span class="comment"># npm-module package name</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line"><span class="attr">    vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    superSample:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    width:</span> <span class="number">125</span></span><br><span class="line"><span class="attr">    height:</span> <span class="number">150</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">left</span></span><br><span class="line"><span class="attr">    hOffset:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">    vOffset:</span> <span class="bullet">-5</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">0.05</span></span><br><span class="line"><span class="attr">  react:</span></span><br><span class="line"><span class="attr">    opacityDefault:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    opacityOnHover:</span> <span class="number">0.2</span></span><br></pre></td></tr></table></figure><ul><li>添加<a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">搜索功能</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-generator-search -D</span><br></pre></td></tr></table></figure><p><code>项目config</code> 设置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p><code>主题config</code> 设置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/theme-next/hexo-filter-**optimize**" target="_blank" rel="noopener">页面加载优化</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-filter-optimize -D</span><br></pre></td></tr></table></figure><p>配置见作者说明。</p><ul><li>注意插件与 next font-awesome 本地库有冲突，需要把<code>主题config</code>里的<code>fontawesome</code>替换为线上 CDN。<a href="https://github.com/theme-next/hexo-filter-optimize/issues/2" target="_blank" rel="noopener">详见</a></li><li>在本地 sever 的时候很慢，建议只在发布部署的时候使用。（用<code>sed -i</code>在 travis 构建里开启）</li></ul><h4 id="主题相关"><a href="#主题相关" class="headerlink" title="主题相关"></a>主题相关</h4><p>采用了 star 最多的 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">hexo</a>，官方文档<a href="https://theme-next.org/docs/" target="_blank" rel="noopener">查阅</a>。设置方式：修改<code>项目config</code>里的 <code>theme</code> 为 <code>next</code>即可。</p><h5 id="主题优化（以下配置均在主题config）"><a href="#主题优化（以下配置均在主题config）" class="headerlink" title="主题优化（以下配置均在主题config）"></a>主题优化（以下配置均在<code>主题config</code>）</h5><ul><li>生成缓存： <code>cache.enable:true</code></li><li>修改网站 favicon： <code>favicon</code></li><li>页脚修改： <code>footer</code></li><li>右上角 github banner 生成： <code>github_banner</code></li><li>设置导航： <code>menu</code></li><li>选择主题 Pisces：<code>scheme: Pisces</code></li><li>设置概览信息：<code>social social_icons</code></li><li>设置头像相关：<code>avatar</code></li><li>代码风格：<code>highlight_theme</code></li><li>设置百度统计：<code>baidu_analytics</code></li><li>设置显示加载更多：<code>scroll_to_more</code></li><li>保存滚动位置：<code>save_scroll</code></li><li>添加打赏：<code>reward_settings reward</code></li><li>拷贝<a href="https://github.com/theme-next/theme-next-reading-progress" target="_blank" rel="noopener">滑动进度条</a>并设置：<code>reading_progress</code></li><li>拷贝<a href="https://github.com/theme-next/theme-next-pace" target="_blank" rel="noopener">加载进度条</a>并设置：<code>pace pace_theme</code></li><li>拷贝<a href="https://github.com/theme-next/theme-next-canvas-nest" target="_blank" rel="noopener">页面 3D 背景</a>并设置<code>canvas_nest</code></li><li>拷贝<a href="https://github.com/theme-next/theme-next-fancybox3" target="_blank" rel="noopener">fancyBox</a>并设置<code>fancybox</code></li><li>拷贝<a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">字数统计插件</a>并设置（需同时设置两个<code>_onfig</code>,并在项目 yarn add 该插件）：<code>symbols_count_time</code></li></ul><h4 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h4><ul><li><p>百度站长平台：<a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">https://ziyuan.baidu.com/</a></p></li><li><p>谷歌站长平台：<a href="https://search.google.com/search-console" target="_blank" rel="noopener">https://search.google.com/search-console/</a></p></li><li><p>通过在搜索引擎输入:<code>site: blog.flqin.com</code>测试是否被收录</p></li><li><p>未被收录的话，在站长平台添加。</p></li><li><p>提交链接：包括<code>主动推送</code>，<code>自动推送</code>，<code>sitemap</code>,效率:<code>主动推送&gt;自动推送&gt;sitemap</code>,可同时配合使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-generator-sitemap hexo-generator-baidu-sitemap hexo-baidu-url-submit -D</span><br></pre></td></tr></table></figure><p>并设置<code>项目config</code>:<code>url</code>,<code>permalink</code>,<code>sitemap</code>,<code>baidusitemap</code>,<code>baidu_url_submit</code>,<code>deploy</code></p></li></ul><h3 id="travis-ci-持续部署到-ftp-和-gitlab-io"><a href="#travis-ci-持续部署到-ftp-和-gitlab-io" class="headerlink" title="travis-ci 持续部署到 ftp 和 gitlab.io"></a>travis-ci 持续部署到 ftp 和 gitlab.io</h3><p>添加部署相关插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-deployer-git -D</span><br><span class="line">yarn add hexo-deployer-ftpsync -D</span><br></pre></td></tr></table></figure><p>部署之前，先生成要部署的静态文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>部署的<code>项目config</code>配置(详细配置<a href="https://hexo.io/zh-cn/docs/deployment" target="_blank" rel="noopener">查阅</a>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:zhaoky/zhaoky.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">ftpsync</span></span><br><span class="line"><span class="attr">  host:</span> <span class="string">ftpHost</span></span><br><span class="line"><span class="attr">  user:</span> <span class="string">ftpUser</span></span><br><span class="line"><span class="attr">  pass:</span> <span class="string">ftpPass</span></span><br><span class="line"><span class="attr">  remote:</span> <span class="string">ftpRemote</span></span><br></pre></td></tr></table></figure><p>部署命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h4 id="ftp-部署相关设置"><a href="#ftp-部署相关设置" class="headerlink" title="ftp 部署相关设置"></a>ftp 部署相关设置</h4><p>为了 ftp 的账号密码的安全性，所以在 config 中的配置用 travis 加密变量表示（如<code>ftpsync，ftpHost，ftpPass，ftpRemote</code>），然后在 travis 里的该项目配置该加密变量。这样在 travis 运行构建的时候就可以应用替换回真实的账号密码。</p><blockquote><p>但我实际操作的时候一直报<code>Error: read ETIMEDOUT at TCP.onStreamRead (internal/stream_base_commons.js:111:27)</code>的错误，查了下源码可能是<code>jsftp</code>包报的错，已经向<a href="https://github.com/hexojs/hexo/issues/3585" target="_blank" rel="noopener">hexo</a>和<a href="https://github.com/hexojs/hexo-deployer-ftpsync/issues/33" target="_blank" rel="noopener">hexo-deployer-ftpsync</a>提 issue,如果有解决方案请告知我，多谢指教！</p></blockquote><h4 id="git-部署相关设置"><a href="#git-部署相关设置" class="headerlink" title="git 部署相关设置"></a>git 部署相关设置</h4><p>github 部署采用 ssh 的通讯加密方式，首先在 github 上建一个命名为 zhaoky.github.io(zhaoky 替换成 github 名)的仓库，然后本地本地生成一对公私钥（运行<code>ssh-keygen -t rsa -C youremail@example.com</code>生成）,将.pub 公钥配置在 zhaoky.github.io 仓库的 <code>deploy key</code>，把私钥和 ssh-config 发到 travis 的构建服务器里。私钥为了保证安全性，本地通过 travis 命令加密，然后在 travis 构建时再解密，这样就能自动发布了。</p><h4 id="本地-travis-命令如何加密"><a href="#本地-travis-命令如何加密" class="headerlink" title="本地 travis 命令如何加密"></a>本地 travis 命令如何加密</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gem install travis</span><br><span class="line">travis login --com #如果仍在使用travis-ci.org，则需要使用--org</span><br><span class="line">travis encrypt-file id_rsa --add --pro #使用--add自动添加到travis.yml,--pro将生成的加密环境变量添加到travis项目后台管理中</span><br></pre></td></tr></table></figure><p>这样就生成了一个加密后的.enc 的文件了</p><h4 id="ssh-config-怎么配置"><a href="#ssh-config-怎么配置" class="headerlink" title="ssh/config 怎么配置"></a>ssh/config 怎么配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    StrictHostKeyChecking no</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    IdentitiesOnly yes</span><br></pre></td></tr></table></figure><p>我的做法是在项目里建了一个.travis 的文件夹，将加密后的.enc 文件和 ssh-config 放进去，在 travis 构建的时候发到构建的机器上。</p><h4 id="我的-travis-yml-的配置"><a href="#我的-travis-yml-的配置" class="headerlink" title="我的.travis.yml 的配置"></a>我的.travis.yml 的配置</h4><p>直接看配置就明白了。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'10'</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_43f9974e8d06_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_43f9974e8d06_iv</span></span><br><span class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">.travis/id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cp</span> <span class="string">.travis/ssh_config</span> <span class="string">~/.ssh/config</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">user.name</span> <span class="string">'korey'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">user.email</span> <span class="string">'keyu.zhao@foxmail.com'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-cli</span> <span class="bullet">-g</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">yarn</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">bash</span> <span class="string">sed.sh</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">yarn</span> <span class="string">run</span> <span class="string">deploy</span> <span class="comment">#hexo clean &amp;&amp; hexo g -d</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git命令总结</title>
      <link href="/347.html"/>
      <url>/347.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h2><p>当前用户的 <code>Git</code> 配置文件放在用户主目录下的一个隐藏文件 <code>.gitconfig</code> 中，里面可配置 <code>git</code> 相关的全局信息。</p><h3 id="安装好后，最后一步设置"><a href="#安装好后，最后一步设置" class="headerlink" title="安装好后，最后一步设置"></a>安装好后，最后一步设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"korey"</span></span><br><span class="line">git config --global user.email <span class="string">"xxx@163.com"</span></span><br><span class="line">git config --global alias.st status <span class="comment">#设置别名</span></span><br></pre></td></tr></table></figure><h3 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.ignorecase <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="列举所有配置"><a href="#列举所有配置" class="headerlink" title="列举所有配置"></a>列举所有配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><h3 id="查看系统-config"><a href="#查看系统-config" class="headerlink" title="查看系统 config"></a>查看系统 config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure><h3 id="查看当前用户（global）配置"><a href="#查看当前用户（global）配置" class="headerlink" title="查看当前用户（global）配置"></a>查看当前用户（global）配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><h3 id="查看当前仓库配置信息"><a href="#查看当前仓库配置信息" class="headerlink" title="查看当前仓库配置信息"></a>查看当前仓库配置信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span>  --list</span><br></pre></td></tr></table></figure><h3 id="删除某个配置"><a href="#删除某个配置" class="headerlink" title="删除某个配置"></a>删除某个配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> user.emaill</span><br></pre></td></tr></table></figure><p>全局的通过 <code>vim ~/.gitconfig</code> 来查看 局部的通过当前路径下的 <code>.git/config</code> 文件来查看</p><h2 id="创建版本库（仓库）"><a href="#创建版本库（仓库）" class="headerlink" title="创建版本库（仓库）"></a>创建版本库（仓库）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir aaa</span><br><span class="line"><span class="built_in">cd</span> aaa</span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><h2 id="三态转换"><a href="#三态转换" class="headerlink" title="三态转换"></a>三态转换</h2><h3 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><ul><li><code>工作区 Working tree</code>：即文件目录内容</li><li><code>暂存区 index</code>：目录 <code>.git</code> 内的 <code>stage/index</code> (已 <code>add</code> 未 <code>commit</code>)</li><li><code>版本库 repo</code>：文件 <code>.git</code> 新修改的文件 (工作区) <code>（untracked）→ 通过 add→ 暂存区 → 通过 commit→ 版本库</code></li></ul><h3 id="工作区-gt-暂存区"><a href="#工作区-gt-暂存区" class="headerlink" title="工作区-&gt;暂存区"></a>工作区-&gt;暂存区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><h3 id="暂存区-gt-版本库"><a href="#暂存区-gt-版本库" class="headerlink" title="暂存区-&gt;版本库"></a>暂存区-&gt;版本库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git commit &lt;file&gt;</span><br><span class="line">git commit .</span><br><span class="line">git commit -a</span><br><span class="line">git commit -amend  <span class="comment">#修改最后一次提交</span></span><br><span class="line">git commit -m “xxx”</span><br></pre></td></tr></table></figure><h3 id="撤销工作区的修改"><a href="#撤销工作区的修改" class="headerlink" title="撤销工作区的修改"></a>撤销工作区的修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout --  &lt;file&gt;</span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure><p><code>checkout</code> 还可以检出提交，查看某个版本的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 5aab391 <span class="comment">#跳到该commit快照</span></span><br><span class="line">git checkout - <span class="comment">#回到当前</span></span><br></pre></td></tr></table></figure><h3 id="已暂存撤销到工作区-git-不再跟踪"><a href="#已暂存撤销到工作区-git-不再跟踪" class="headerlink" title="已暂存撤销到工作区(git 不再跟踪)"></a>已暂存撤销到工作区(git 不再跟踪)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm -- cached &lt;file&gt;</span><br><span class="line">git reset &lt;file&gt;</span><br><span class="line">git reset .   <span class="comment">#--mixed 为默认参数 意思是把变更放在工作区</span></span><br><span class="line">git reset --hard <span class="comment">#工作区和暂存区都撤销</span></span><br></pre></td></tr></table></figure><h3 id="文件改名"><a href="#文件改名" class="headerlink" title="文件改名"></a>文件改名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv oldName newName</span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt;</span><br></pre></td></tr></table></figure><h2 id="比较-diff"><a href="#比较-diff" class="headerlink" title="比较 diff"></a>比较 diff</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git diff                <span class="comment">#比较Working tree和index之间的差异</span></span><br><span class="line">git diff &lt;file&gt;      <span class="comment">#比较Working tree和index之间的差异</span></span><br><span class="line">git diff --cached 或 <span class="variable">$git</span> diff --staged    <span class="comment">#两个都是比较index和版本库的差异</span></span><br><span class="line">git diff HEAD <span class="comment"># 查看Working tree和版本库的差异</span></span><br><span class="line">git diff &lt;<span class="variable">$id1</span>&gt; &lt;<span class="variable">$id2</span>&gt;  <span class="comment">#比较两次提交之间的差异</span></span><br><span class="line">git diff &lt;branch1&gt;..&lt;branch2&gt; <span class="comment">#在两个分支之间比较</span></span><br><span class="line">git diff --name-only HEAD src <span class="comment">#显示当前分支最新的提交与工作区或暂存区的比较，只显示文件名</span></span><br></pre></td></tr></table></figure><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="^和~的区别"></a>^和~的区别</h2><ul><li><code>^</code>代表父提交,当一个提交有多个父提交时，可以通过在<code>^</code>后面跟上一个数字，表示第几个父提交，<code>^</code>相当于<code>^1</code>。</li><li><code>~&lt;n&gt;</code>表示第 n 个祖先提交，相当于连续的 n 个<code>^</code>。如<code>HEAD~3</code>即 HEAD 的父提交的父提交的父提交。如要取 merge 的第二个父提交的父提交:<code>HEAD^2~1</code></li></ul><h2 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span>                      <span class="comment">#第一行为commit ID</span></span><br><span class="line">git <span class="built_in">log</span>  -p &lt;file&gt;  <span class="comment">#查看指定文件的提交历史</span></span><br><span class="line">git blame  &lt;file&gt; <span class="comment">#以列表方式查看指定文件的提交历史</span></span><br><span class="line">git reflog show master | head  <span class="comment">#显示所有的版本记录</span></span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>这里收集了 <code>四种</code> 方式实现版本回退，通过<code>git reflog</code>可以查看操作记录。</p><h3 id="暴力-reset-回退"><a href="#暴力-reset-回退" class="headerlink" title="暴力 reset 回退"></a>暴力 reset 回退</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line">git reset --hard &lt;commit&gt;</span><br><span class="line">git push origin master -f</span><br></pre></td></tr></table></figure><p>该方式会<code>改变历史进程</code>，多人开发时会混乱,非常不推荐。</p><h3 id="使用-revert-生成一个新-commit"><a href="#使用-revert-生成一个新-commit" class="headerlink" title="使用 revert 生成一个新 commit"></a>使用 revert 生成一个新 commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git revert 5aab391 <span class="comment">#回滚某次commit</span></span><br><span class="line">git revert -n 5aab391..1hd2d72 <span class="comment">#回滚从5aab391到1hd2d72，但中间如果有merge等则不适用</span></span><br><span class="line">git revert -m 1 5aab391 <span class="comment">#回滚某次merge的commit -m 1是选择保留1，抛弃2，这个1，2的定义在git log中的merge那行顺序为准</span></span><br></pre></td></tr></table></figure><p>该方法<code>不会改变历史进程</code>，适用于单个回滚或者多个无 merge 的回滚。</p><h3 id="使用-reset-–head-–soft"><a href="#使用-reset-–head-–soft" class="headerlink" title="使用 reset –head –soft"></a>使用 reset –head –soft</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 5aab391</span><br><span class="line">git reset --soft 1hd2d72 <span class="comment">#5aab391到1hd2d72之前的放到了暂存区 ？</span></span><br><span class="line">git commit -m <span class="string">'生成一个新提交，回滚5aab391到1hd2d72的内容'</span></span><br><span class="line">git push xxx</span><br></pre></td></tr></table></figure><p>该方法<code>不会改变历史进程</code>，生成一个新的 commit 来覆盖之前的内容达到回滚，推荐。</p><h3 id="使用-s-ours-master"><a href="#使用-s-ours-master" class="headerlink" title="使用 -s ours master"></a>使用 -s ours master</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b v2 4a50c9f <span class="comment">#切一个新分支并使用历史安全版本</span></span><br><span class="line">git merge -s ours master</span><br><span class="line">git push origin master <span class="comment">#等价于git push origin v2:master</span></span><br></pre></td></tr></table></figure><p>该方法<code>不会改变历史进程</code>，生成一个新的 commit 来覆盖之前的内容达到回滚，墙裂推荐。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@git ….</span><br></pre></td></tr></table></figure><h3 id="创建-SSH-Key"><a href="#创建-SSH-Key" class="headerlink" title="创建 SSH Key"></a>创建 SSH Key</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -c <span class="string">"623212389@qq.com"</span></span><br></pre></td></tr></table></figure><p>用户主目录下 →.ssh→id_rsa（私钥）+id_rsa.pub（公钥）或<code>\$cat ~/.ssh/id-rsa.pub</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">git remote -v     <span class="comment">#查看远程服务器地址和仓库名称</span></span><br><span class="line">git remote show origin   <span class="comment">#查看远程服务器仓库状态</span></span><br><span class="line">git remote add origin git@git……    <span class="comment">#添加远程仓库地址</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin git@git……    <span class="comment">#修改远程地址</span></span><br><span class="line">git remote rm    <span class="comment">#删除远程创库地址</span></span><br><span class="line"></span><br><span class="line">git pull  <span class="comment"># =git fetch + git merge</span></span><br><span class="line">git fetch <span class="comment">#拉取</span></span><br><span class="line">git merge <span class="comment">#合并</span></span><br><span class="line">git push <span class="comment"># push所有分支</span></span><br><span class="line">git push origin master           <span class="comment"># 将本地主分支推到远程主分支</span></span><br><span class="line">git push -u origin master       <span class="comment"># 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</span></span><br><span class="line">git push origin &lt;local_branch&gt;   <span class="comment"># 创建远程分支， origin是远程仓库名</span></span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  <span class="comment"># 创建远程分支</span></span><br><span class="line">git push origin :&lt;remote_branch&gt;  <span class="comment">#先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支</span></span><br><span class="line"></span><br><span class="line">git rebase</span><br><span class="line"></span><br><span class="line">git remote update origin --prune  <span class="comment">#更新远程分支信息</span></span><br></pre></td></tr></table></figure><h2 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><h3 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h3 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a <span class="comment">#远程分支用的红色</span></span><br></pre></td></tr></table></figure><h3 id="查看已经被合并到当前分支的分支"><a href="#查看已经被合并到当前分支的分支" class="headerlink" title="查看已经被合并到当前分支的分支"></a>查看已经被合并到当前分支的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged</span><br></pre></td></tr></table></figure><h3 id="查看未被合并到当前分支的分支"><a href="#查看未被合并到当前分支的分支" class="headerlink" title="查看未被合并到当前分支的分支"></a>查看未被合并到当前分支的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch xxx</span><br></pre></td></tr></table></figure><h3 id="切换分支或标签"><a href="#切换分支或标签" class="headerlink" title="切换分支或标签"></a>切换分支或标签</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout xxx/tag</span><br></pre></td></tr></table></figure><h3 id="创建加切换"><a href="#创建加切换" class="headerlink" title="创建加切换"></a>创建加切换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b xxx</span><br></pre></td></tr></table></figure><h3 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m old new</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d xxx   <span class="comment">#-D为强制删除</span></span><br></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;branchName&gt;</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">git push origin  :&lt;branchName&gt;  <span class="comment">#推送一个空分支到远程</span></span><br></pre></td></tr></table></figure><h2 id="暂存管理"><a href="#暂存管理" class="headerlink" title="暂存管理"></a>暂存管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash  <span class="comment">#将工作区做的修改暂存到一个git栈中</span></span><br><span class="line">git stash list <span class="comment">#查看栈中所有暂存</span></span><br><span class="line">git stash apply &lt;暂存编号&gt;  <span class="comment">#回复对应编号暂存到工作区，如果不指定编号为栈顶的，注意：这些暂存还在栈中</span></span><br><span class="line">git stash pop <span class="comment">#将栈顶的暂存，恢复到工作区，并从栈中弹出</span></span><br><span class="line">git stash clear <span class="comment">#清空暂存栈</span></span><br></pre></td></tr></table></figure><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0 <span class="comment">#id</span></span><br><span class="line">git tag -a v1.0.0 -m <span class="string">"你的附注信息"</span> <span class="comment">#id</span></span><br><span class="line">git tag</span><br><span class="line">git show v1.0.0</span><br><span class="line">git tag -d v1.0.0</span><br><span class="line">git push origin :refs/tags/v1.0.0</span><br><span class="line">git push --tags <span class="comment">#上传所有标签</span></span><br></pre></td></tr></table></figure><h2 id="挑拣提交"><a href="#挑拣提交" class="headerlink" title="挑拣提交"></a>挑拣提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick 1hs73hds <span class="comment">#直接在该分支应用任意其他分支的commit即可</span></span><br></pre></td></tr></table></figure><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>使用 Windows 的童鞋注意了，如果你在资源管理器里新建一个 <code>.gitignore</code> 文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 <code>.gitignore</code> 了。</p><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p>在 <code>GitHub</code> 上，可以任意 <code>Fork</code> 开源仓库； 自己拥有 <code>Fork</code> 后的仓库的读写权限； 可以推送 <code>pull request</code> 给官方仓库来贡献代码。</p><h2 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h2><p><img src="http://cdn.flqin.com/p347-1.png" alt="git命令总结"></p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）cookie浅析</title>
      <link href="/340.html"/>
      <url>/340.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接：<code>https://segmentfault.com/a/1190000004556040</code></p></blockquote><h2 id="我们看到的-cookie"><a href="#我们看到的-cookie" class="headerlink" title="我们看到的 cookie"></a>我们看到的 cookie</h2><p>在 <code>chrome</code> 浏览器中打开这个网站，进入开发者模式，点击 <code>Resources 栏</code> -&gt; 选择 <code>cookies</code>，我们会看到如下图所示的界面：</p><p><img src="http://cdn.flqin.com/p340-1.png" alt="chrome resources"></p><p>在这个网页 <code>http://ppsc.sankuai.com</code> 中我设置了几个<code>cookie</code>：<code>JSSESSIONID，PA_VTIME，skmtutc，test</code>。</p><p>解释一下：左边栏 <code>Cookies</code> 下方会列举当前网页中设置过 <code>cookie</code> 的域都有哪些。上图中只有一个域，即“<code>ppsc.sankuai.com</code>”。而右侧区域显示的就是某个域下具体的 <code>cookie</code> 列表，对应上图就是“<code>ppsc.sankuai.com</code>”域下设置的 4 个 <code>cookie</code>。</p><p>在这个网页中我往 <code>http://ppsc.sankuai.com/getList</code> 接口发了一个 <code>Ajax</code> 请求，<code>request header</code> 如下图所示：</p><p><img src="http://cdn.flqin.com/p340-2.png" alt="request header"></p><p>从上图中我们会看到 <code>request header</code> 中自动添加了 <code>Cookie</code> 字段（我并没有手动添加这个字段哦~），<code>Cookie</code> 字段的值其实就是我设置的那 4 个 <code>cookie</code>。这个请求最终会发送到 <code>http://ppsc.sankuai.com</code> 这个服务器上，这个服务器就能从接收到的 <code>request header</code> 中提取那 4 个 <code>cookie</code>。</p><p>上面两张图展示了 <code>cookie</code> 的基本通信流程：<code>设置 cookie</code> =&gt; <code>cookie 被自动添加到 request header 中</code> =&gt; <code>服务端接收到 cookie</code>。这个流程中有几个问题需要好好研究：</p><ul><li>什么样的数据适合放在 <code>cookie</code> 中？</li><li><code>cookie</code> 是怎么设置的？</li><li><code>cookie</code> 为什么会自动加到 <code>request header</code> 中？</li><li><code>cookie</code> 怎么增删查改？</li></ul><p>我们要带着这几个问题继续往下阅读。</p><h2 id="cookie-是怎么工作的"><a href="#cookie-是怎么工作的" class="headerlink" title="cookie 是怎么工作的"></a>cookie 是怎么工作的</h2><p>首先必须明确一点，存储 <code>cookie</code> 是浏览器提供的功能。<code>cookie</code> 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 <code>cookie</code> 文件夹来存放各个域下设置的 <code>cookie</code>。</p><p>当网页要发 <code>http</code> 请求时，浏览器会先检查是否有相应的 <code>cookie</code>，有则自动添加在 <code>request header</code> 中的 <code>cookie</code> 字段中。这些是浏览器自动帮我们做的，而且每一次 <code>http</code> 请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在 <code>cookie</code> 中”。</p><p>存储在 <code>cookie</code> 中的数据，每次都会被浏览器自动放在 <code>http</code> 请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在 <code>cookie</code> 中，其他类型的数据就不适合了。</p><p>但在 <code>localStorage</code> 出现之前，<code>cookie</code> 被滥用当做了存储工具。什么数据都放在 <code>cookie</code> 中，即使这些数据只在页面中使用而不需要随请求传送到服务端。当然 <code>cookie</code> 标准还是做了一些限制的：每个域名下的 <code>cookie</code> 的大小最大为 4KB，每个域名下的 <code>cookie</code> 数量最多为 20 个（但很多浏览器厂商在具体实现时支持大于 20 个）。</p><h2 id="cookie-的格式"><a href="#cookie-的格式" class="headerlink" title="cookie 的格式"></a>cookie 的格式</h2><h3 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h3><p><code>JS</code> 原生的 <code>API</code> 提供了获取 <code>cookie</code> 的方法：<code>document.cookie</code>（注意，这个方法只能获取非 <code>HttpOnly</code> 类型的 <code>cookie</code>）。在 <code>console</code> 中执行这段代码可以看到结果如下图：</p><p><img src="http://cdn.flqin.com/p340-3.png" alt="document.cookie"></p><p>打印出的结果是一个字符串类型，因为 <code>cookie</code> 本身就是存储在浏览器中的字符串。但这个字符串是有格式的，由键值对 <code>key=value</code> 构成，键值对之间由一个分号和一个空格隔开。</p><h3 id="cookie-的属性选项"><a href="#cookie-的属性选项" class="headerlink" title="cookie 的属性选项"></a>cookie 的属性选项</h3><p>每个 <code>cookie</code> 都有一定的属性，如什么时候失效，要发送到哪个域名，哪个路径等等。这些属性是通过 <code>cookie</code> 选项来设置的，<code>cookie</code> 选项包括：<code>expires、domain、path、secure、HttpOnly</code>。在设置任一个 <code>cookie</code> 时都可以设置相关的这些属性，当然也可以不设置，这时会使用这些属性的默认值。在设置这些属性时，属性之间由一个分号和一个空格隔开。代码示例如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly"</span></span><br></pre></td></tr></table></figure><h4 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h4><p><code>expires</code> 选项用来设置 <code>cookie</code> 什么时间内有效”。<code>expires</code> 其实是 <code>cookie</code> 失效日期，<code>expires</code> 必须是 <code>GMT</code> 格式的时间（可以通过 <code>new Date().toGMTString()</code>或者 <code>new Date().toUTCString()</code> 来获得）。</p><p>如 <code>expires=Thu, 25 Feb 2016 04:18:00 GMT</code> 表示 <code>cookie</code> 将在 <code>2016 年 2 月 25 日 4:18 分</code> 之后失效，对于失效的 <code>cookie</code> 浏览器会清空。如果没有设置该选项，则默认有效期为 <code>session</code>，即会话 <code>cookie</code>。这种 <code>cookie</code> 在浏览器关闭后就没有了。</p><blockquote><p>expires 是 http/1.0 协议中的选项，在新的 http/1.1 协议中 expires 已经由 max-age 选项代替，两者的作用都是限制 cookie 的有效时间。expires 的值是一个时间点（cookie 失效时刻= expires），而 max-age 的值是一个以秒为单位时间段（cookie 失效时刻= 创建时刻+ max-age）。 另外，max-age 的默认值是 -1(即有效期为 session )；若 max-age 有三种可能值：负数、0、正数。负数：有效期 session；0：删除 cookie；正数：有效期为创建时刻+ max-age</p></blockquote><h4 id="domain-和-path"><a href="#domain-和-path" class="headerlink" title="domain 和 path"></a>domain 和 path</h4><p><code>domain</code> 是域名，<code>path</code> 是路径，两者加起来就构成了 <code>URL</code>，<code>domain</code> 和 <code>path</code> 一起来限制 <code>cookie</code> 能被哪些 <code>URL</code> 访问。</p><p>一句话概括：某 <code>cookie</code> 的 <code>domain</code> 为 <code>baidu.com</code>, <code>path</code> 为 <code>/</code>，若请求的 <code>URL</code> (<code>URL</code> 可以是 <code>js/html/img/css</code> 资源请求，但不包括 <code>XHR</code> 请求)的域名是 <code>baidu.com</code> 或其子域如 <code>api.baidu.com</code>、<code>dev.api.baidu.com</code>，且 <code>URL</code> 的路径是<code>/</code> 或子路径<code>/home</code>、<code>/home/login</code>，则浏览器会将此 <code>cookie</code> 添加到该请求的 <code>cookie</code> 头部中。</p><p>所以 <code>domain</code> 和 <code>path2</code> 个选项共同决定了 <code>cookie</code> 何时被浏览器自动添加到请求头部中发送出去。如果没有设置这两个选项，则会使用默认值。<code>domain</code> 的默认值为设置该 <code>cookie</code> 的网页所在的域名，<code>path</code> 默认值为设置该 <code>cookie</code> 的网页所在的目录。</p><blockquote><p><strong>特别说明 1：</strong><br>发生跨域 xhr 请求时，即使请求 URL 的域名和路径都满足 cookie 的 domain 和 path，默认情况下 cookie 也不会自动被添加到请求头部中。若想知道原因请阅读本文最后一节）<br><strong>特别说明 2：</strong><br>domain 是可以设置为页面本身的域名（本域），或页面本身域名的父域，但不能是公共后缀 public suffix。举例说明下：如果页面域名为 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>, domain 可以设置为“<a href="http://www.baidu.com”，也可以设置为“baidu.com”，但不能设置为“.com”或“com”。" target="_blank" rel="noopener">www.baidu.com”，也可以设置为“baidu.com”，但不能设置为“.com”或“com”。</a></p></blockquote><h4 id="secure"><a href="#secure" class="headerlink" title="secure"></a>secure</h4><p><code>secure</code> 选项用来设置 <code>cookie</code> 只在确保安全的请求中才会发送。当请求是 <code>HTTPS</code> 或者其他安全协议时，包含 <code>secure</code> 选项的 <code>cookie</code> 才能被发送至服务器。</p><p>默认情况下，<code>cookie</code> 不会带 <code>secure</code> 选项(即为空)。所以默认情况下，不管是 <code>HTTPS</code> 协议还是 <code>HTTP</code> 协议的请求，<code>cookie</code> 都会被发送至服务端。但要注意一点，<code>secure</code> 选项只是限定了在安全情况下才可以传输给服务端，但并不代表你不能看到这个 <code>cookie</code>。</p><p>下面我们设置一个 <code>secure</code> 类型的 <code>cookie</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=huang; secure'</span>;</span><br></pre></td></tr></table></figure><p>之后你就能在控制台中看到这个 <code>cookie</code> 了，如下图所示：</p><p><img src="http://cdn.flqin.com/p340-4.png" alt="cookie"></p><blockquote><p>这里有个坑需要注意下： 如果想在客户端即网页中通过 js 去设置 secure 类型的 cookie，必须保证网页是 https 协议的。在 http 协议的网页中是无法设置 secure 类型 cookie 的。</p></blockquote><h4 id="httpOnly"><a href="#httpOnly" class="headerlink" title="httpOnly"></a>httpOnly</h4><p>这个选项用来设置 <code>cookie</code> 是否能通过 <code>js</code> 去访问。默认情况下，<code>cookie</code> 不会带 <code>httpOnly</code> 选项(即为空)，所以默认情况下，客户端是可以通过 <code>js</code> 代码去访问（包括读取、修改、删除等）这个 <code>cookie</code> 的。当 <code>cookie</code> 带 <code>httpOnly</code> 选项时，客户端则无法通过 <code>js</code> 代码去访问（包括读取、修改、删除等）这个 <code>cookie</code>。</p><p>在客户端是不能通过 <code>js</code> 代码去设置一个 <code>httpOnly</code> 类型的 <code>cookie</code> 的，这种类型的 <code>cookie</code> 只能通过服务端来设置。</p><p>那我们在页面中怎么知道哪些 <code>cookie</code> 是 <code>httpOnly</code> 类型的呢？看下图：</p><p><img src="http://cdn.flqin.com/p340-5.png" alt="httpOnly"></p><p>凡是 <code>httpOnly</code> 类型的 <code>cookie</code>，其 <code>HTTP</code> 一列都会打上 <code>√</code>，如上图中的 <code>PA_VTIME</code>。你通过 <code>document.cookie</code> 是不能获取的，也不能修改 <code>PA_VTIME</code> 的。</p><blockquote><p>——httpOnly 与安全</p><p>从上面介绍中，大家是否会有这样的疑问：为什么我们要限制客户端去访问 cookie？其实这样做是为了保障安全。</p><p>试想：如果任何 cookie 都能被客户端通过 document.cookie 获取会发生什么可怕的事情。当我们的网页遭受了 XSS 攻击，有一段恶意的 script 脚本插到了网页中。这段 script 脚本做的事情是：通过 document.cookie 读取了用户身份验证相关的 cookie，并将这些 cookie 发送到了攻击者的服务器。攻击者轻而易举就拿到了用户身份验证信息，于是就可以摇摇大摆地冒充此用户访问你的服务器了（因为攻击者有合法的用户身份验证信息，所以会通过你服务器的验证）。</p></blockquote><h2 id="如何设置-cookie"><a href="#如何设置-cookie" class="headerlink" title="如何设置 cookie"></a>如何设置 cookie</h2><p>知道了 <code>cookie</code> 的格式，<code>cookie</code> 的属性选项，接下来我们就可以设置 <code>cookie</code> 了。首先得明确一点：<code>cookie</code> 既可以由服务端来设置，也可以由客户端来设置。</p><h3 id="服务端设置-cookie"><a href="#服务端设置-cookie" class="headerlink" title="服务端设置 cookie"></a>服务端设置 cookie</h3><p>不管你是请求一个资源文件（如 <code>html/js/css/图片</code>），还是发送一个 <code>ajax</code> 请求，服务端都会返回 <code>response</code>。而 <code>response header</code> 中有一项叫 <code>set-cookie</code>，是服务端专门用来设置 <code>cookie</code> 的。如下图所示，服务端返回的 <code>response header</code> 中有 5 个 <code>set-cookie</code> 字段，每个字段对应一个 <code>cookie</code>（注意不能将多个 <code>cookie</code> 放在一个 <code>set-cookie</code> 字段中），<code>set-cookie</code> 字段的值就是普通的字符串，每个 <code>cookie</code> 还设置了相关属性选项。</p><p><img src="http://cdn.flqin.com/p340-6.png" alt="set-Cookie"></p><p>注意：</p><ul><li>一个 <code>set-Cookie</code> 字段只能设置一个 <code>cookie</code>，当你要想设置多个 <code>cookie</code>，需要添加同样多的 <code>set-Cookie</code> 字段。</li><li>服务端可以设置 <code>cookie</code> 的所有选项：<code>expires、domain、path、secure、HttpOnly</code></li></ul><h3 id="客户端设置-cookie"><a href="#客户端设置-cookie" class="headerlink" title="客户端设置 cookie"></a>客户端设置 cookie</h3><p>在网页即客户端中我们也可以通过 <code>js</code> 代码来设置 <code>cookie</code>。如我当前打开的网址为<code>http://dxw.st.sankuai.com/mp/</code>，在控制台中我们执行了下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=Jonh; '</span>;</span><br></pre></td></tr></table></figure><p>查看浏览器 <code>cookie</code> 面板如下图所示，<code>cookie</code> 确实设置成功了，而且属性选项 <code>domain、path、expires</code> 都用了默认值。</p><p><img src="http://cdn.flqin.com/p340-7.png" alt="cookie"></p><p>再执行下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'age=12; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/'</span>;</span><br></pre></td></tr></table></figure><p>查看浏览器 <code>cookie</code> 面板，如下图所示，新的 <code>cookie</code> 设置成功了，而且属性选项 <code>domain、path、expires</code> 都变成了设定的值。</p><p><img src="http://cdn.flqin.com/p340-8.png" alt="cookie"></p><p>注意：</p><ul><li>客户端可以设置 <code>cookie</code> 的下列选项：<code>expires、domain、path、secure</code>（有条件：只有在 <code>https</code> 协议的网页中，客户端设置 <code>secure</code> 类型的 <code>cookie</code> 才能成功），但无法设置 <code>HttpOnly</code> 选项。</li></ul><h4 id="用-js-如何设置多个-cookie"><a href="#用-js-如何设置多个-cookie" class="headerlink" title="用 js 如何设置多个 cookie"></a>用 js 如何设置多个 cookie</h4><p>当要设置多个 <code>cookie</code> 时， <code>js</code> 代码很自然地我们会这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=Jonh; age=12; class=111'</span>;</span><br></pre></td></tr></table></figure><p>但你会发现这样写只是添加了第一个 <code>cookie</code>:<code>name=John</code>，后面的所有 <code>cookie</code> 都没有添加成功。所以最简单的设置多个 <code>cookie</code> 的方法就在重复执行 <code>document.cookie = &quot;key=name&quot;</code>，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=Jonh'</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'age=12'</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'class=111'</span>;</span><br></pre></td></tr></table></figure><h2 id="如何修改、删除"><a href="#如何修改、删除" class="headerlink" title="如何修改、删除"></a>如何修改、删除</h2><h3 id="修改-cookie"><a href="#修改-cookie" class="headerlink" title="修改 cookie"></a>修改 cookie</h3><p>要想修改一个 <code>cookie</code>，只需要重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新 <code>cookie</code> 时，<code>path/domain</code> 这几个选项一定要旧 <code>cookie</code> 保持一样。否则不会修改旧值，而是添加了一个新的 <code>cookie</code>。</p><h3 id="删除-cookie"><a href="#删除-cookie" class="headerlink" title="删除 cookie"></a>删除 cookie</h3><p>删除一个 <code>cookie</code> 也挺简单，也是重新赋值，只要将这个新 <code>cookie</code> 的 <code>expires</code> 选项设置为一个过去的时间点就行了。但同样要注意，<code>path/domain/</code>这几个选项一定要旧 <code>cookie</code> 保持一样。</p><h2 id="cookie-编码"><a href="#cookie-编码" class="headerlink" title="cookie 编码"></a>cookie 编码</h2><p><code>cookie</code> 其实是个字符串，但这个字符串中逗号、分号、空格被当做了特殊符号。所以当 <code>cookie</code> 的 <code>key</code> 和 <code>value</code> 中含有这 3 个特殊字符时，需要对其进行额外编码，一般会用 <code>escape</code> 进行编码，读取时用 <code>unescape</code> 进行解码；当然也可以用 <code>encodeURIComponent/decodeURIComponent</code> 或者 <code>encodeURI/decodeURI</code>（三者的区别可以参考这篇文章）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key = <span class="built_in">escape</span>(<span class="string">'name;value'</span>);</span><br><span class="line"><span class="keyword">var</span> value = <span class="built_in">escape</span>(<span class="string">'this is a value contain , and ;'</span>);</span><br><span class="line"><span class="built_in">document</span>.cookie = key + <span class="string">'='</span> + value + <span class="string">'; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/'</span>;</span><br></pre></td></tr></table></figure><h2 id="跨域请求中-cookie"><a href="#跨域请求中-cookie" class="headerlink" title="跨域请求中 cookie"></a>跨域请求中 cookie</h2><p>之前在介绍 <code>XHR</code> 的一篇文章里面提过：默认情况下，在发生跨域时，<code>cookie</code> 作为一种 <code>credential</code> 信息是不会被传送到服务端的。必须要进行额外设置才可以。具体原因和如何设置可以参考我的这篇文章：你真的会使用 <code>XMLHttpRequest</code> 吗？</p><p>另外，关于跨域资源共享 <code>CORS</code> 极力推荐大家阅读阮一峰老师的这篇 <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a>。</p><h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><ol><li>什么时候 <code>cookie</code> 会被覆盖：<code>name/domain/path</code> 这 3 个字段都相同的时候；</li><li>关于 <code>domain</code> 的补充说明：</li></ol><ul><li>如果显式设置了 <code>domain</code>，则设置成什么，浏览器就存成什么；但如果没有显式设置，则浏览器会自动取 <code>url</code> 的 <code>host</code> 作为 <code>domain</code> 值；</li><li>新的规范中，显式设置 <code>domain</code> 时，如果 <code>value</code> 最前面带点，则浏览器处理时会将这个点去掉，所以最后浏览器存的就是没有点的（注意：但目前大多数浏览器并未全部这么实现）</li><li>前面带点‘.’和不带点‘.’有啥区别：<ul><li>带点：任何 <code>subdomain</code> 都可以访问，包括父 <code>domain</code></li><li>不带点：只有完全一样的域名才能访问，<code>subdomain</code> 不能（但在 <code>IE</code> 下比较特殊，它支持 <code>subdomain</code> 访问）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）从输入URL到页面加载的过程</title>
      <link href="/336.html"/>
      <url>/336.html</url>
      
        <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>对知识体系进行一次预评级</li><li>为什么说知识体系如此重要？</li><li>梳理主干流程</li><li>从浏览器接收url到开启网络请求线程<ul><li>多进程的浏览器</li><li>多线程的浏览器内核</li><li>解析URL</li><li>网络请求都是单独的线程</li><li>更多</li></ul></li><li>开启网络线程到发出一个完整的http请求<ul><li>DNS查询得到IP</li><li>tcp/ip请求</li><li>五层因特网协议栈</li></ul></li><li>从服务器接收到请求到对应后台接收到请求<ul><li>负载均衡</li><li>后台的处理</li></ul></li><li>后台和前台的http交互<ul><li>http报文结构</li><li>cookie以及优化</li><li>gzip压缩</li><li>长连接与短连接</li><li>http 2.0</li><li>https</li></ul></li><li>单独拎出来的缓存问题，http的缓存<ul><li>强缓存与弱缓存</li><li>缓存头部简述</li><li>头部的区别</li></ul></li><li>解析页面流程<ul><li>流程简述</li><li>HTML解析，构建DOM</li><li>生成CSS规则</li><li>构建渲染树</li><li>渲染</li><li>了解层</li><li>Chrome中的调试</li><li>资源外链的下载</li><li>loaded和domcontentloaded</li></ul></li><li>CSS的可视化格式模型<ul><li>包含块（Containing Block）</li><li>控制框（Controlling Box）</li><li>盒模型</li><li>BFC（Block Formatting Context）</li><li>IFC（Inline Formatting Context）</li><li>其它</li></ul></li><li>JS引擎解析过程<ul><li>JS的解释阶段</li><li>JS的预处理阶段</li><li>JS的执行阶段</li><li>回收机制</li></ul></li><li>其它</li><li>总结</li></ul><h2 id="对知识体系进行一次预评级"><a href="#对知识体系进行一次预评级" class="headerlink" title="对知识体系进行一次预评级"></a>对知识体系进行一次预评级</h2><p>看到这道题目，不借助搜索引擎，自己的心里是否有一个答案？</p><p>这里，以目前的经验（了解过一些处于不同阶段的相关前端人员的情况），大概有以下几种情况：（以下都是以点见面，实际上不同阶段人员一般都会有其它的隐藏知识点的）</p><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><p>完全没什么概念的，支支吾吾的回答，一般就是这种水平（大致形象点描述）：</p><ul><li>浏览器发起请求，服务端返回数据，然后前端解析成网页，执行脚本。。。</li></ul><p>这类人员一般都是：</p><ul><li>萌新（刚接触前端的，包括0-6个月都有可能有这种回答）</li><li>沉淀人员（就是那种可能已经接触了前端几年，但是仍然处于初级阶段的那种。。。）</li></ul><p>当然了，后者一般还会偶尔提下<code>http、后台、浏览器渲染，js引擎</code>等等关键字，但基本都是一详细的问就不知道了。。。</p><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><p>已经有初步概念，但是可能没有完整梳理过，导致无法形成一个完整的体系，或者是很多细节都不会展开，大概是这样子的：（可能符合若干条）</p><ul><li>知道浏览器输入url后会有http请求这个概念</li><li>有后台这个概念，大致知道前后端的交互，知道前后端靠http报文通信</li><li>知道浏览器接收到数据后会进行解析，有一定概念，但是具体流程不熟悉（如render树构建流程，layout、paint，复合层与简单层，常用优化方案等不是很熟悉）</li><li>对于js引擎的解析流程有一定概念，但是细节不熟悉（如具体的形参，函数，变量提升，执行上下文以及VO、AO、作用域链，回收机制等概念不是很熟悉）</li><li>如可能知道一些http规范初步概念，但是不熟悉（如http报文结构，常用头部，缓存机制，http2.0，https等特性，跨域与web安全等不是很熟悉）</li></ul><p>到这里，看到这上面一大堆的概念后，心里应该也会有点底了。。。</p><p><strong>实际上，大部分的前端人员可能都处于level2</strong>，但是，跳出这个阶段并不容易，一般需要积累，不断学习，才能水到渠成。</p><p>这类人员一般都是：</p><ul><li>工作1-3年左右的普通人员（占大多数，而且大多数人员工作3年左右并没有实质上的提升）</li><li>工作3年以上的老人（这部分人大多都业务十分娴熟，一个当好几个用，但是，基础比较薄弱，可能没有尝试写过框架、组件、脚手架等）</li></ul><p>大部分的初中级都陷在这个阶段，如果要突破，不断学习，积累，自然能水到渠成，打通任督二脉。</p><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>基本能到这一步的，不是高阶就是接近高阶，因为很多概念并不是靠背就能理解的，而要理解这么多，需形成体系，一般都需要积累，非一日之功。</p><p>一般包括什么样的回答呢？（这里就以自己的简略回答进行举例），一般这个阶段的人员都会符合若干条（不一定全部，当然可能还有些是这里遗漏的）:</p><ul><li>首先略去那些键盘输入、和操作系统交互、以及屏幕显示原理、网卡等硬件交互之类的（前端向中，很多硬件原理暂时略去。。。）</li><li>对浏览器模型有整体概念，知道浏览器是多进程的，浏览器内核是多线程的，清楚进程与线程之间得区别，以及输入url后会开一个新的网络线程</li><li>对从开启网络线程到发出一个完整的http请求中间的过程有所了解（如dns查询，tcp/ip链接，五层因特网协议栈等等，以及一些优化方案，如dns-prefetch）</li><li>对从服务器接收到请求到对应后台接收到请求有一定了解（如负载均衡，安全拦截以及后台代码处理等）</li><li>对后台和前台的http交互熟悉（包括http报文结构，场景头部，cookie，跨域，web安全，http缓存，http2.0，https等）</li><li>对浏览器接收到http数据包后的解析流程熟悉（包括解析html，词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、里面可能还包括复合图层的合成、GPU绘制、外链处理、加载顺序等）</li><li>对JS引擎解析过程熟悉（包括JS的解释，预处理，执行上下文，VO，作用域链，this，回收机制等）</li></ul><p>可以看到，上述包括了一大堆的概念，仅仅是偏前端向，而且没有详细展开，就已经如此之多的概念了，所以，个人认为如果没有自己的见解，没有形成自己的知识体系，仅仅是看看，背背是没用的，过一段时间就会忘光了。</p><p>再说下一般这个阶段的都可能是什么样的人吧。（不一定准确，这里主要是靠少部分现实以及大部分推测得出）</p><ul><li>工作2年以上的前端（基本上如果按正常进度的话，至少接触前端两年左右才会开始走向高阶，当然，现在很多都是上学时就开始学了的，还有部分是天赋异禀，不好预估。。。）</li><li>或者是已经十分熟悉其它某门语言，再转前端的人（基本上是很快就可以将前端水准提升上去）</li></ul><p>一般符合这个条件的都会有各种隐藏属性（如看过各大框架、组件的源码，写过自己的组件、框架、脚手架，做过大型项目，整理过若干精品博文等）</p><h3 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h3><p>由于本人层次尚未达到，所以大致说下自己的见解吧。</p><p>一般这个层次，很多大佬都并不仅仅是某个技术栈了，而是成为了技术专家，技术leader之类的角色。所以仅仅是回答某个技术问题已经无法看出水准了， 可能更多的要看架构，整体把控，大型工程构建能力等等</p><p>不过，对于某些执着于技术的大佬，大概会有一些回答吧：（猜的）</p><ul><li>从键盘谈起到系统交互，从浏览器到CPU，从调度机制到系统内核，从数据请求到二进制、汇编，从GPU绘图到LCD显示，然后再分析系统底层的进程、内存等等</li></ul><p>总之，从软件到硬件，到材料，到分子，原子，量子，薛定谔的猫，人类起源，宇宙大爆炸，平行宇宙？感觉都毫无违和感。。。</p><p>这点可以参考下本题的原始出处：<a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="noopener">查阅</a></p><h2 id="为什么说知识体系如此重要"><a href="#为什么说知识体系如此重要" class="headerlink" title="为什么说知识体系如此重要"></a>为什么说知识体系如此重要</h2><p>为什么说知识体系如此重要呢？这里举几个例子</p><p>假设有被问到这样一道题目（随意想到的一个）：</p><ul><li>如何理解<code>getComputedStyle</code></li></ul><p>在尚未梳理知识体系前，大概会这样回答：</p><ul><li>普通版本：<code>getComputedStyle</code>会获取当前元素所有最终使用的CSS属性值（最终计算后的结果），通过<code>window.getComputedStyle</code>等价于<code>document.defaultView.getComputedStyle</code>调用</li><li>详细版本：<code>window.getComputedStyle(elem, null).getPropertyValue(&quot;height&quot;)</code>可能的值为<code>100px</code>，而且，就算是css上写的是<code>inherit</code>，<code>getComputedStyle</code>也会把它最终计算出来的。不过注意，如果元素的背景色透明，那么<code>getComputedStyle</code>获取出来的就是透明的这个背景（因为透明本身也是有效的），而不会是父节点的背景。所以它不一定是最终显示的颜色。</li></ul><p>就这个API来说，上述的回答已经比较全面了。</p><p>但是，其实它是可以继续延伸的。</p><p>譬如现在会这样回答：</p><ul><li><code>getComputedStyle</code>会获取当前元素所有最终使用的CSS属性值，<code>window.</code>和<code>document.defaultView.</code>等价</li><li><code>getComputedStyle</code>会引起回流，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），所以用的时候慎用，回流会引起性能问题。然后合适的话会将话题引导回流，重绘，浏览器渲染原理等等。当然也可以列举一些其它会引发回流的操作，如<code>offsetXXX，scrollXXX，clientXXX，currentStyle</code>等等</li></ul><p>再举一个例子：</p><ul><li><code>visibility: hidden</code>和<code>display: none</code>的区别</li></ul><p>可以如下回答：</p><ul><li>普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置</li><li>进一步，display由于隐藏后不占据位置，所以造成了dom树的改变，会引发<code>回流</code>，代价较大</li><li>再进一步，当一个页面某个元素经常需要切换<code>display</code>时如何优化，一般会用复合层优化，或者要求低一点用<code>absolute</code>让其脱离普通文档流也行。然后可以将话题引到普通文档流，<code>absolute</code>文档流，复合图层的区别，</li><li>再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）</li></ul><p>上面这些大概就是知识系统化后的回答，会更全面，容易由浅入深，而且一有机会就可以往更底层挖</p><h3 id="前端向知识的重点"><a href="#前端向知识的重点" class="headerlink" title="前端向知识的重点"></a>前端向知识的重点</h3><p>此部分的内容是站在个人视角分析的，并不是说就一定是正确答案</p><p>首先明确，计算机方面的知识是可以无穷无尽的挖的，而本文的重点是梳理<code>前端向</code>的重点知识</p><p>对于<code>前端向</code>（这里可能没有提到<code>node.js</code>之类的，更多的是指客户端前端），这里将知识点按重要程度划分成以下几大类：</p><ul><li>核心知识，必须掌握的，也是最基础的，譬如浏览器模型，渲染原理，JS解析过程，JS运行机制等，作为骨架来承载知识体系</li><li>重点知识，往往每一块都是一个知识点，而且这些知识点都很重要，譬如http相关，web安全相关，跨域处理等</li><li>拓展知识，这一块可能更多的是了解，稍微实践过，但是认识上可能没有上面那么深刻，譬如五层因特网协议栈，hybrid模式，移动原生开发，后台相关等等（当然，在不同领域，可能有某些知识就上升到重点知识层次了，譬如hybrid开发时，懂原生开发是很重要的）</li></ul><p>为什么要按上面这种方式划分？</p><p>这大概与个人的技术成长有关。</p><p>记得最开始学前端知识时，是一点一点的积累，一个知识点一个知识点的攻克。</p><p>就这样，虽然在很长一段时间内积累了不少的知识，但是，总是无法将它串联到一起。每次梳理时都是很分散的，无法保持思路连贯性。</p><p>直到后来，在将<code>浏览器渲染原理</code>、<code>JS运行机制</code>、<code>JS引擎解析流程</code>梳理一遍后，感觉就跟打通了任督二脉一样，有了一个整体的架构，以前的知识点都连贯起来了。</p><p>梳理出了一个知识体系，以后就算再学新的知识，也会尽量往这个体系上靠拢，环环相扣，更容易理解，也更不容易遗忘。</p><h2 id="梳理主干流程"><a href="#梳理主干流程" class="headerlink" title="梳理主干流程"></a>梳理主干流程</h2><p>回到这道题上，如何回答呢？先梳理一个骨架</p><p>知识体系中，最重要的是骨架，脉络。有了骨架后，才方便填充细节。所以，先梳理下<code>主干流程</code>：</p><ol><li>从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</li><li>开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）</li><li>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</li><li>后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）</li><li>单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）</li><li>浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</li><li>CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）</li><li>JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</li><li>其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）</li></ol><p>梳理出主干骨架，然后就需要往骨架上填充细节内容。</p><h2 id="从浏览器接收url到开启网络请求线程"><a href="#从浏览器接收url到开启网络请求线程" class="headerlink" title="从浏览器接收url到开启网络请求线程"></a>从浏览器接收url到开启网络请求线程</h2><p>这一部分展开的内容是：<code>浏览器进程/线程模型</code>，<code>JS引擎的运行机制</code></p><h3 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h3><p>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）</p><p>进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p><ul><li>Browser进程：浏览器的主进程（负责协调、主控），只有一个</li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D绘制</li><li>浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li></ul><p><img src="http://cdn.flqin.com/p336-1.png" alt="多进程的浏览器"></p><h3 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" class="headerlink" title="多线程的浏览器内核"></a>多线程的浏览器内核</h3><p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程</p><ul><li>GUI线程</li><li>JS引擎线程</li><li>事件触发线程</li><li>定时器线程</li><li>网络请求线程</li></ul><p><img src="http://cdn.flqin.com/p336-2.png" alt="多线程的浏览器内核"></p><p>可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的，<a href="https://blog.flqin.com/359.html">JS引擎的运行机制查阅</a></p><h3 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h3><p>输入URL后，会进行解析（URL的本质就是统一资源定位符）</p><p>URL一般包括几大部分：</p><ul><li><code>protocol</code>，协议头，譬如有http，ftp等</li><li><code>host</code>，主机域名或IP地址</li><li><code>port</code>，端口号</li><li><code>path</code>，目录路径</li><li><code>query</code>，即查询参数</li><li><code>fragment</code>，即<code>#</code>后的hash值，一般用来定位到某个位置</li></ul><h3 id="网络请求都是单独的线程"><a href="#网络请求都是单独的线程" class="headerlink" title="网络请求都是单独的线程"></a>网络请求都是单独的线程</h3><p>每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载</p><p>因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）</p><h2 id="开启网络线程到发出一个完整的http请求"><a href="#开启网络线程到发出一个完整的http请求" class="headerlink" title="开启网络线程到发出一个完整的http请求"></a>开启网络线程到发出一个完整的http请求</h2><p>这一部分主要内容包括：<code>dns查询</code>，<code>tcp/ip请求构建</code>，<code>七层因特网协议栈（ISO）</code>等等</p><p>仍然是先梳理主干，有些详细的过程不展开（因为展开的话内容过多）</p><h3 id="DNS查询得到IP"><a href="#DNS查询得到IP" class="headerlink" title="DNS查询得到IP"></a>DNS查询得到IP</h3><p>如果输入的是域名，需要进行dns解析成IP，大致流程：</p><ul><li>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用<code>host</code></li><li>如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP</li></ul><p>注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）</p><p>而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑<code>dns-prefetch</code>优化</p><p>这一块可以深入展开，具体请去网上搜索，这里就不占篇幅了（网上可以看到很详细的解答）</p><h3 id="tcp-ip请求"><a href="#tcp-ip请求" class="headerlink" title="tcp/ip请求"></a>tcp/ip请求</h3><p><code>http</code>的本质就是<code>tcp/ip</code>请求，<code>tcp</code>将<code>http</code>长报文划分为短报文，通过<code>三次握手</code>与服务端建立连接，进行可靠传输。</p><p>然后，待到断开连接时，由于TCP连接是<code>全双工</code>的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个<code>FIN</code>来终止这个方向的连接。收到一个<code>FIN</code>只意味着这一方向上没有数据流动，一个TCP连接在收到一个<code>FIN</code>后仍能发送数据。首先进行关闭的一方将执行<code>主动关闭</code>，而另一方执行<code>被动关闭</code>。</p><h4 id="HTTP-与-TCP-IP-区别"><a href="#HTTP-与-TCP-IP-区别" class="headerlink" title="HTTP 与 TCP/IP 区别"></a>HTTP 与 TCP/IP 区别</h4><ul><li><code>TPC/IP</code> 协议是传输层协议，主要解决数据如何在网络中传输</li><li><code>HTTP</code> 是应用层协议，主要解决如何包装数据</li><li><code>WEB</code> 使用 <code>HTTP</code> 协议作应用层协议，以封装 <code>HTTP</code> 文本信息，然后使用 <code>TCP/IP</code> 做传输层协议将它发到网络上。</li></ul><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ul><li>SYN(synchronous建立联机)同步序列号</li><li>ACK(acknowledgement 确认)应答码</li><li>PSH(push传送)</li><li>FIN(finish结束)</li><li>RST(reset重置)</li><li>URG(urgent紧急)</li><li>Sequence number(seq 顺序号码) 对方上次的ack（首次发送时seq为系统随机生成）</li><li>Acknowledge number(ack 确认号码)对方的seq+1（无数据传输时） 或者 seq+L（报文数据的长度L）</li></ul><p><img src="http://cdn.flqin.com/p336-17.png" alt="TCP通信握手图解"></p><h4 id="三次握手的步骤"><a href="#三次握手的步骤" class="headerlink" title="三次握手的步骤"></a>三次握手的步骤</h4><ol><li>客户端发送<code>SYN包</code>（SYN=1,seq=x,x为随机数）的数据包到服务器，并进入<code>SYN_SEND</code>状态，等待服务器确认</li><li>服务器收到<code>SYN包</code>，发现SYN=1知客户端想请求连接，然后需要确认客户的<code>SYN包</code>（ACK number=x+1,ACK位码=1），同时自己也发送一个<code>SYN包</code>（seq=y），即<code>SYN+ACK包</code>，此时服务器进入<code>SYN_RECV</code>状态</li><li>客户端收到服务器的<code>SYN＋ACK包</code>，发现<code>ACK number=x+1，ACK位码=1</code>的话， 就向服务器发送<code>确认包ACK</code>(ACK number=y+1，ACK位码=1)，此包发送完毕，客户端和服务器进入<code>ESTABLISHED</code>状态，完成三次握手</li></ol><p>建立连接成功后，接下来就正式传输数据。</p><h4 id="四次挥手的步骤"><a href="#四次挥手的步骤" class="headerlink" title="四次挥手的步骤"></a>四次挥手的步骤</h4><ol><li>主动关闭方发送一个<code>FIN包</code>，用来关闭主动方到被动方的数据传送</li><li>被动方收到<code>FIN包</code>后，发送一个<code>ACK</code>给对方，确认序号为收到序号+1</li><li>被动方发送一个<code>FIN包</code>，用来关闭被动方到主动方的数据传送</li><li>主动方收到<code>FIN包</code>后，发送一个<code>ACK</code>给被动关闭方，确认序号为收到序号+1</li></ol><p>注：2，3次挥手不会一起发送，当<code>Server端</code>收到<code>FIN</code>报文时，很可能并不会立即关闭 <code>SOCKET</code>，所以只能先回复一个<code>ACK</code>报文，告诉<code>Client端</code>，”你发的<code>FIN报文</code>我收到了”。只有等到我<code>Server端</code>所有的报文都发送完了，我才能发送<code>FIN报文</code>，因此不能一起发送。</p><h4 id="tcp-ip的并发限制"><a href="#tcp-ip的并发限制" class="headerlink" title="tcp/ip的并发限制"></a>tcp/ip的并发限制</h4><p>在 <code>HTTP/1.0</code> 中，一个服务器在发送完一个 <code>HTTP</code> 响应后，会断开 <code>TCP</code> 链接。但是这样每次请求都会重新建立和断开 <code>TCP</code> 连接，代价过大。</p><p>所以 <code>HTTP/1.1</code> 就把 Connection 头写进标准(<code>Connection: keep-alive</code>)，并且默认开启<code>持久连接</code>，除非请求中写明 <code>Connection: close</code>，那么浏览器和服务器之间是会维持一段时间的 <code>TCP</code> 连接，不会一个请求结束就断掉，这样 <code>SSL</code> 的开销也可以避免。 在 <code>chrome</code> 浏览器里通过 <code>network</code> 标签 -&gt; <code>connection ID</code>表示<code>TCP连接</code>的重用</p><p>在<code>HTTP/1.1</code>中，单个 <code>TCP连接</code> 在同一时刻只能处理一个请求，顺序处理多个请求； 在 <code>HTTP2</code> 中由于 <code>Multiplexing</code> 特点的存在，多个 <code>HTTP 请求</code> 可以在同一个 <code>TCP 连接</code> 中并行进行。</p><p>浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等），Chrome 最多允许对同一个 Host 建立六个 TCP 连接。</p><h4 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h4><p><code>get</code>和<code>post</code>虽然本质都是<code>tcp/ip</code>，但两者除了在<code>http</code>层面外，在<code>tcp/ip</code>层面也有区别。</p><p><code>get</code>会产生一个<code>tcp</code>数据包，<code>post</code>两个</p><p>具体就是：</p><ul><li><code>get</code>请求时，浏览器会把<code>headers</code>和<code>data</code>一起发送出去，服务器响应200（返回数据），</li><li><code>post</code>请求时，浏览器先发送<code>headers</code>，服务器响应<code>100 continue</code>， 浏览器再发送<code>data</code>，服务器响应200（返回数据）。</li></ul><p>再说一点，这里的区别是<code>specification</code>（规范）层面，而不是<code>implementation</code>（对规范的实现）</p><h4 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP/UDP的区别"></a>TCP/UDP的区别</h4><ul><li>TCP是面向连接的，UDP是面向无连接的。TCP在通信之前必须通过三次握手机制与对方建立连接，而UDP通信不必与对方建立连接，不管对方的状态就直接把数据发送给对方</li><li>TCP连接过程耗时，UDP不耗时</li><li>TCP连接过程中出现的延时增加了被攻击的可能，安全性不高，而UDP不需要连接，安全性较高</li><li>TCP是可靠的，保证数据传输的正确性，不易丢包;UDP是不可靠的，易丢包</li><li>TCP传输速率较慢，实时性差，udp传输速率较快。tcp建立连接需要耗时，并且tcp首部信息太多，每次传输的有用信息较少，实时性差</li><li>TCP是流模式，udp是数据包模式。tcp只要不超过缓冲区的大小就可以连续发送数据到缓冲区上，接收端只要缓冲区上有数据就可以读取，可以一次读取多个数据包，而udp一次只能读取一个数据包，数据包之间独立</li></ul><h4 id="TCP可靠性的四大手段"><a href="#TCP可靠性的四大手段" class="headerlink" title="TCP可靠性的四大手段"></a>TCP可靠性的四大手段</h4><ul><li><strong>顺序编号</strong>：tcp在传输文件的时候，会将文件拆分为多个tcp数据包，每个装满的数据包大小大约在1k左右，tcp协议为保证可靠传输，会将这些数据包顺序编号</li><li><strong>确认机制</strong>：当数据包成功的被发送方发送给接收方，接收方会根据tcp协议反馈给发送方一个成功接收的ACK信号，信号中包含了当前包的序号</li><li><strong>超时重传</strong>：当发送方发送数据包给接收方时，会为每一个数据包设置一个定时器，当在设定的时间内，发送方仍没有收到接收方的ACK信号，会再次发送该数据包，直到收到接收方的ACK信号或者连接已断开</li><li><strong>校验信息</strong>：tcp首部校验信息较多，udp首部校验信息较少</li></ul><h3 id="七层因特网协议栈（ISO）"><a href="#七层因特网协议栈（ISO）" class="headerlink" title="七层因特网协议栈（ISO）"></a>七层因特网协议栈（ISO）</h3><p><img src="http://cdn.flqin.com/p336-16.jpeg" alt="五层因特网协议栈"></p><p><strong>从客户端发出http请求到服务器接收，中间会经过一系列的流程。</strong></p><p>简括就是：<strong>从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。</strong></p><p>当然，服务端的接收就是反过来的步骤。</p><p>七层因特网协议栈其实就是：</p><ol><li>应用层(http,ftp) 这一层为操作系统或网络应用程序提供访问网络服务的接口,如DNS解析成IP并发送http请求</li><li>表示层(Telnet,SNMP) 主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</li><li>会话层(dns,SMTP) 这一层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话，如控制登陆和注销过程。 (QoS)</li><li>传输层(tcp,udp) 建立tcp连接（三次握手）,数据的单位称为数据段（segment）（四层交换机）</li><li>网络层(IP,ARP) IP寻址，数据的单位称为数据包（packet）（路由器、三层交换机）</li><li>数据链路层(PPP) 将bit流封装成frame帧（网桥、二层交换机）</li><li>物理层(传输bit流) 物理传输（然后传输的时候通过双绞线、电磁波、光纤、中继器和集线器 &amp; RJ-45(网线接口)等各种介质）</li></ol><h2 id="从服务器接收到请求到对应后台接收到请求"><a href="#从服务器接收到请求到对应后台接收到请求" class="headerlink" title="从服务器接收到请求到对应后台接收到请求"></a>从服务器接收到请求到对应后台接收到请求</h2><p>服务端在接收到请求时，内部会进行很多的处理</p><p>这里由于不是专业的后端分析，所以只是简单的介绍下，不深入</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡</p><p>当然了，负载均衡不止这一种实现方式，这里不深入…</p><p>简单的说：<strong>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户</strong></p><h3 id="后台的处理"><a href="#后台的处理" class="headerlink" title="后台的处理"></a>后台的处理</h3><p>一般后台都是部署到容器中的，所以一般为：</p><ul><li>先是容器接受到请求（如tomcat容器）</li><li>然后对应容器中的后台程序接收到请求（如java程序）</li><li>然后就是后台会有自己的统一处理，处理完后响应响应结果</li></ul><p>概括下：</p><ul><li>一般有的后端是有统一的验证的，如安全拦截，跨域验证</li><li>如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）</li><li>然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）</li><li>等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）</li><li>然后就是将这个包从后端发送到前端，完成交互</li></ul><h2 id="后台和前台的http交互"><a href="#后台和前台的http交互" class="headerlink" title="后台和前台的http交互"></a>后台和前台的http交互</h2><p>前后端交互时，http报文作为信息的载体，所以http是一块很重要的内容，这一部分重点介绍它</p><h3 id="http报文结构"><a href="#http报文结构" class="headerlink" title="http报文结构"></a>http报文结构</h3><p>报文一般包括了：<code>通用头部(General)</code>，<code>请求/响应头部</code>，<code>请求/响应体</code></p><h4 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h4><p>这也是开发人员见过的最多的信息，包括如下：</p><ul><li><code>Request Url</code>: 请求的web服务器地址</li><li><code>Request Method</code>: 请求方式（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）</li><li><code>Status Code</code>: 请求的返回状态码，如200代表成功</li><li><code>Remote Address</code>: 请求的远程服务器地址（会转为IP）</li><li><code>Referrer-Policy</code>: 控制请求头中referrer的内容<a href="https://juejin.im/post/5cd81b59518825686a06fd05" target="_blank" rel="noopener">查阅</a></li></ul><p>譬如，在跨域拒绝时，可能是<code>method</code>为<code>options</code>，状态码为<code>404/405</code>等（当然，实际上可能的组合有很多）</p><p>其中，<code>Method</code>的话一般分为两批次：</p><ul><li><code>HTTP1.0</code>定义了三种请求方法：<code>GET, POST 和 HEAD方法</code>。以及几种<code>Additional Request Methods：PUT、DELETE、LINK、UNLINK</code></li><li><code>HTTP1.1</code>定义了八种请求方法：<code>GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</code></li></ul><p>这里面最常用到的就是状态码，很多时候都是通过状态码来判断，如（列举几个最常见的）：</p><ul><li><code>200</code>——表明该请求被成功地完成，所请求的资源发送回客户端</li><li><code>304</code>——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存</li><li><code>400</code>——客户端请求有错（譬如可以是安全模块拦截）</li><li><code>401</code>——请求未经授权</li><li><code>403</code>——禁止访问（譬如可以是未登录时禁止）</li><li><code>404</code>——资源未找到</li><li><code>500</code>——服务器内部错误</li><li><code>503</code>——服务不可用</li></ul><p>再列举下大致不同范围状态的意义</p><ul><li><code>1xx</code>——指示信息，表示请求已接收，继续处理</li><li><code>2xx</code>——成功，表示请求已被成功接收、理解、接受</li><li><code>3xx</code>——重定向，要完成请求必须进行更进一步的操作</li><li><code>4xx</code>——客户端错误，请求有语法错误或请求无法实现</li><li><code>5xx</code>——服务器端错误，服务器未能实现合法的请求</li></ul><p><img src="http://cdn.flqin.com/p336-3.png" alt="http status"></p><p>总之，当请求出错时，状态码能帮助快速定位问题，完整版本的状态可以自行去互联网搜索</p><h4 id="请求-响应头部"><a href="#请求-响应头部" class="headerlink" title="请求/响应头部"></a>请求/响应头部</h4><p>请求和响应头部也是分析时常用到的</p><p>常用的请求头部（部分）：</p><ul><li><code>Accept</code>: 接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）</li><li><code>Accept-Encoding</code>：浏览器支持的压缩类型,如gzip等,超出类型不能接收</li><li><code>Content-Type</code>：客户端发送出去实体内容的类型</li><li><code>Cache-Control</code>: 指定请求和响应遵循的缓存机制，如no-cache</li><li><code>If-Modified-Since</code>：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中</li><li><code>Expires</code>：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间</li><li><code>Max-age</code>：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中</li><li><code>If-None-Match</code>：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中</li><li><code>Cookie</code>: 有cookie并且同域访问时会自动带上</li><li><code>Connection</code>: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive</li><li><code>Host</code>：请求的服务器URL</li><li><code>Origin</code>：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私</li><li><code>Referer</code>：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)</li><li><code>User-Agent</code>：用户客户端的一些必要信息，如UA头部等</li></ul><p>常用的响应头部（部分）：</p><ul><li><code>Access-Control-Allow-Headers</code>: 服务器端允许的请求Headers</li><li><code>Access-Control-Allow-Methods</code>: 服务器端允许的请求方法</li><li><code>Access-Control-Allow-Origin</code>: 服务器端允许的请求Origin头部（譬如为*）</li><li><code>Content-Type</code>：服务端返回的实体内容的类型</li><li><code>Date</code>：数据从服务器发送的时间</li><li><code>Cache-Control</code>：告诉浏览器或其他客户，什么环境可以安全的缓存文档</li><li><code>Last-Modified</code>：请求资源的最后修改时间</li><li><code>Expires</code>：应该在什么时候认为文档已经过期,从而不再缓存它</li><li><code>Max-age</code>：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效</li><li><code>ETag</code>：请求变量的实体标签的当前值</li><li><code>Set-Cookie</code>：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端</li><li><code>Keep-Alive</code>：如果客户端有keep-alive，服务端也会有响应（如timeout=38）</li><li><code>Server</code>：服务器的一些相关信息</li></ul><p>一般来说，请求头部和响应头部是匹配分析的。</p><p>譬如，请求头部的<code>Accept</code>要和响应头部的<code>Content-Type</code>匹配，否则会报错</p><p>譬如，跨域请求时，请求头部的<code>Origin</code>要匹配响应头部的<code>Access-Control-Allow-Origin</code>，否则会报跨域错误</p><p>譬如，在使用缓存时，请求头部的<code>If-Modified-Since、If-None-Match</code>分别和响应头部的<code>Last-Modified、ETag</code>对应</p><h4 id="请求-响应实体"><a href="#请求-响应实体" class="headerlink" title="请求/响应实体"></a>请求/响应实体</h4><p><code>http</code>请求时，除了头部，还有消息实体，一般来说:</p><ul><li><p>请求实体中会将一些需要的参数都放入进入（用于post请求）如实体中可以放参数的序列化形式（a=1&amp;b=2这种），或者直接放表单对象（Form Data对象，上传时可以夹杂参数以及文件）等等</p></li><li><p>响应实体中就是放服务端需要传给客户端的内容，一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。</p></li></ul><h4 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h4><p>CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在</p><p>请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔</p><p>一般来说（分隔符类别）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CRLF-&gt;Windows-style</span><br><span class="line">LF-&gt;Unix Style</span><br><span class="line">CR-&gt;Mac Style</span><br></pre></td></tr></table></figure><p>如下图是对某请求的http报文结构的简要分析:</p><p><img src="http://cdn.flqin.com/p336-4.png" alt="http报文结构"></p><h3 id="cookie以及优化"><a href="#cookie以及优化" class="headerlink" title="cookie以及优化"></a>cookie以及优化</h3><p><code>cookie</code>是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的<code>session</code>使用。</p><p>场景如下（简述）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在登陆页面，用户登陆了</span><br><span class="line">此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）</span><br><span class="line">然后会有一个sessionid（相当于是服务端的这个session对应的key）</span><br><span class="line">然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx</span><br><span class="line">然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。</span><br></pre></td></tr></table></figure><p>上述就是<code>cookie</code>的常用场景简述（当然了，实际情况下得考虑更多因素）</p><p>一般来说，<code>cookie</code>是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在<code>cookie</code>中设置<code>httponly</code>（这样就无法通过js操作了），另外可以考虑<code>rsa</code>等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全）</p><p>另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。</p><p>譬如以下场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端在域名A下有cookie（这个可以是登陆时由服务端写入的）</span><br><span class="line">然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有<span class="number">20</span>个静态资源）</span><br><span class="line">此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie</span><br><span class="line">也就是说，这<span class="number">20</span>个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证</span><br><span class="line">此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）</span><br></pre></td></tr></table></figure><p>当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是：</p><ul><li>将静态资源分组，分别放到不同的域名下（如<code>static.base.com</code>）</li><li>而<code>page.base.com</code>（页面所在域名）下请求时，是不会带上<code>static.base.com</code>域名的<code>cookie</code>的，所以就避免了浪费</li></ul><p>说到了多域名拆分，这里再提一个问题，那就是：</p><ul><li>在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）</li><li>此时就需要用到一种优化方案：<code>dns-prefetch</code>（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）</li></ul><p>关于cookie的交互，可以看下图总结:</p><p><img src="http://cdn.flqin.com/p336-5.png" alt="cookie交互"></p><h3 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h3><p>首先，明确<code>gzip</code>是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持）， 而且<code>gzip</code>压缩效率很好（高达70%左右）,一般是由<code>apache、tomcat</code>等<code>web</code>服务器开启</p><p>一般只需要在服务器上开启了<code>gzip</code>压缩，然后之后的请求就都是基于<code>gzip</code>压缩格式的，当然服务器除了<code>gzip</code>外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）</p><h3 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h3><p>首先看<code>tcp/ip</code>层面的定义：</p><ul><li>长连接：一个<code>tcp/ip</code>连接上可以连续发送多个数据包，在<code>tcp连接</code>保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li><li>短连接：通信双方有数据交互时，就建立一个<code>tcp连接</code>，数据发送完成后，则断开此<code>tcp连接</code></li></ul><p>然后在http层面：</p><ul><li><code>http1.0</code>中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li><li><code>http1.1</code>起，默认使用长连接，使用长连接会有这一行<code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输<code>http</code>的<code>tcp连接</code>不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li></ul><p>注意： <strong>keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效</strong></p><h3 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h3><p><code>http2.0</code>不是<code>https</code>，它相当于是<code>http</code>的下一代规范（譬如<code>https</code>的请求可以是<code>http2.0</code>规范的）</p><p>然后简述下<code>http2.0</code>与<code>http1.1</code>的显著不同点：</p><ul><li><code>http1.1</code>中，每请求一个资源，都是需要开启一个<code>tcp/ip</code>连接的，所以对应的结果是，每一个资源对应一个<code>tcp/ip</code>请求，由于<code>tcp/ip</code>本身有并发数限制，所以当资源一多，速度就显著慢下来</li><li><code>http2.0</code>中，一个<code>tcp/ip</code>请求可以请求多个资源，也就是说，只要一次<code>tcp/ip</code>请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li></ul><p>所以，如果<code>http2.0</code>全面应用，很多<code>http1.1</code>中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）</p><p>然后简述下<code>http2.0</code>的一些特性：</p><ul><li><strong>多路复用</strong>（即一个<code>tcp/ip</code>连接可以请求多个资源）</li><li><strong>首部压缩</strong>（<code>http</code>头部压缩，减少体积）</li><li><strong>二进制分帧</strong>（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li><li><strong>服务器端推送</strong>（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li><li><strong>请求优先级</strong>（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</li></ul><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p><code>https</code>就是安全版本的<code>http</code>，譬如一些支付等操作基本都是基于<code>https</code>的，因为<code>http</code>请求的安全系数太低了。</p><p>简单来看，<code>https</code>与<code>http</code>的区别就是： 在请求前，会建立<code>ssl链接</code>，确保接下来的通信都是加密的，无法被轻易截取分析。</p><p>一般来说，如果要将网站升级成<code>https</code>，需要后端支持（后端需要申请<code>CA证书</code>等），然后<code>https</code>的开销也比<code>http</code>要大（因为需要额外建立安全链接以及加密等），所以一般来说<code>http2.0</code>配合<code>https</code>的体验更佳（因为<code>http2.0</code>更快了）</p><h4 id="https-握手"><a href="#https-握手" class="headerlink" title="https 握手"></a>https 握手</h4><p>一般来说，主要关注的就是<code>SSL/TLS</code>的握手流程，如下（简述）：</p><ol><li>浏览器发起https请求建立<code>SSL链接</code>，并向服务端发送一个随机数<code>Client random</code>和客户端支持的<code>加密方法</code>（非对称加密算法：<code>RSA，DSA/DSS</code> 对称加密算法：<code>AES，RC4，3DES HASH</code> 算法：<code>MD5，SHA1，SHA256</code>），比如<code>RSA加密</code>，此时是明文传输。</li><li>服务端从中选出一组<code>加密算法</code>与<code>Hash算法</code>，回复一个随机数<code>Server random</code>，并将自己的身份信息以<code>CA证书</code>的形式发回给浏览器 （证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</li><li>浏览器收到服务端的证书后<ul><li><strong>TLS来验证证书的合法性</strong>（颁发机构是否合法，证书中包含的网址是否和正在访问的一样，过期时间等），如果证书信任，则浏览器会显示一个小锁头，否则会弹出一个警告框，提示证书存在问题。</li><li>用户接收证书后（不管信不信任），浏览会生产新的随机数<code>Premaster secret</code>，然后证书中的公钥以及指定的加密方法加密<code>Premaster secret</code>，发送给服务器。</li><li>利用<code>Client random</code>、<code>Server random</code>和<code>Premaster secret</code>通过一定的算法生成HTTP链接数据传输的对称加密key-<code>session key</code></li><li>使用约定好的<code>HASH算法</code>计算握手消息，并使用生成的<code>session key</code>对消息进行加密，最后将之前生成的所有信息发送给服务端。</li></ul></li><li>服务端收到浏览器的回复<ul><li>利用已知的加解密方式与自己的私钥进行解密，获取<code>Premaster secret</code></li><li>和浏览器相同规则生成<code>session key</code></li><li>使用<code>session key</code>解密浏览器发来的握手消息，并验证<code>Hash</code>是否与浏览器发来的一致</li><li>使用<code>session key</code>加密一段握手消息，发送给浏览器</li></ul></li><li>浏览器解密并计算握手消息的<code>HASH</code>，如果与服务端发来的<code>HASH</code>一致，此时握手过程结束.</li></ol><p><strong>之后所有的https通信数据将由之前浏览器生成的session key并利用对称加密算法进行加密</strong></p><p>这里放一张图（来源：阮一峰-图解SSL/TLS协议）</p><p><img src="http://cdn.flqin.com/p336-6.png" alt="图解SSL/TLS协议"></p><h4 id="https加密是在传输层"><a href="#https加密是在传输层" class="headerlink" title="https加密是在传输层"></a>https加密是在传输层</h4><p><code>https</code> 报文在被包装成 <code>tcp</code> 报文的时候完成加密的过程，无论是 <code>https</code> 的 <code>header</code> 域也好，<code>body</code> 域也罢都是会被加密的。</p><p>当使用 <code>tcpdump</code> 或者 <code>wireshark</code> 之类的 <code>tcp</code> 层工具抓包，获取是加密的内容，而如果用应用层抓包，使用 <code>Charels(Mac)、Fildder(Windows)</code> 抓包工具，那当然看到是明文的</p><h4 id="CA-证书是什么"><a href="#CA-证书是什么" class="headerlink" title="CA 证书是什么"></a>CA 证书是什么</h4><p><code>CA（Certificate Authority）</code> 是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任的、认可的。</p><p><code>CA</code> 证书，就是 <code>CA</code> 颁发的证书，可用于验证网站是否可信（针对 <code>HTTPS</code>）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。</p><h3 id="HTTPS-和-HTTP-的区别"><a href="#HTTPS-和-HTTP-的区别" class="headerlink" title="HTTPS 和 HTTP 的区别"></a>HTTPS 和 HTTP 的区别</h3><ol><li><code>https</code> 协议需要到 <code>ca</code> 申请证书或自制证书。</li><li><code>http</code> 的信息是明文传输，<code>https</code> 则是具有安全性的 <code>ssl</code> 加密。</li><li><code>http</code> 是直接与 <code>TCP</code> 进行数据传输，而 <code>https</code> 是经过一层 <code>SSL</code>（OSI 表示层），用的端口也不一样，前者是 <code>80</code>（需要国内备案），后者是 <code>443</code>。</li><li><code>http</code> 的连接很简单，是无状态的；<code>https</code> 协议是由 <code>SSL+HTTP</code> 协议构建的可进行加密传输、身份认证的网络协议，比 <code>http</code> 协议安全。</li><li><code>https</code> 协议握手阶段比较费时，会使页面的加载时间延长近50%，增加 10% 到 20% 的耗电。</li><li><code>https</code> 连接缓存不如 <code>http</code> 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响。</li><li>谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 <code>HTTP</code> 网站，采用 <code>HTTPS</code> 加密的网站在搜索结果中的排名将会更高”。</li></ol><h2 id="单独拎出来的缓存问题，http的缓存"><a href="#单独拎出来的缓存问题，http的缓存" class="headerlink" title="单独拎出来的缓存问题，http的缓存"></a>单独拎出来的缓存问题，http的缓存</h2><p>前后端的<code>http交互</code>中，使用缓存能很大程度上的提升效率，而且基本上对性能有要求的前端项目都是必用缓存的</p><h3 id="强缓存与弱缓存"><a href="#强缓存与弱缓存" class="headerlink" title="强缓存与弱缓存"></a>强缓存与弱缓存</h3><p>缓存可以简单的划分成两种类型：<code>强缓存（200 from cache）</code>与<code>协商缓存（304）</code></p><p>区别简述如下：</p><ul><li><code>强缓存（200 from cache）</code>时，浏览器如果判断本地缓存未过期，就直接使用，无需发起<code>http请求</code></li><li><code>协商缓存（304）</code>时，浏览器会向服务端发起<code>http请求</code>，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存</li></ul><p>对于协商缓存，使用<code>Ctrl + F5</code>强制刷新可以使得缓存无效</p><p>但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）</p><h3 id="缓存头部简述"><a href="#缓存头部简述" class="headerlink" title="缓存头部简述"></a>缓存头部简述</h3><p>上述提到了强缓存和协商缓存，那它们是怎么区分的呢？</p><p>答案是通过不同的http头部控制</p><p>先看下这几个头部：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match/E-tag、If-Modified-Since/Last-Modified、Cache-Control/Max-Age、Pragma/Expires</span><br></pre></td></tr></table></figure><p>这些就是缓存中常用到的头部，这里不展开。仅列举下大致使用。</p><p>属于强缓存控制的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    （http1.1）Cache-Control/Max-Age</span><br><span class="line">    （http1.0）Pragma/Expires</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">注意：`Max-Age`不是一个头部，它是`Cache-Control`头部的值</span><br><span class="line"></span><br><span class="line">属于协商缓存控制的：</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">    （http1.1）If-None-Match/E-tag</span><br><span class="line">    （http1.0）If-Modified-Since/Last-Modified</span><br></pre></td></tr></table></figure><p>可以看到，上述有提到<code>http1.1</code>和<code>http1.0</code>，这些不同的头部是属于不同<code>http</code>时期的</p><p>再提一点，其实HTML页面中也有一个<code>meta标签</code>可以控制缓存方案:<code>Pragma</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">"Pragma"</span> <span class="attr">CONTENT</span>=<span class="string">"no-cache"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过，这种方案还是比较少用到，因为支持情况不佳，譬如缓存代理服务器肯定不支持，所以不推荐</p><h3 id="头部的区别"><a href="#头部的区别" class="headerlink" title="头部的区别"></a>头部的区别</h3><p>首先明确，<code>http</code>的发展是从<code>http1.0</code>到<code>http1.1</code></p><p>而在<code>http1.1</code>中，出了一些新内容，弥补了<code>http1.0</code>的不足。</p><h3 id="http1-0中的缓存控制"><a href="#http1-0中的缓存控制" class="headerlink" title="http1.0中的缓存控制"></a>http1.0中的缓存控制</h3><ul><li><strong>Pragma</strong>：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）</li><li><strong>Expires</strong>：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41</li><li><strong>If-Modified-Since/Last-Modified</strong>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内</li></ul><h3 id="http1-1中的缓存控制"><a href="#http1-1中的缓存控制" class="headerlink" title="http1.1中的缓存控制"></a>http1.1中的缓存控制</h3><ul><li><strong>Cache-Control</strong>：缓存控制头部，有no-cache、max-age等多种取值</li><li><strong>Max-Age</strong>：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算</li><li><strong>If-None-Match/E-tag</strong>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</li></ul><h3 id="Max-Age相比Expires"><a href="#Max-Age相比Expires" class="headerlink" title="Max-Age相比Expires"></a>Max-Age相比Expires</h3><ul><li><p><strong>Expires</strong>: 使用的是服务器端的时间，但是有时候会有这样一种情况-客户端时间和服务端不同步，那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期，所以一般<code>http1.1</code>后不推荐使用<code>Expires</code></p></li><li><p><strong>Max-Age</strong>: 使用的是客户端本地时间的计算，因此不会有这个问题，因此推荐使用<code>Max-Age</code>。</p></li></ul><p>注意，如果同时启用了<code>Cache-Control</code>与<code>Expires</code>，<code>Cache-Control</code>优先级高。</p><h3 id="E-tag相比Last-Modified"><a href="#E-tag相比Last-Modified" class="headerlink" title="E-tag相比Last-Modified"></a>E-tag相比Last-Modified</h3><ul><li><p><strong>Last-Modified</strong>：表明服务端的文件最后何时改变的,它有一个缺陷就是只能精确到1s，而且有的服务端的文件会周期性的改变，导致缓存失效</p></li><li><p><strong>E-tag</strong>：是一种指纹机制，代表文件相关指纹，只有文件变才会变，也只要文件变就会变，也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了</p></li></ul><p>如果同时带有<code>E-tag</code>和<code>Last-Modified</code>，服务端会优先检查<code>E-tag</code></p><p>各大缓存头部的整体关系如下图:</p><p><img src="http://cdn.flqin.com/p336-7.png" alt="缓存"></p><h2 id="解析页面流程"><a href="#解析页面流程" class="headerlink" title="解析页面流程"></a>解析页面流程</h2><p>前面有提到<code>http交互</code>，那么接下来就是浏览器获取到<code>html</code>，然后解析，渲染</p><h3 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h3><p><code>浏览器内核</code>拿到内容后，渲染步骤大致可以分为以下几步：</p><ol><li>解析HTML，构建DOM树</li><li>解析CSS，生成CSS规则树</li><li>合并DOM树和CSS规则树，生成render树</li><li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li><li>绘制render树（paint），绘制页面像素信息</li><li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</li></ol><p>如下图：</p><p><img src="http://cdn.flqin.com/p336-8.png" alt="页面渲染"></p><h3 id="HTML解析，构建DOM树"><a href="#HTML解析，构建DOM树" class="headerlink" title="HTML解析，构建DOM树"></a>HTML解析，构建DOM树</h3><p>整个渲染步骤中，HTML解析是第一步。</p><p>简单的理解，这一步的流程是这样的：<strong>浏览器解析HTML，构建DOM树。</strong></p><p>解析HTML到构建出DOM当然过程可以简述如下：<code>Bytes → characters → tokens → nodes → DOM</code></p><p>譬如假设有这样一个HTML页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器的处理如下：</p><p><img src="http://cdn.flqin.com/p336-9.png" alt="构建DOM树1"></p><p>列举其中的一些重点过程：</p><ul><li><strong>Conversion转换</strong>：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</li><li><strong>Tokenizing分词</strong>：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</li><li><strong>Lexing词法分析</strong>：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</li><li><strong>DOM构建</strong>：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样 例如：body对象的父节点就是HTML对象，然后段落p对象的父节点就是body对象</li></ul><p>最后的DOM树如下：</p><p><img src="http://cdn.flqin.com/p336-10.png" alt="构建DOM树2"></p><h3 id="生成CSS规则树"><a href="#生成CSS规则树" class="headerlink" title="生成CSS规则树"></a>生成CSS规则树</h3><p>同理，CSS规则树的生成也是类似。简述为：<code>Bytes → characters → tokens → nodes → CSSOM</code></p><p>譬如style.css内容如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold &#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; <span class="attribute">display</span>: none &#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">float</span>: right &#125;</span><br></pre></td></tr></table></figure><p>那么最终的CSSOM树就是：</p><p><img src="http://cdn.flqin.com/p336-11.png" alt="CSSOM树"></p><h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><p>当<code>DOM树</code>和<code>CSSOM树</code>都有了后，就要开始构建渲染树了，一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应，因为有一些不可见的<code>DOM元素</code>不会插入到渲染树中，如<code>head</code>这种不可见的标签或者<code>display: none</code>等。</p><p>整体来说可以看图：</p><p><img src="http://cdn.flqin.com/p336-12.png" alt="构建渲染树"></p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>有了render树，接下来就是开始渲染，基本流程如下：</p><p><img src="http://cdn.flqin.com/p336-13.jpg" alt="渲染"></p><p>图中重要的四个步骤就是：</p><ol><li>计算CSS样式</li><li>构建渲染树</li><li><strong>布局</strong>，主要定位坐标和大小，是否换行，各种<code>position,overflow,z-index</code>属性</li><li><strong>绘制</strong>，将图像绘制出来</li></ol><p>然后，图中的线与箭头代表通过js动态修改了<code>DOM</code>或<code>CSS</code>，导致了<code>重新布局（Layout）</code>或<code>渲染（Repaint）</code></p><p>这里<code>Layout</code>和<code>Repaint</code>的概念是有区别的：</p><ul><li><code>Layout</code>，也称为<code>Reflow(重排)</code>，即<code>回流</code>。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树<ul><li>以下会触发回流：<ul><li>盒子模型相关属性会触发重布局(<code>width,height,padding,margin,display,border-width,border,min-height</code>)</li><li>定位属性及浮动也会触发重布局(<code>top,bottom,left,right,position,float,clear</code>)</li><li>改变节点内部文字结构也会触发重布局(<code>text-align,overflow-y,font-weight,overflow,font-family,line-height,vertival-align,white-space,font-size</code>)</li><li>获取某些属性也会引发回流，很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括：<ul><li><code>offset(Top/Left/Width/Height)</code></li><li><code>scroll(Top/Left/Width/Height)</code></li><li><code>cilent(Top/Left/Width/Height)</code></li><li><code>width,height</code></li><li>调用了<code>getComputedStyle()</code>或者IE的<code>currentStyle</code></li></ul></li></ul></li></ul></li><li><code>Repaint</code>，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（<code>color,border-style,border-radius,visibility,text-decoration,background,background-image,background-position,background-repeat,background-size,outline-color,outline,outline-style,outline-width,box-shadow</code>），此时只需要应用新样式绘制这个元素就可以了</li></ul><p><code>回流</code>一定伴随着<code>重绘</code>，<code>重绘</code>却可以单独出现。<code>回流</code>的成本开销要高于<code>重绘</code>，而且一个节点的<code>回流</code>往往回导致子节点以及同级节点的<code>回流</code>， 所以优化方案中一般都包括，尽量避免<code>回流</code>。</p><p>本身浏览器通过<code>队列化修改</code>和<code>批量显示</code>优化重排版过程。其他一般会有一些<strong>优化方案</strong>，如：</p><ul><li>减少逐项更改dom样式，最好一次性更改<code>style</code>，或者将样式定义为<code>class</code>并一次性更新</li><li>把<code>DOM</code>离线后修改<ul><li>使用<code>documentFragment</code> 对象在内存里操作<code>DOM</code></li><li>先把<code>DOM</code>给<code>display:none</code>(有一次<code>reflow</code>)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来</li><li><code>clone</code>一个<code>DOM</code>结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下</li></ul></li><li>不要把<code>DOM</code>结点的属性值(<code>offset</code>等)放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性,无法避免则将它们缓存到变量</li><li>尽可能的修改层级比较低的<code>DOM</code>。当然，改变层级比较底的<code>DOM</code>有可能会造成大面积的<code>reflow</code>，但是也可能影响范围很小</li><li>将复杂的元素绝对定位(<code>absolute</code>)或固定定位(<code>fixed</code>)，使得它脱离文档流，否则回流代价会很高</li><li>千万不要使用<code>table</code>布局。因为可能很小的一个小改动会造成整个<code>table</code>的重新布局</li></ul><p>再来看一个示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.body.style;</span><br><span class="line"></span><br><span class="line">s.padding = <span class="string">"2px"</span>; <span class="comment">// 回流+重绘</span></span><br><span class="line">s.border = <span class="string">"1px solid red"</span>; <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line">s.color = <span class="string">"blue"</span>; <span class="comment">// 再一次重绘</span></span><br><span class="line">s.backgroundColor = <span class="string">"#ccc"</span>; <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.fontSize = <span class="string">"14px"</span>; <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line"><span class="comment">// 添加node，再一次 回流+重绘</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'abc!'</span>));</span><br></pre></td></tr></table></figure><h3 id="了解层"><a href="#了解层" class="headerlink" title="了解层"></a>了解层</h3><p>在第6步：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.</span> 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</span><br></pre></td></tr></table></figure><h4 id="什么是-composite"><a href="#什么是-composite" class="headerlink" title="什么是 composite"></a>什么是 composite</h4><p>在 <code>DOM</code> 树中每个节点都会对应一个 <code>LayoutObject</code>，当他们的 <code>LayoutObject</code> 处于相同的坐标空间时，就会形成一个 <code>RenderLayers</code> ，也就是渲染层。<code>RenderLayers</code> 来保证页面元素以正确的顺序合成，这时候就会出现层合成（<code>composite</code>），从而正确处理透明元素和重叠元素的显示。</p><p><code>GPU</code>中，各个<code>复合图层</code>是单独绘制的，所以互不影响，可以通过<strong>硬件加速</strong>的方式，声明一个新的<code>复合图层</code>，它会单独分配资源。复合层是独立的，所以一般做动画推荐使用硬件加速。</p><p>调试方式 ：</p><ul><li><code>Chrome源码调试 -&gt; More Tools -&gt; Layers</code></li><li><code>Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders</code>,黄色的就是复合图层信息</li></ul><h4 id="RenderLayers-与-GraphicsLayers"><a href="#RenderLayers-与-GraphicsLayers" class="headerlink" title="RenderLayers 与 GraphicsLayers"></a>RenderLayers 与 GraphicsLayers</h4><p><img src="http://cdn.flqin.com/p336-18.png" alt="RenderLayers 与 GraphicsLayers"></p><p>chrome中：</p><ul><li><code>RenderLayers</code> 渲染层，这是负责对应 <code>DOM 子树</code></li><li><code>GraphicsLayers</code> 图形层，这是负责对应 <code>RenderLayers 子树</code></li></ul><p><code>RenderObjects</code> 保持了树结构，他通过向一个绘图上下文（<code>GraphicsContext</code>）发出必要的绘制调用来绘制 <code>nodes</code>。</p><p>每个 <code>GraphicsLayer</code> 都有一个 <code>GraphicsContext</code>，<code>GraphicsContext</code> 会负责输出该层的<code>位图</code>，<code>位图</code>是存储在共享内存中，作为纹理上传到 <code>GPU</code> 中，最后由 <code>GPU</code> 将多个位图进行合成，然后 <code>draw</code> 到屏幕上，此时，我们的页面也就展现到了屏幕上。</p><h4 id="影响-composite-因素"><a href="#影响-composite-因素" class="headerlink" title="影响 composite 因素"></a>影响 composite 因素</h4><p>以下情形浏览器会主动将渲染层提至合成层(硬件加速)：</p><ul><li>z-index</li><li>3D 或透视变换(perspective transform) CSS 属性</li><li>video, canvas, iframe, Flash等元素</li><li>opacity属性/过渡动画</li><li>position: fixed</li><li>will-change</li><li>filter</li><li>backface-visibility</li><li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li><li>元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li></ul><p>使用硬件加速时，尽可能的使用<strong>z-index</strong>，防止浏览器默认给后续的元素创建复合层渲染.因为在webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，<br>那么在这个元素的后面其它元素会默认变为复合层渲染，如果处理不当会极大的影响性能，即如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层。</p><h4 id="复合图层的优劣"><a href="#复合图层的优劣" class="headerlink" title="复合图层的优劣"></a>复合图层的优劣</h4><ul><li>优：合成层的位图，会交由 <code>GPU</code> 合成，比 <code>CPU</code> 处理要快</li><li>优：当需要 <code>repaint</code> 时，只需要 <code>repaint</code> 本身，不会影响到其他的层</li><li>优：元素提升为合成层后，<code>transform</code> 和 <code>opacity</code> 才不会触发 <code>paint</code>，如果不是合成层，则其依然会触发 <code>paint</code></li><li>劣：大量的合成层，这样会占用很多无辜的 <code>CPU</code> 和内存资源，严重影响了页面的性能</li><li>劣：层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象</li></ul><p>如果你已经把一个元素放到一个新的合成层里，那么可以使用 Timeline 来确认这么做是否真的改进了渲染性能。别盲目提升合成层，一定要分析其实际性能表现。</p><p>在内存资源有限的设备上，合成层带来的性能改善，可能远远赶不上过多合成层开销给页面性能带来的负面影响。同时，由于每个渲染层的纹理都需要上传到 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。</p><h3 id="Chrome中的调试"><a href="#Chrome中的调试" class="headerlink" title="Chrome中的调试"></a>Chrome中的调试</h3><p>Chrome的开发者工具中，Performance中可以看到详细的渲染过程：</p><p><img src="http://cdn.flqin.com/p336-14.png" alt="Chrome中的调试"></p><h3 id="资源外链的下载"><a href="#资源外链的下载" class="headerlink" title="资源外链的下载"></a>资源外链的下载</h3><p>上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了</p><p>简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：</p><ul><li>CSS样式资源</li><li>JS脚本资源</li><li>img图片类资源</li></ul><h4 id="遇到外链时的处理"><a href="#遇到外链时的处理" class="headerlink" title="遇到外链时的处理"></a>遇到外链时的处理</h4><p>当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）</p><h4 id="遇到CSS样式资源"><a href="#遇到CSS样式资源" class="headerlink" title="遇到CSS样式资源"></a>遇到CSS样式资源</h4><p>CSS资源的处理有几个特点：</p><ul><li>CSS下载时异步，不会阻塞浏览器构建<code>DOM树</code></li><li>但是会阻塞<code>渲染</code>，也就是在<code>构建render</code>时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</li><li>有例外，<code>media query</code>声明的CSS是不会阻塞渲染的</li></ul><h4 id="遇到JS脚本资源"><a href="#遇到JS脚本资源" class="headerlink" title="遇到JS脚本资源"></a>遇到JS脚本资源</h4><p>JS脚本资源的处理有几个特点：</p><ul><li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML</li><li>浏览器的优化在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li><li><code>defer</code>与<code>async</code>，普通的脚本是会阻塞浏览器解析的，但是可以加上<code>defer</code>或<code>async</code>属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li></ul><p>注意，<code>defer</code>和<code>async</code>是有区别的： <strong>defer是延迟执行，而async是异步执行。</strong></p><p>简单的说：</p><ul><li><code>async</code>是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在<code>onload</code>前，但不确定在<code>DOMContentLoaded</code>事件的前或后</li><li><code>defer</code>是延迟执行，在浏览器看起来的效果像是将脚本放在了body后面一样（虽然按规范应该是在<code>DOMContentLoaded</code>事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li></ul><h4 id="遇到img图片类资源"><a href="#遇到img图片类资源" class="headerlink" title="遇到img图片类资源"></a>遇到img图片类资源</h4><p>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</p><h3 id="loaded和domcontentloaded"><a href="#loaded和domcontentloaded" class="headerlink" title="loaded和domcontentloaded"></a>loaded和domcontentloaded</h3><p>简单的对比：</p><ul><li><code>DOMContentLoaded</code> 事件触发时，仅当<code>DOM加载</code>完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)</li><li><code>load</code> 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li></ul><h2 id="CSS的可视化格式模型"><a href="#CSS的可视化格式模型" class="headerlink" title="CSS的可视化格式模型"></a>CSS的可视化格式模型</h2><p>前面提到了整体的渲染概念，但实际上文档树中的元素是按什么渲染规则渲染的，是可以进一步展开的</p><p>先了解：</p><ul><li>CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）</li><li>然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局及相互作用</li></ul><p>说到底： <strong>CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树</strong></p><p>关键字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">包含块（Containing Block）</span><br><span class="line">控制框（Controlling Box）</span><br><span class="line">盒模型</span><br><span class="line">BFC（Block Formatting Context）</span><br><span class="line">IFC（Inline Formatting Context）</span><br><span class="line">定位体系</span><br><span class="line">浮动等</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>另外，CSS有三种定位机制：<code>普通流</code>，<code>浮动</code>，<code>绝对定位</code>，如无特别提及，下文中都是针对普通流中的</p><h3 id="包含块（Containing-Block）"><a href="#包含块（Containing-Block）" class="headerlink" title="包含块（Containing Block）"></a>包含块（Containing Block）</h3><p>一个元素的<code>box</code>的定位和尺寸，会与某一矩形框有关，这个框就称之为<code>包含块</code>。</p><p>元素会为它的子孙元素创建<code>包含块</code>，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系。</p><p>譬如：</p><ul><li>根元素是最顶端的元素，它没有父节点，它的包含块就是<code>初始包含块</code></li><li><code>static</code>和<code>relative</code>的包含块由它最近的<code>块级</code>、<code>单元格</code>或者<code>行内块祖先元素</code>的内容框（<code>content</code>）创建</li><li><code>fixed</code>的包含块是当前可视窗口</li><li><code>absolute的</code>包含块由它最近的<code>position</code>属性为<code>absolute</code>、<code>relative</code>或者<code>fixed</code>的祖先元素创建<ul><li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的<code>direction</code>特性</li><li>如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界</li></ul></li></ul><h3 id="控制框（Controlling-Box）"><a href="#控制框（Controlling-Box）" class="headerlink" title="控制框（Controlling Box）"></a>控制框（Controlling Box）</h3><p>块级元素和块框以及行内元素和行框的相关概念</p><h4 id="块框"><a href="#块框" class="headerlink" title="块框"></a>块框</h4><ul><li>块级元素会生成一个块框（<code>Block Box</code>），块框会占据一整行，用来包含子box和生成的内容</li><li>块框同时也是一个块包含框（<code>Containing Box</code>），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围</li></ul><p>关于<strong>匿名块框</strong>的生成，示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DIV</span>&gt;</span></span><br><span class="line">Some text</span><br><span class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span>More text</span><br><span class="line"><span class="tag">&lt;/<span class="name">DIV</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>div</code>生成了一个块框，包含了另一个块框<code>p</code>以及文本内容<code>Some text</code>，此时<code>Some text</code>文本会被强制加到一个匿名的块框里面，被<code>div</code>生成的块框包含（其实这个就是IFC中提到的行框，包含这些行内框的这一行匿名块形成的框，行框和行内框不同）</p><p>换句话说:<br><strong>如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）</strong></p><h4 id="行内框"><a href="#行内框" class="headerlink" title="行内框"></a>行内框</h4><ul><li>一个行内元素生成一个行内框</li><li>行内元素能排在一行，允许左右有其它元素</li></ul><p>关于匿名行内框的生成，示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span>Some <span class="tag">&lt;<span class="name">EM</span>&gt;</span>emphasized<span class="tag">&lt;/<span class="name">EM</span>&gt;</span> text<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br></pre></td></tr></table></figure><p>P元素生成一个块框，其中有几个行内框（如EM），以及文本Some ， text，此时会专门为这些文本生成匿名行内框</p><h4 id="display属性的影响"><a href="#display属性的影响" class="headerlink" title="display属性的影响"></a>display属性的影响</h4><p>display的几个属性也可以影响不同框的生成：</p><ul><li>block，元素生成一个<code>块框</code></li><li>inline，元素产生一个或多个的<code>行内框</code></li><li>inline-block，元素产生一个行<code>内级块框</code>，行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生BFC）</li><li>none，不生成框，不再格式化结构中，当然了，另一个visibility: hidden则会产生一个不可见的框</li></ul><p>总结：</p><ul><li>如果一个框里，有一个块级元素，那么这个框里的内容都会被当作<code>块框</code>来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）</li><li>如果一个框里，没有任何块级元素，那么这个框里的内容会被当成<code>行内框</code>来格式化，因为里面的内容是按照顺序成行的排列</li></ul><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p><code>CSS</code>盒模型本质上是一个盒子，封装周围的<code>HTML</code>元素，它包括：外边距（<code>margin</code>）、边框（b<code>order</code>）、内边距（<code>padding</code>）、实际内容（<code>content</code>）四个属性。</p><h4 id="标准盒子模型"><a href="#标准盒子模型" class="headerlink" title="标准盒子模型"></a>标准盒子模型</h4><p><img src="http://cdn.flqin.com/p336-19.jpg" alt="标准盒子模型"></p><p><code>padding</code>和<code>border</code>不被包含在定义的<code>width</code>和<code>height</code>之内。对象的实际宽度等于设置的<code>width</code>值和<code>border</code>、<code>padding</code>之和，即 <code>Element width = width + border + padding</code></p><h4 id="IE盒子模型-怪异盒模型"><a href="#IE盒子模型-怪异盒模型" class="headerlink" title="IE盒子模型(怪异盒模型)"></a>IE盒子模型(怪异盒模型)</h4><p><img src="http://cdn.flqin.com/p336-20.jpg" alt="IE盒子模型"></p><p><code>padding</code>和<code>border</code>被包含在定义的<code>width</code>和<code>height</code>之内。对象的实际宽度就等于设置的<code>width</code>值，即使定义有<code>border</code>和<code>padding</code>也不会改变对象的实际宽度，即 <code>Element width = width</code></p><h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><p><code>box-sizing</code> 用于指定盒子模型种类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span>; <span class="comment">/*默认值，对应标准盒子模型  */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>; <span class="comment">/* 对应IE盒子模型 */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">inherit</span>; <span class="comment">/* 规定应从父元素继承 box-sizing 属性 */</span></span><br></pre></td></tr></table></figure><h3 id="BFC-amp-IFC"><a href="#BFC-amp-IFC" class="headerlink" title="BFC &amp; IFC"></a>BFC &amp; IFC</h3><p>篇幅太长，详情跳转此处<a href="https://blog.flqin.com/224.html">BFC等Formatting Contexts浅析</a></p><h2 id="JS引擎解析过程"><a href="#JS引擎解析过程" class="headerlink" title="JS引擎解析过程"></a>JS引擎解析过程</h2><p>前面有提到遇到JS脚本时，会等到它的执行，实际上是需要引擎解析的，这里展开描述（介绍主干流程）</p><h3 id="JS的解释阶段"><a href="#JS的解释阶段" class="headerlink" title="JS的解释阶段"></a>JS的解释阶段</h3><p>首先得明确： <strong>JS是解释型语言，所以它无需提前编译，而是由解释器实时运行</strong></p><p>引擎对JS的处理过程可以简述如下：</p><ol><li>读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）</li><li>对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）</li><li>使用翻译器（translator），将代码转为字节码（bytecode）</li><li>使用字节码解释器（bytecode interpreter），将字节码转为机器码</li></ol><p>最终计算机执行的就是<code>机器码</code>。</p><p>为了提高运行速度，现代浏览器一般采用即时编译（JIT-Just In Time compiler），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache），这样整个程序的运行速度能得到显著提升。而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8）</p><p>总结起来可以认为是： <strong>核心的<code>JIT</code>编译器将源码编译成机器码运行。</strong></p><h3 id="JS的预处理阶段"><a href="#JS的预处理阶段" class="headerlink" title="JS的预处理阶段"></a>JS的预处理阶段</h3><p>上述将的是解释器的整体过程，这里再提下在正式执行JS前，还会有一个<code>预处理阶段</code> （譬如变量提升，分号补全等）</p><p><code>预处理阶段</code>会做一些事情，确保JS可以正确执行，这里仅提部分：</p><h4 id="分号补全"><a href="#分号补全" class="headerlink" title="分号补全"></a>分号补全</h4><p>JS执行是需要分号的，但为什么以下语句却可以正常运行呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure><p>原因就是JS解释器有一个<code>Semicolon Insertion</code>规则，它会按照一定规则，在适当的位置补充分号</p><p>譬如列举几条自动加分号的规则：</p><ul><li>当有换行符（包括含有换行符的多行注释），并且下一个token没法跟前面的语法匹配时，会自动补分号。</li><li>当有}时，如果缺少分号，会补分号。</li><li>程序源代码结束时，如果缺少分号，会补分号。</li></ul><p>于是，上述的代码就变成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br></pre></td></tr></table></figure><p>所以可以正常运行。</p><p>当然了，这里有一个经典的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#123;</span><br><span class="line">        a: <span class="string">'a'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于分号补全机制，所以它变成了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        a: <span class="string">'a'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以运行后是<code>undefined</code></p><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>一般包括<code>函数提升</code>和<code>变量提升</code></p><p>譬如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure><p>经过变量提升后，就变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure><p>这里没有展开，其实展开也可以牵涉到很多内容的，譬如可以提下变量声明，<a href="https://goddyzhao.tumblr.com/post/11273713920/functions" target="_blank" rel="noopener">函数声明</a>，形参，实参的优先级顺序，以及es6中let有关的<a href="https://blog.flqin.com/349.html">临时死区</a>等.</p><h3 id="JS的执行阶段"><a href="#JS的执行阶段" class="headerlink" title="JS的执行阶段"></a>JS的执行阶段</h3><p>相关概念中文文档<a href="https://goddyzhao.tumblr.com/JavaScript-Internal" target="_blank" rel="noopener">翻译查阅</a></p><p>解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：</p><ul><li>执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）</li><li>VO（变量对象）和AO（活动对象）</li><li>作用域链</li><li>this机制等</li></ul><p>这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性</p><h4 id="执行上下文简单解释"><a href="#执行上下文简单解释" class="headerlink" title="执行上下文简单解释"></a>执行上下文简单解释</h4><ul><li>JS有<code>执行上下文</code></li><li>浏览器首次载入脚本，它将创建<code>全局执行上下文</code>，并压入<code>执行栈</code>栈顶（不可被弹出）</li><li>然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的<code>顶部</code></li><li>一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈</li><li>这样依次执行（最终都会回到全局执行上下文）</li></ul><p>譬如，如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收</p><p><img src="http://cdn.flqin.com/p336-15.png" alt="执行上下文"></p><p>然后执行上下文与VO，作用域链，this的关系是：</p><p>每一个执行上下文，都有三个重要属性：</p><ul><li>变量对象(<code>Variable object</code>-<code>VO</code>)</li><li>作用域链(<code>Scope chain</code>)</li><li><code>this</code></li></ul><p><img src="http://cdn.flqin.com/p336-21.png" alt="execution context"></p><h4 id="VO与AO"><a href="#VO与AO" class="headerlink" title="VO与AO"></a>VO与AO</h4><p><code>VO</code>是执行上下文的属性（抽象概念），但是<strong>只有全局上下文的变量对象允许通过<code>VO</code>的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）</strong></p><p><code>AO（activation object)</code> 活动对象，当函数被调用者激活，<code>AO</code>就被创建了</p><p>可以理解为：</p><ul><li>在函数上下文中：<code>VO === AO</code></li><li>在全局上下文中：<code>VO === this === global</code></li></ul><p>总的来说，<code>VO</code>中会存放一些变量信息（如声明的变量，函数，arguments参数等等）</p><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>它是执行上下文中的一个属性，原理和原型链很相似，作用很重要。</p><p>譬如流程简述：</p><ul><li>在函数上下文中，查找一个变量<code>foo</code></li><li>如果函数的<code>VO</code>中找到了，就直接使用</li><li>否则去它的父级作用域链中（<strong>parent</strong>）找</li><li>如果父级中没找到，继续往上找</li><li>直到全局上下文中也没找到就报错</li></ul><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><p>这也是JS的核心知识之一，由于内容过多，这里就不展开，仅提及部分,更多<a href="https://blog.flqin.com/240.html">this介绍查询</a></p><p>注意：<strong>this是执行上下文环境的一个属性，而不是某个变量对象的属性</strong></p><p>因此:</p><ul><li><code>this</code>是没有一个类似搜寻变量的过程</li><li>当代码中使用了<code>this</code>，这个 <code>this</code>的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻</li><li><code>this</code>的值只取决中进入上下文时的情况</li></ul><p>所以经典的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baz = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">    baz: <span class="number">100</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.baz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = bar.foo;</span><br><span class="line"><span class="comment">// 进入环境：global</span></span><br><span class="line">foo(); <span class="comment">// 200，严格模式中会报错，Cannot read property 'baz' of undefined</span></span><br><span class="line"><span class="comment">// 进入环境：global bar</span></span><br><span class="line">bar.foo(); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>就要明白了上面<code>this</code>的介绍，上述例子很好理解.</p><h3 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h3><p>JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。</p><p>一般来说，垃圾处理器有自己的回收策略。譬如对于那些执行完毕的函数，如果没有<code>外部引用</code>（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）</p><p>常用的两种垃圾回收规则是：</p><ul><li>标记清除</li><li>引用计数</li></ul><p><code>Javascript</code>引擎基础<code>GC</code>方案是（simple GC）：<code>mark and sweep（标记清除）</code>，简单解释如下：</p><ul><li>遍历所有可访问的对象。</li><li>回收已不可访问的对象。</li></ul><p>譬如：（出自javascript高程）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。</span><br><span class="line">从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。</span><br><span class="line">而当变量离开环境时，则将其标记为“离开环境”。</span><br><span class="line">垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。</span><br><span class="line">然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。</span><br><span class="line">而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。</span><br><span class="line">最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</span><br></pre></td></tr></table></figure><p>关于引用计数，简单点理解：<strong>跟踪记录每个值被引用的次数，当一个值被引用时，次数+1，减持时-1，下次垃圾回收器会回收次数为0的值的内存（当然了，容易出循环引用的bug）</strong></p><h4 id="GC的缺陷"><a href="#GC的缺陷" class="headerlink" title="GC的缺陷"></a>GC的缺陷</h4><p>和其他语言一样，javascript的<code>GC策略</code>也无法避免一个问题： <strong>GC时，停止响应其他操作</strong>，这是为了安全考虑。而Javascript的<code>GC</code>在100ms甚至以上。</p><p>对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是引擎需要优化的点： <strong>避免GC造成的长时间停止响应。</strong></p><h4 id="GC优化策略"><a href="#GC优化策略" class="headerlink" title="GC优化策略"></a>GC优化策略</h4><p>这里介绍常用到的：<strong>分代回收（Generation GC）</strong></p><p>目的是通过区分“临时”与“持久”对象:</p><ul><li>多回收“临时对象”区（<code>young generation</code>）</li><li>少回收“持久对象”区（<code>tenured generation</code>）</li><li>减少每次需遍历的对象，从而减少每次GC的耗时。</li></ul><p>像node v8引擎就是采用的分代回收。</p><p>更多JavaScript垃圾回收<a href="https://blog.flqin.com/259.html">查阅</a></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="可以提到跨域"><a href="#可以提到跨域" class="headerlink" title="可以提到跨域"></a>可以提到跨域</h3><p>譬如发出网络请求时，会用AJAX，如果接口跨域，就会遇到跨域问题</p><p>可以参考：</p><p><a href="https://segmentfault.com/a/1190000012469713" target="_blank" rel="noopener">ajax跨域，这应该是最全的解决方案了</a></p><h3 id="可以提到web安全"><a href="#可以提到web安全" class="headerlink" title="可以提到web安全"></a>可以提到web安全</h3><p>譬如浏览器在解析HTML时，有XSSAuditor，可以延伸到web安全相关领域</p><p>可以参考：</p><p><a href="https://segmentfault.com/a/1190000012693772" target="_blank" rel="noopener">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系。</a></p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><ul><li>如可以提到viewport概念，讲讲物理像素，逻辑像素，CSS像素等概念<a href="https://blog.flqin.com/218.html">查阅</a></li><li>如熟悉Hybrid开发的话可以提及一下Hybrid相关内容以及优化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）深入理解“连等赋值”问题</title>
      <link href="/333.html"/>
      <url>/333.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接：<code>https://segmentfault.com/a/1190000004224719</code></p></blockquote><p>有这样一个热门问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br><span class="line">alert(a.x); <span class="comment">// --&gt; undefined</span></span><br><span class="line">alert(b.x); <span class="comment">// --&gt; &#123;n: 2&#125;</span></span><br></pre></td></tr></table></figure><p>其实这个问题很好理解，关键要弄清下面两个知识点：</p><ul><li><code>JS</code> 引擎对赋值表达式的处理过程</li><li>赋值运算的右结合性</li></ul><h3 id="一-赋值表达式"><a href="#一-赋值表达式" class="headerlink" title="一. 赋值表达式"></a>一. 赋值表达式</h3><p>形如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = B;</span><br></pre></td></tr></table></figure><p>的表达式称为<strong>赋值表达式</strong>。其中 <code>A</code> 和 <code>B</code> 又分别可以是表达式。<code>B</code> 可以是任意表达式，但是 <code>A</code> 必须是一个<strong>左值</strong>。</p><p>所谓左值，就是可以被赋值的表达式，在 <code>ES</code> 规范中是用内部类型引用(<code>Reference</code>)描述的。例如：</p><ul><li>表达式 <code>foo.bar</code> 可以作为一个左值，表示对 <code>foo</code> 这个对象中 <code>bar</code> 这个名称的引用；</li><li>变量 <code>email</code> 可以作为一个左值，表示对当前执行环境中的环境记录项 <code>envRec</code> 中 <code>email</code> 这个名称的引用</li><li>同样地，函数名 <code>func</code> 可以做左值，然而函数调用表达式 <code>func(a, b)</code>不可以。</li></ul><p>那么 <code>JS</code> 引擎是怎样计算一般的赋值表达式 <code>A = B</code> 的呢？简单地说，按如下步骤：</p><ol><li>计算表达式 <code>A</code>，得到一个引用 <code>refA</code>；</li><li>计算表达式 <code>B</code>，得到一个值 <code>valueB</code>；</li><li>将 <code>valueB</code> 赋给 <code>refA</code> 指向的名称绑定；</li><li>返回 <code>valueB</code>。</li></ol><h3 id="二-结合性"><a href="#二-结合性" class="headerlink" title="二. 结合性"></a>二. 结合性</h3><p>所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。 赋值表达式是右结合的。这意味着：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A1 = A2 = A3 = A4;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A1 = A2 = A3 = A4;</span><br></pre></td></tr></table></figure><h3 id="三-连等的解析"><a href="#三-连等的解析" class="headerlink" title="三. 连等的解析"></a>三. 连等的解析</h3><p>好了，有了上面两部分的知识。下面来看一下 <code>JS</code> 引擎是怎样运算连等赋值表达式的。</p><p>以下面的式子为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exp1 = Exp2 = Exp3 = Exp4;</span><br></pre></td></tr></table></figure><p>首先根据右结合性，可以转换成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exp1 = Exp2 = Exp3 = Exp4;</span><br></pre></td></tr></table></figure><p>然后，我们已经知道对于单个赋值运算，<code>JS</code> 引擎总是先计算左边的操作数，再计算右边的操作数。所以接下来的步骤就是：</p><ol><li>计算 <code>Exp1</code>，得到 <code>Ref1</code>；</li><li>计算 <code>Exp2</code>，得到 <code>Ref2</code>；</li><li>计算 <code>Exp3</code>，得到 <code>Ref3</code>；</li><li>计算 <code>Exp4</code>，得到 <code>Value4</code>。</li></ol><p>现在变成了这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ref1 = Ref2 = Ref3 = Value4;</span><br></pre></td></tr></table></figure><p>接下来的步骤是：</p><ol><li>将 <code>Value4</code> 赋给 <code>Exp3</code>；</li><li>将 <code>Value4</code> 赋给 <code>Exp2</code>；</li><li>将 <code>Value4</code> 赋给 <code>Exp1</code>；</li><li>返回表达式最终的结果 <code>Value4</code>。</li></ol><p>注意：这几个步骤体现了右结合性。</p><p>总结一下就是：</p><blockquote><p>先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用。</p></blockquote><h3 id="四-问题的解决"><a href="#四-问题的解决" class="headerlink" title="四. 问题的解决"></a>四. 问题的解决</h3><p>现在回到文章开头的问题。</p><p>首先前两个 <code>var</code> 语句执行完后，<code>a</code> 和 <code>b</code> 都指向同一个对象 {<code>n: 1}</code> (为方便描述，下面称为对象 <code>N1</code>)。然后来看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>根据前面的知识，首先依次计算表达式 <code>a.x</code> 和 <code>a</code>，得到两个引用。其中 <code>a.x</code> 表示对象 <code>N1</code> 中的 <code>x</code>，而 <code>a</code> 相当于 <code>envRec.a</code>，即当前环境记录项中的 <code>a</code>。所以此时可以写出如下的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[N1]].x = [[encRec]].a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>[[]]</code> 表示引用指向的对象。</p><p>接下来，将 <code>{n: 2}</code> 赋值给 <code>[[encRec]].a</code>，即将 <code>{n: 2}</code> 绑定到当前上下文中的名称 <code>a</code>。</p><p>接下来，将同一个 <code>{n: 2}</code> 赋值给 <code>[[N1]].x</code>，即将 <code>{n: 2}</code> 绑定到 <code>N1</code> 中的名称 <code>x</code>。</p><p>由于 <code>b</code> 仍然指向 <code>N1</code>，所以此时有</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b &lt;=&gt; N1 &lt;=&gt; &#123;<span class="attr">n</span>: <span class="number">1</span>, <span class="attr">x</span>: &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>而 <code>a</code> 被重新赋值了，所以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &lt;=&gt; &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>并且</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a === b.x;</span><br></pre></td></tr></table></figure><h3 id="五-最后的最后"><a href="#五-最后的最后" class="headerlink" title="五. 最后的最后"></a>五. 最后的最后</h3><p>如果你明白了上面所有的内容，应该会明白 <code>a.x = a = {n:2};</code> 与 <code>b.x = a = {n:2};</code> 是完全等价的。因为在解析 <code>a.x</code> 或 <code>b.x</code> 的那个时间点。<code>a</code> 和 <code>b</code> 这两个名称指向同一个对象，就像 <code>C++</code> 中同一个对象可以有多个引用一样。而在这个时间点之后，不论是 <code>a.x</code>还是 <code>b.x</code>，其实早就不存在了，它已经变成了 <code>那个内存中的对象.x</code> 了。</p><p>最后用一张图表示整个表达式的运算过程：</p><p><img src="http://cdn.flqin.com/p333-1.png" alt="连等赋值"></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数节流（throttle）与函数去抖（debounce）</title>
      <link href="/325.html"/>
      <url>/325.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>以下场景往往由于事件频繁被触发，因而频繁执行 <code>DOM</code> 操作、资源加载等重行为，导致 <code>UI</code> 停顿甚至浏览器崩溃。</p><ul><li><code>window</code> 对象的 <code>resize</code>、<code>scroll</code> 事件</li><li>拖拽时的 <code>mousemove</code> 事件</li><li>射击游戏中的 <code>mousedown</code>、<code>keydown</code> 事件</li><li>文字输入、自动完成的 <code>keyup</code> 事件</li></ul><p>实际上对于 <code>window</code> 的 <code>resize</code> 事件，实际需求大多为停止改变大小 <code>n</code> 毫秒后执行后续处理；而其他事件大多的需求是以一定的频率执行后续处理。针对这两种需求就出现了 <code>debounce</code> 和 <code>throttle</code> 两种解决办法。</p><h3 id="什么是-debounce"><a href="#什么是-debounce" class="headerlink" title="什么是 debounce"></a>什么是 debounce</h3><h4 id="debounce-定义"><a href="#debounce-定义" class="headerlink" title="debounce 定义"></a>debounce 定义</h4><p>如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。</p><p>也就是说当调用动作 <code>n</code> 毫秒后，才会执行该动作，若在这 <code>n</code> 毫秒内又调用此动作则将重新计算执行时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 idle，action 才会执行</span></span><br><span class="line"><span class="comment"> * @param idle   &#123;number&#125;    空闲时间，单位毫秒</span></span><br><span class="line"><span class="comment"> * @param action &#123;function&#125;  请求关联函数，实际应用需要调用的函数</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;    返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">debounce(idle, action);</span><br></pre></td></tr></table></figure><h4 id="debounce-简单实现"><a href="#debounce-简单实现" class="headerlink" title="debounce 简单实现"></a>debounce 简单实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">idle, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">    clearTimeout(last);</span><br><span class="line">    last = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      action.apply(ctx, args);</span><br><span class="line">    &#125;, idle);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="什么是-throttle"><a href="#什么是-throttle" class="headerlink" title="什么是 throttle"></a>什么是 throttle</h3><h4 id="throttle-定义"><a href="#throttle-定义" class="headerlink" title="throttle 定义"></a>throttle 定义</h4><p>如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。</p><p>也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay</span></span><br><span class="line"><span class="comment"> * @param delay  &#123;number&#125;    延迟时间，单位毫秒</span></span><br><span class="line"><span class="comment"> * @param action &#123;function&#125;  请求关联函数，实际应用需要调用的函数</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;    返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">throttle(delay, action);</span><br></pre></td></tr></table></figure><h4 id="throttle-简单实现"><a href="#throttle-简单实现" class="headerlink" title="throttle 简单实现"></a>throttle 简单实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">delay, action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last = <span class="number">0</span><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> curr = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">if</span> (curr - last &gt; delay)&#123;</span><br><span class="line">      action.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      last = curr</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>underscore 里有该实现，可以多多参考一下。</strong></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）javascript闭包概念及用法梳理</title>
      <link href="/317.html"/>
      <url>/317.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接: <code>https://www.tangshuang.net/2368.html</code></p></blockquote><h3 id="函数内部的函数：私有函数"><a href="#函数内部的函数：私有函数" class="headerlink" title="函数内部的函数：私有函数"></a>函数内部的函数：私有函数</h3><p>首先，我们从这个内部函数去说开，因为这个是形式上的，如果一开始讲作用域，有点故意。闭包在形式上就是函数内部的函数，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = add(<span class="number">5</span>)(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>这是一个很奇怪的用法，第一次看到有 <code>function()()</code> 这样的用法？请阅读<a href="https://www.tangshuang.net/2020.html" target="_blank" rel="noopener">这篇文章</a>。当执行 <code>add(5)</code> 的时候，返回的结果其实是一个函数，而再执行这个函数，需要再传入一个参数，所以就有了 <code>add(5)(10)</code> 这样的用法。当然，这是一个极端的例子，出现的太早，我们来看下最常见的一种用法吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jQuery(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">message</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    alert(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ($(<span class="built_in">window</span>).width() &gt; <span class="number">1000</span>) message(<span class="string">'window宽度大于1000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你用 <code>jquery</code>，这段代码应该经常使用吧。如果你仔细去观察就会发现，第一个 <code>function</code> 被作为参数，传给了 <code>jQuery()</code> 这个函数，而在 <code>function</code> 内，又有一个 <code>message()</code> 函数。所有的 <code>jQuery</code> 代码被放在第一个 <code>function</code> 中去处理。第二个函数就是函数体内部的函数，这个函数在函数体内声明，一旦外层函数执行完毕，那么这个函数就失去了作用，在 <code>jQuery()</code> 外无法使用 <code>message()</code>，因此，<code>message()</code> 是第一个函数内部的私有函数。</p><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>函数内部的变量有两种，一种是局部变量，一种是全局变量。局部变量只在当前函数体内有效，出了函数体，就回到全局变量的范围，局部变量无效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">_age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> age + _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">_age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">11</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age + _age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> add();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(a(<span class="number">9</span>)); <span class="comment">// 10 : 9 + 1</span></span><br><span class="line">alert(b(<span class="number">2</span>)); <span class="comment">// 12 : 10 + 2</span></span><br><span class="line">alert(c(<span class="number">5</span>)); <span class="comment">// 16 : 11 + 5</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们看 <code>b</code> 和 <code>c</code> 函数。<code>b</code> 函数中的 <code>age</code> 直接引用了全局变量 <code>age（10</code>），而 <code>c</code> 函数中重新声明了局部变量 <code>age</code>，因此，全局变量 <code>age</code> 在 <code>c</code> 函数中无效。</p><p>但是在 <code>c</code> 中，函数内部有一个函数 <code>add()</code>，它的函数体内的 <code>age</code> 是指 <code>c</code> 中声明的局部变量，而非全局变量 <code>age</code>。从这个例子里，反映出了变量的作用域，函数内的函数体里，如果没有声明局部变量，就会承认其父级甚至祖先级函数的变量，以及全局变量。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>怎么样才算是一个闭包呢？我们来看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age = a();</span><br><span class="line">alert(age()); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>按照我们前面说的作用域，在上面这段代码中 <code>age</code> 是 <code>a()</code> 的局部变量，按道理出了函数就不能被访问了。但是，<code>a()</code> 返回了一个私有函数，个这个函数返回了 <code>age</code>，这导致我们可以在 <code>a()</code> 外部，仍然可以访问到本来是局部变量的 <code>age</code>，这个时候，我们就把这个内部函数称为<strong>闭包</strong>。它的原理就是<strong>函数内部的函数可以访问父函数的局部变量</strong>。</p><p>综合上面的阐述，我们要这样去理解闭包：</p><ul><li>闭包是一个函数，它使用了自己之外的变量。</li><li>闭包是一个作用域。</li><li>闭包是“由函数和与其相关的引用环境组合而成的实体”。</li><li>严格的讲，闭包常常表现为一个函数内部的函数，它使用了非自己定义的、自己所在作用域内的变量，并且使这些变量突破了作用域的限制。</li></ul><p>所以，我们文章最开头的那段代码，也有一个闭包。</p><p>一个典型的闭包：</p><ul><li>函数内的函数</li><li>这个内部函数引用了父函数的局部变量</li><li>这个内部函数使引用的变量突破了作用域限制</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(fun());</span><br></pre></td></tr></table></figure><p>这也可以算作一个闭包，<code>a()</code>引用了它之外定义的变量。但是这不算严格的闭包，因为它没有在突破作用域的这个点上表现出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + ++b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = fun();</span><br><span class="line">alert(c()); <span class="comment">// 4</span></span><br><span class="line">alert(c()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>这就是一个非常典型的闭包了。而且为什么 <code>alert(c())</code> 两次的值不同，我们还会在下面解释到。</p><p>为了让你更加明晰的和你曾经开发过的案例联系在一起，我们来看我们曾经做过的这样的事：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">grow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age: getAge,</span><br><span class="line">    grow: grow</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是我们在 <code>require.js</code> 中的一种写法，把它还原为我们熟悉的闭包模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">grow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ageAge: getAge,</span><br><span class="line">    grow: grow</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat = Cat();</span><br><span class="line"><span class="keyword">var</span> age = cat.getAge();</span><br><span class="line">alert(age); <span class="comment">// 10</span></span><br><span class="line">cat.grow();</span><br><span class="line">age = cat.getAge();</span><br><span class="line">alert(age); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><h3 id="从内存看闭包"><a href="#从内存看闭包" class="headerlink" title="从内存看闭包"></a>从内存看闭包</h3><p>现在，我们就要来解释为什么上面的 <code>alert()</code> 两次的结果不同的原因了。</p><p>首先，我们来看下普通的函数声明和使用过程中内存的变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(fun(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">alert(fun(<span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>上面是我们没有遇到闭包的情况，内存我们这样来画（注意，我这里只是抽象的画出内存变化，而不是真实的 <code>javascript</code> 内存机制。）</p><p><img src="http://cdn.flqin.com/p317-1.png" alt="闭包内存"></p><p>在每一次执行完 <code>fun()</code> 之后，<code>fun()</code>函数的执行环境被释放（回收机制）。</p><p>接下来我们来看一个闭包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = fun(<span class="number">2</span>);</span><br><span class="line">alert(add(<span class="number">2</span>));</span><br><span class="line">alert(add(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>上面就出现闭包了，注意，我们这里出现了一个 <code>add</code> 变量。</p><p><img src="http://cdn.flqin.com/p317-2.png" alt="闭包内存2"></p><p>在后两步中，实际上 <code>fun(2)</code> 部分没有任何变化，所变的，则是在内部函数所对应的内存区域中有变化。细心的你，可能会发现这里面的问题所在，当执行完 <code>add(2)</code> <code>之后，fun</code> 对应的内存没有被释放掉，而它的内部函数，也就是 <code>function(2)</code> 被释放掉了，在执行 <code>add(4)</code> 的时候，仅仅重新运行了内部函数。如果连 <code>fun()</code> 对应的内存出现了变化怎么办？我们来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + ++b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = fun();</span><br><span class="line">alert(c(<span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line">alert(c(<span class="number">1</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>注意，这可是个非常典型的闭包的例子，它有一个局部变量 <code>b</code>，我们来看它的内存图。</p><p><img src="http://cdn.flqin.com/p317-3.png" alt="闭包内存3"></p><p>注意第 2、3、4 步中内存的变化。第 2 步时，我们仅仅将 <code>fun()</code> 赋给变量 <code>c</code>，这个时候，内部函数 <code>function(a)</code> 并没有被执行，所以 <code>++b</code> 也没有被执行，<code>b</code> 的值还是 2。但是第 3 步开始，<code>++b</code> 被先执行，<code>++b</code> 的意思是先自加，再进行运算，和 <code>b++</code> 是不同的，如果是 <code>b++</code>，虽然 <code>c(1)</code> 的最终结果还是为 4，但是在 <code>c(1)</code> 执行开始时，<code>b</code> 应该为 2，执行完之后才是 3。</p><p>奇妙的事情发生了，在内部函数中，<code>++b</code> 导致了局部变量值发生了变化，<code>b</code> 从 2 变成了 3，而且，内存并没有被释放，<code>fun()</code> 的执行环境没有被销毁，<code>b</code> 还被保存在内存中。到第 4 步时，b 的初始值是 3，经过 <code>++b</code> 之后，变成了 4。</p><p>这个内存分析非常形象的把闭包概念中，关于“突破作用域限制”这个点描述的非常清楚，原本按照作用域的限制，函数的局部变量不能被外部环境访问，更不能被修改，但是闭包却使得外部环境不仅可以读取到局部变量的内容，甚至可以修改它，深入一点就是：<strong>闭包会导致闭包函数所涉及到的非自身定义的变量一直保存在内存中，包括其父函数在内的相关环境都不会被销毁。</strong></p><h3 id="闭包到底有什么用"><a href="#闭包到底有什么用" class="headerlink" title="闭包到底有什么用"></a>闭包到底有什么用</h3><p>说了这么多，那闭包到底有什么用，我们为什么要使用闭包呢？从上面的阐述中，你应该已经知道了闭包的唯一作用：突破作用域限制。那如何使用这个作用为程序服务呢？</p><p>常驻内存，意味着读取速度快，（当然，内存花销也大，导致内存溢出）。常驻内存，意味着一旦初始化以后，就可以反复使用同一个内存中的某个对象，而无需再次运行程序。而这一点，是很多插件、模块的设计思想。</p><p>最好的例子就是上文我举得那个 <code>define()</code> 的例子，后面用我们今天所了解的形式去实践之后，你就会发现原来可以把 <code>function</code> 当做一个其他语言中的 <code>class</code> 来对待，<code>cat.getAge()</code>, <code>cat.grow()</code> 这样的操作是不是很符合我们在编程中的使用习惯呢？一旦一个产生之后，这个 <code>cat</code> 就一直在内存中，随时可以拿出来就用，它就是一个实例化对象。</p><p>为了更形象，我们来创建一个简单的代码块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.weight = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;,</span><br><span class="line">    getWeight: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;,</span><br><span class="line">    grow: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age++;</span><br><span class="line">      <span class="keyword">this</span>.weight = <span class="keyword">this</span>.age * <span class="number">10</span> * <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cat = <span class="keyword">new</span> Animal(); <span class="comment">// 继承</span></span><br><span class="line">  cat.grow = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    cat.age++;</span><br><span class="line">    cat.weight = cat.age * <span class="number">10</span> * <span class="number">0.6</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> cat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat();</span><br><span class="line">alert(cat1.getAge());</span><br><span class="line">cat1.grow();</span><br><span class="line">alert(cat1.getAge());</span><br></pre></td></tr></table></figure><p>为什么要举这个例子呢，因为我想让你想象这样一种场景，如果没有闭包怎么办？</p><p>没有闭包是这样的一种状态：函数无法访问自己父级（祖先，全局）对象的变量。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++a; <span class="comment">// 如果没有闭包机制，会undefined报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况怎么办？必须以参数的形式传入到函数中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++a;</span><br><span class="line">&#125;</span><br><span class="line">alert(add(a)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>如果是这样，就很麻烦了，你需要在每一个函数中传入变量。而更麻烦的是，没有了作用域的突破，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  age = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">grow</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getAge: getAge,</span><br><span class="line">    grow: grow</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.grow();</span><br><span class="line">alert(cat.getAge()); <span class="comment">// 1，没有被修改</span></span><br></pre></td></tr></table></figure><p>这种情况下，我们无论如何都无法使用这种办法来实现我们的目的。唯一能够实现的，就是按照下面这种方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">  age: <span class="number">1</span>,</span><br><span class="line">  weight: <span class="number">10</span>,</span><br><span class="line">  grow: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age++;</span><br><span class="line">    <span class="keyword">this</span>.weight += <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cat1 = cat;</span><br><span class="line">alert(cat1.age);</span><br><span class="line">cat1.grow();</span><br><span class="line">alert(cat1.age);</span><br></pre></td></tr></table></figure><p>我们聪明的使用到了 <code>this</code> 关键字，但是这样一个坏处是，<code>age</code>, <code>weight</code> 这些属性直接暴露给外部，我们只需要执行 <code>cat1.age = 12</code>; 就可以马上让 <code>cat</code> 长到 <code>12</code> 岁，而体重却没任何变化。</p><p>总结而言，闭包可以带来这么几个方面的应用优势：</p><ul><li>常驻内存，加快运行速度</li><li>封装</li></ul><h3 id="闭包使用中的注意点"><a href="#闭包使用中的注意点" class="headerlink" title="闭包使用中的注意点"></a>闭包使用中的注意点</h3><p>除了上面提到的内存开销问题外，还有一个需要被注意的地方，就是闭包所引用的外部变量，在一些特殊情况下会存在与期望值不同的误差。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pAry = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pAry.length; i++) &#123;</span><br><span class="line">    pAry[i].i = i;</span><br><span class="line">    pAry[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中，你希望通过一个循环，来为每一个 <code>p</code> 标签绑定一个 <code>click</code> 事件，然而不幸的是，<code>for</code> 循环中使用的闭包函数没有让你如愿以偿，在闭包函数中，<code>i</code> 被认作 <code>pAry.length</code>，也就是循环到最后 <code>i</code> 的最终值。为什么会这样呢？ 原来，闭包引用变量，而非直接使用变量，“引用”的意思是将指针指向变量的内容。由于这个原因，当 <code>i=0</code> 的时候，闭包里面的 <code>i</code> 确实是 0，但是当随着 <code>i</code> 的值变大的时候，闭包内的 <code>i</code> 并没有保存当前值，而是继续把指针指向 <code>i</code> 的内容，当你点击某个 <code>p</code> 标签的时候，<code>i</code> 的内容实际上是 <code>for</code> 到最后 <code>i</code> 的值。</p><p>同样，这个问题会出现在 <code>setTimeout，setInterval，\$.ajax</code> 等这类操作中，你只要记住，当你绑定操作时，和执行操作时，对应的变量是否已经变化就 OK 了。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）用 GitLab CI 进行持续集成</title>
      <link href="/312.html"/>
      <url>/312.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接: <code>https://scarletsky.github.io/2016/07/29/use-gitlab-ci-for-continuous-integration/</code></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>从 <code>GitLab 8.0</code> 开始，<code>GitLab CI</code> 就已经集成在 <code>GitLab</code> 中，我们只要在项目中添加一个 <code>.gitlab-ci.yml</code> 文件，然后添加一个 <code>Runner</code>，即可进行持续集成。 而且随着 <code>GitLab</code> 的升级，<code>GitLab CI</code> 变得越来越强大，本文将介绍如何使用 <code>GitLab CI</code> 进行持续集成。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>在介绍 <code>GitLab CI</code> 之前，我们先看看一些持续集成相关的概念。</p><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>一次 <code>Pipeline</code> 其实相当于一次构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。 任何提交或者 <code>Merge Request</code> 的合并都可以触发 <code>Pipeline</code>，如下图所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------------------+           +----------------+</span><br><span class="line">|                  |  trigger  |                |</span><br><span class="line">|   Commit / MR    +----------&gt;+    Pipeline    |</span><br><span class="line">|                  |           |                |</span><br><span class="line">+------------------+           +----------------+</span><br></pre></td></tr></table></figure><h3 id="Stages"><a href="#Stages" class="headerlink" title="Stages"></a>Stages</h3><p><code>Stages</code> 表示构建阶段，说白了就是上面提到的流程。 我们可以在一次 <code>Pipeline</code> 中定义多个 <code>Stages</code>，这些 <code>Stages</code> 会有以下特点：</p><ul><li>所有 <code>Stages</code> 会按照顺序运行，即当一个 <code>Stage</code> 完成后，下一个 <code>Stage</code> 才会开始</li><li>只有当所有 <code>Stages</code> 完成后，该构建任务 (<code>Pipeline</code>) 才会成功</li><li>如果任何一个 <code>Stage</code> 失败，那么后面的 <code>Stages</code> 不会执行，该构建任务 (<code>Pipeline</code>) 失败</li><li>因此，<code>Stages</code> 和 <code>Pipeline</code> 的关系就是：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------------------------------+</span><br><span class="line">| |</span><br><span class="line">| Pipeline |</span><br><span class="line">| |</span><br><span class="line">| +-----------+ +------------+ +------------+ |</span><br><span class="line">| | Stage <span class="number">1</span> |----&gt;| Stage <span class="number">2</span> |-----&gt;| Stage <span class="number">3</span> | |</span><br><span class="line">| +-----------+ +------------+ +------------+ |</span><br><span class="line">| |</span><br><span class="line">+--------------------------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h3><p><code>Jobs</code> 表示构建工作，表示某个 <code>Stage</code> 里面执行的工作。 我们可以在 <code>Stages</code> 里面定义多个 <code>Jobs</code>，这些 <code>Jobs</code> 会有以下特点：</p><ul><li>相同 <code>Stage</code> 中的 <code>Jobs</code> 会并行执行</li><li>相同 <code>Stage</code> 中的 <code>Jobs</code> 都执行成功时，该 <code>Stage</code> 才会成功</li><li>如果任何一个 <code>Job</code> 失败，那么该 <code>Stage</code> 失败，即该构建任务 (<code>Pipeline</code>) 失败</li></ul><p>所以，<code>Jobs</code> 和 <code>Stage</code> 的关系图就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------+</span><br><span class="line">|                                          |</span><br><span class="line">|  Stage <span class="number">1</span>                                 |</span><br><span class="line">|                                          |</span><br><span class="line">|  +---------+  +---------+  +---------+   |</span><br><span class="line">|  |  Job <span class="number">1</span>  |  |  Job <span class="number">2</span>  |  |  Job <span class="number">3</span>  |   |</span><br><span class="line">|  +---------+  +---------+  +---------+   |</span><br><span class="line">|                                          |</span><br><span class="line">+------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="GitLab-Runner"><a href="#GitLab-Runner" class="headerlink" title="GitLab Runner"></a>GitLab Runner</h2><h3 id="Runner-简介"><a href="#Runner-简介" class="headerlink" title="Runner 简介"></a>Runner 简介</h3><p>理解了上面的基本概念之后，有没有觉得少了些什么东西 —— 由谁来执行这些构建任务呢？ 答案就是 <code>GitLab Runner</code> 了！</p><p>想问为什么不是 <code>GitLab CI</code> 来运行那些构建任务？ 一般来说，构建任务都会占用很多的系统资源 (譬如编译代码)，而 <code>GitLab CI</code> 又是 <code>GitLab</code> 的一部分，如果由 <code>GitLab CI</code> 来运行构建任务的话，在执行构建任务的时候，<code>GitLab</code> 的性能会大幅下降。</p><p><code>GitLab CI</code> 最大的作用是管理各个项目的构建状态，因此，运行构建任务这种浪费资源的事情就交给 <code>GitLab Runner</code> 来做拉！ 因为 <code>GitLab Runner</code> 可以安装到不同的机器上，所以在构建任务运行期间并不会影响到 <code>GitLab</code> 的性能~</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 <code>GitLab Runner</code> 太简单了，按照着 <a href="https://gitlab.com/gitlab-org/gitlab-ci-multi-runner" target="_blank" rel="noopener">官方文档</a> 的教程来就好拉！ 下面是 <code>Debian/Ubuntu/CentOS</code> 的安装方法，其他系统去参考官方文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For Debian/Ubuntu</span></span><br><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.deb.sh | sudo bash</span><br><span class="line">sudo apt-get install gitlab-ci-multi-runner</span><br><span class="line"><span class="comment"># For CentOS</span></span><br><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash</span><br><span class="line">sudo yum install gitlab-ci-multi-runner</span><br></pre></td></tr></table></figure><h3 id="注册-Runner"><a href="#注册-Runner" class="headerlink" title="注册 Runner"></a>注册 Runner</h3><p>安装好 <code>GitLab Runner</code> 之后，我们只要启动 <code>Runner</code> 然后和 <code>CI</code> 绑定就可以了：</p><ul><li>打开你 <code>GitLab</code> 中的项目页面，在项目设置中找到 <code>runners</code></li><li>运行 <code>sudo gitlab-ci-multi-runner register</code></li><li>输入 <code>CI URL</code></li><li>输入 <code>Token</code></li><li>输入 <code>Runner</code> 的名字</li><li>选择 <code>Runner</code> 的类型，简单起见还是选 <code>Shell</code> 吧</li><li>完成</li></ul><p>当注册好 <code>Runner</code> 之后，可以用 <code>sudo gitlab-ci-multi-runner list</code> 命令来查看各个 <code>Runner</code> 的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gitlab-runner list</span><br><span class="line">Listing configured runners          ConfigFile=/etc/gitlab-runner/config.toml</span><br><span class="line">my-runner                           Executor=shell Token=cd1cd7cf243afb47094677855aacd3 URL=http://mygitlab.com/ci</span><br></pre></td></tr></table></figure><h2 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a>.gitlab-ci.yml</h2><h3 id="配置简介"><a href="#配置简介" class="headerlink" title="配置简介"></a>配置简介</h3><p>配置好 <code>Runner</code> 之后，我们要做的事情就是在项目根目录中添加 <code>.gitlab-ci.yml</code> 文件了。 当我们添加了 <code>.gitlab-ci.yml</code> 文件后，每次提交代码或者合并 <code>MR</code> 都会自动运行构建任务了。</p><p>还记得 <code>Pipeline</code> 是怎么触发的吗？<code>Pipeline</code> 也是通过提交代码或者合并 <code>MR</code> 来触发的！ 那么 <code>Pipeline</code> 和 <code>.gitlab-ci.yml</code> 有什么关系呢？ 其实 <code>.gitlab-ci.yml</code> 就是在定义 <code>Pipeline</code> 而已拉！</p><h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p>我们先来看看 <code>.gitlab-ci.yml</code> 是怎么写的：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 stages</span></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">test</span></span><br><span class="line"><span class="comment"># 定义 job</span></span><br><span class="line"><span class="attr">job1:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">echo</span> <span class="string">"I am job1"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">echo</span> <span class="string">"I am in test stage"</span></span><br><span class="line"><span class="comment"># 定义 job</span></span><br><span class="line"><span class="attr">job2:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">echo</span> <span class="string">"I am job2"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">echo</span> <span class="string">"I am in build stage"</span></span><br></pre></td></tr></table></figure><p>写起来很简单吧！用 <code>stages</code> 关键字来定义 <code>Pipeline</code> 中的各个构建阶段，然后用一些非关键字来定义 <code>jobs</code>。 每个 <code>job</code> 中可以可以再用 <code>stage</code> 关键字来指定该 <code>job</code> 对应哪个 <code>stage</code>。 <code>job</code> 里面的 <code>script</code> 关键字是最关键的地方了，也是每个 <code>job</code> 中必须要包含的，它表示每个 <code>job</code> 要执行的命令。</p><p>回想一下我们之前提到的 <code>Stages</code> 和 <code>Jobs</code> 的关系，然后猜猜上面例子的运行结果？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am job2</span><br><span class="line">I am <span class="keyword">in</span> build stage</span><br><span class="line">I am job1</span><br><span class="line">I am <span class="keyword">in</span> test stage</span><br></pre></td></tr></table></figure><p>根据我们在 <code>stages</code> 中的定义，<code>build</code> 阶段要在 <code>test</code> 阶段之前运行，所以 <code>stage:build</code> 的 <code>jobs</code> 会先运行，之后才会运行 <code>stage:test</code> 的 <code>jobs</code>。</p><h3 id="常用的关键字"><a href="#常用的关键字" class="headerlink" title="常用的关键字"></a>常用的关键字</h3><p>下面介绍一些常用的关键字，想要更加详尽的内容请前往 <a href="https://docs.gitlab.com/ce/ci/yaml/README.html" target="_blank" rel="noopener">官方文档</a></p><h4 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h4><p>定义 <code>Stages</code>，默认有三个 <code>Stages</code>，分别是 <code>build, test, deploy</code>。</p><h4 id="types"><a href="#types" class="headerlink" title="types"></a>types</h4><p><code>stages</code> 的别名。</p><h4 id="before-script"><a href="#before-script" class="headerlink" title="before_script"></a>before_script</h4><p>定义任何 Jobs 运行前都会执行的命令。</p><h4 id="after-script"><a href="#after-script" class="headerlink" title="after_script"></a>after_script</h4><blockquote><p>要求 GitLab 8.7+ 和 GitLab Runner 1.2+</p></blockquote><p>定义任何 Jobs 运行完后都会执行的命令。</p><h4 id="variables-amp-amp-Job-variables"><a href="#variables-amp-amp-Job-variables" class="headerlink" title="variables &amp;&amp; Job.variables"></a>variables &amp;&amp; Job.variables</h4><blockquote><p>要求 GitLab Runner 0.5.0+</p></blockquote><p>定义环境变量。 如果定义了 <code>Job</code> 级别的环境变量的话，该 <code>Job</code> 会优先使用 <code>Job</code> 级别的环境变量。 <a href="https://docs.gitlab.com/ce/ci/variables/README.html" target="_blank" rel="noopener">查看更多</a></p><h4 id="cache-amp-amp-Job-cache"><a href="#cache-amp-amp-Job-cache" class="headerlink" title="cache &amp;&amp; Job.cache"></a>cache &amp;&amp; Job.cache</h4><blockquote><p>要求 GitLab Runner 0.7.0+</p></blockquote><p>定义需要缓存的文件。 每个 <code>Job</code> 开始的时候，<code>Runner</code> 都会删掉 <code>.gitignore</code> 里面的文件。 如果有些文件 (如 <code>node_modules/</code>) 需要多个 <code>Jobs</code> 共用的话，我们只能让每个 <code>Job</code> 都先执行一遍 <code>npm install</code>。 这样很不方便，因此我们需要对这些文件进行缓存。缓存了的文件除了可以跨 <code>Jobs</code> 使用外，还可以跨 <code>Pipeline</code> 使用。</p><p>具体用法请查看 <a href="http://docs.gitlab.com/ce/ci/yaml/README.html#cache" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="Job-script"><a href="#Job-script" class="headerlink" title="Job.script"></a>Job.script</h4><p>定义 <code>Job</code> 要运行的命令，必填项。</p><h4 id="Job-stage"><a href="#Job-stage" class="headerlink" title="Job.stage"></a>Job.stage</h4><p>定义 <code>Job</code> 的 <code>stage</code>，默认为 <code>test</code>。</p><h4 id="Job-artifacts"><a href="#Job-artifacts" class="headerlink" title="Job.artifacts"></a>Job.artifacts</h4><p>定义 <code>Job</code> 中生成的附件。 当该 <code>Job</code> 运行成功后，生成的文件可以作为附件 (如生成的二进制文件) 保留下来，打包发送到 <code>GitLab</code>，之后我们可以在 <code>GitLab</code> 的项目页面下下载该附件。 注意，不要把 <code>artifacts</code> 和 <code>cache</code> 混淆了。</p><h3 id="实用例子"><a href="#实用例子" class="headerlink" title="实用例子"></a>实用例子</h3><p>下面给出一个我自己在用的例子：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">install_deps</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">test</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">deploy_test</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">deploy_production</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">$&#123;CI_BUILD_REF_NAME&#125;</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules/</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">dist/</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="attr">install_deps:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">install_deps</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">develop</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="comment"># 运行测试用例</span></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">develop</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">develop</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="attr">build:client</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="attr">build:server</span></span><br><span class="line"><span class="comment"># 部署测试服务器</span></span><br><span class="line"><span class="attr">deploy_test:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy_test</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">develop</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">pm2</span> <span class="string">delete</span> <span class="string">app</span> <span class="string">||</span> <span class="literal">true</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">pm2</span> <span class="string">start</span> <span class="string">app.js</span> <span class="bullet">--name</span> <span class="string">app</span></span><br><span class="line"><span class="comment"># 部署生产服务器</span></span><br><span class="line"><span class="attr">deploy_production:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy_production</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">bash</span> <span class="string">scripts/deploy/deploy.sh</span></span><br></pre></td></tr></table></figure><p>上面的配置把一次 <code>Pipeline</code> 分成五个阶段：</p><ul><li>安装依赖(<code>install_deps</code>)</li><li>运行测试(<code>test</code>)</li><li>编译(<code>build</code>)</li><li>部署测试服务器(<code>deploy_test</code>)</li><li>部署生产服务器(<code>deploy_production</code>)</li></ul><p>设置 <code>Job.only</code> 后，只有当 <code>develop</code> 分支和 <code>master</code> 分支有提交的时候才会触发相关的 <code>Jobs</code>。注意，我这里用 <code>GitLab Runner</code> 所在的服务器作为测试服务器。</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）301、302、200、206、304、404等HTTP状态引见</title>
      <link href="/303.html"/>
      <url>/303.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考链接：<code>https://www.cnblogs.com/micua/p/3502691.html</code></p></blockquote><p>如果向您的服务器发出了某项请求要求显示您网站上的某个网页，那么，您的服务器会返回 <code>HTTP</code> 状态代码以响应该请求。 一些常见的状态代码为：</p><ul><li><code>200</code> - 服务器成功返回网页</li><li><code>404</code> - 请求的网页不存在</li><li><code>503</code> - 服务器暂时不可用</li></ul><p>以下提供了 <code>HTTP</code> 状态代码的完整列表。您也可以访问有关 <code>HTTP</code> 状态代码的 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">W3C</a> 来了解详细信息。</p><h2 id="1xx（临时响应）"><a href="#1xx（临时响应）" class="headerlink" title="1xx（临时响应）"></a>1xx（临时响应）</h2><p>用于表示临时响应并需要请求者执行操作才能继续的状态代码。</p><h3 id="100（继续）"><a href="#100（继续）" class="headerlink" title="100（继续）"></a>100（继续）</h3><p>请求者应当继续提出请求。服务器返回此代码则意味着，服务器已收到了请求的第一部分，现正在等待接收其余部分。</p><h3 id="101（切换协议）"><a href="#101（切换协议）" class="headerlink" title="101（切换协议）"></a>101（切换协议）</h3><p>请求者已要求服务器切换协议，服务器已确认并准备进行切换。</p><h3 id="2xx（成功）"><a href="#2xx（成功）" class="headerlink" title="2xx（成功）"></a>2xx（成功）</h3><p>用于表示服务器已成功处理了请求的状态代码。</p><h3 id="200（成功）"><a href="#200（成功）" class="headerlink" title="200（成功）"></a>200（成功）</h3><p>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果您的 <code>robots.txt</code> 文件显示为此状态，那么，这表示 <code>Googlebot</code> 已成功检索到该文件。</p><h3 id="201（已创建）"><a href="#201（已创建）" class="headerlink" title="201（已创建）"></a>201（已创建）</h3><p>请求成功且服务器已创建了新的资源。</p><h3 id="202（已接受）"><a href="#202（已接受）" class="headerlink" title="202（已接受）"></a>202（已接受）</h3><p>服务器已接受了请求，但尚未对其进行处理。</p><h3 id="203（非授权信息）"><a href="#203（非授权信息）" class="headerlink" title="203（非授权信息）"></a>203（非授权信息）</h3><p>服务器已成功处理了请求，但返回了可能来自另一来源的信息。</p><h3 id="204（无内容）"><a href="#204（无内容）" class="headerlink" title="204（无内容）"></a>204（无内容）</h3><p>服务器成功处理了请求，但未返回任何内容。</p><h3 id="205（重置内容）"><a href="#205（重置内容）" class="headerlink" title="205（重置内容）"></a>205（重置内容）</h3><p>服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。</p><h3 id="206（部分内容）"><a href="#206（部分内容）" class="headerlink" title="206（部分内容）"></a>206（部分内容）</h3><p>服务器成功处理了部分 GET 请求。</p><h2 id="3xx（已重定向）"><a href="#3xx（已重定向）" class="headerlink" title="3xx（已重定向）"></a>3xx（已重定向）</h2><p>要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。<code>Google</code> 建议您在每次请求时使用的重定向要少于 5 个。您可以使用网站管理员工具来查看 <code>Googlebot</code> 在抓取您已重定向的网页时是否会遇到问题。诊断下的抓取错误页中列出了 <code>Googlebot</code> 由于重定向错误而无法抓取的网址。</p><h3 id="300（多种选择）"><a href="#300（多种选择）" class="headerlink" title="300（多种选择）"></a>300（多种选择）</h3><p>服务器根据请求可执行多种操作。服务器可根据请求者 (<code>User agent</code>) 来选择一项操作，或提供操作列表供请求者选择。</p><h3 id="301（永久移动）"><a href="#301（永久移动）" class="headerlink" title="301（永久移动）"></a>301（永久移动）</h3><p>请求的网页已被永久移动到新位置。服务器返回此响应（作为对 <code>GET</code> 或 <code>HEAD</code> 请求的响应）时，会自动将请求者转到新位置。您应使用此代码通知 <code>Googlebot</code> 某个网页或网站已被永久移动到新位置。</p><h3 id="302（临时移动）"><a href="#302（临时移动）" class="headerlink" title="302（临时移动）"></a>302（临时移动）</h3><p>服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 <code>GET</code> 和 <code>HEAD</code> 请求的 <code>301</code> 代码类似，会自动将请求者转到不同的位置。但由于 <code>Googlebot</code> 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 <code>Googlebot</code> 某个页面或网站已被移动。</p><h3 id="303（查看其他位置）"><a href="#303（查看其他位置）" class="headerlink" title="303（查看其他位置）"></a>303（查看其他位置）</h3><p>当请求者应对不同的位置进行单独的 <code>GET</code> 请求以检索响应时，服务器会返回此代码。对于除 <code>HEAD</code> 请求之外的所有请求，服务器会自动转到其他位置。</p><h3 id="304（未修改）"><a href="#304（未修改）" class="headerlink" title="304（未修改）"></a>304（未修改）</h3><p>自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应（称为 <code>If-Modified-Since</code> <code>HTTP</code> 标头）。由于服务器可以告诉 <code>Googlebot</code> 自从上次抓取后网页没有更改过，因此可节省带宽和开销。</p><h3 id="305（使用代理）"><a href="#305（使用代理）" class="headerlink" title="305（使用代理）"></a>305（使用代理）</h3><p>请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。</p><h3 id="307（临时重定向）"><a href="#307（临时重定向）" class="headerlink" title="307（临时重定向）"></a>307（临时重定向）</h3><p>服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 <code>GET</code> 和 <code>HEAD</code> 请求的 <code>301</code> 代码类似，会自动将请求者转到不同的位置。但由于 <code>Googlebot</code> 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 <code>Googlebot</code> 某个页面或网站已被移动。</p><h2 id="4xx（请求错误）"><a href="#4xx（请求错误）" class="headerlink" title="4xx（请求错误）"></a>4xx（请求错误）</h2><p>这些状态代码表示，请求可能出错，已妨碍了服务器对请求的处理。</p><h3 id="400（错误请求）"><a href="#400（错误请求）" class="headerlink" title="400（错误请求）"></a>400（错误请求）</h3><p>服务器不理解请求的语法。</p><h3 id="401（未授权）"><a href="#401（未授权）" class="headerlink" title="401（未授权）"></a>401（未授权）</h3><p>请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。</p><h3 id="403（已禁止）"><a href="#403（已禁止）" class="headerlink" title="403（已禁止）"></a>403（已禁止）</h3><p>服务器拒绝请求。如果在 <code>Googlebot</code> 尝试抓取您网站上的有效网页时显示此状态代码（您可在 <code>Google</code> 网站管理员工具中诊 断下的网络抓取页面上看到此状态代码），那么，这可能是您的服务器或主机拒绝 <code>Googlebot</code> 对其进行访问。</p><h3 id="404（未找到）"><a href="#404（未找到）" class="headerlink" title="404（未找到）"></a>404（未找到）</h3><p>服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。</p><p>如果您的网站上没有 <code>robots.txt</code> 文件，而您在 <code>Google</code> 网站管理员工具” 诊断”标签的 <code>robots.txt</code> 页上发现此状态，那么，这是正确的状态。然而，如果您有 <code>robots.txt</code> 文件而又发现了此状态，那么，这说明您的 <code>robots.txt</code> 文件可能是命名错误或位于错误的位置。（该文件应当位于顶级域名上，且应当名为 <code>robots.txt</code>）。</p><p>如果您在 <code>Googlebot</code> 尝试抓取的网址上发现此状态（位于”诊断”标签的 HTTP 错误页上），那么，这表示 <code>Googlebot</code> 所追踪的可能是另一网页中的无效链接（旧链接或输入有误的链接）。</p><h3 id="405（方法禁用）"><a href="#405（方法禁用）" class="headerlink" title="405（方法禁用）"></a>405（方法禁用）</h3><p>禁用请求中所指定的方法。</p><h3 id="406（不接受）"><a href="#406（不接受）" class="headerlink" title="406（不接受）"></a>406（不接受）</h3><p>无法使用请求的内容特性来响应请求的网页。</p><h3 id="407（需要代理授权）"><a href="#407（需要代理授权）" class="headerlink" title="407（需要代理授权）"></a>407（需要代理授权）</h3><p>此状态代码与 401（未授权）类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。</p><h3 id="408（请求超时）"><a href="#408（请求超时）" class="headerlink" title="408（请求超时）"></a>408（请求超时）</h3><p>服务器等候请求时超时。</p><h3 id="409（冲突）"><a href="#409（冲突）" class="headerlink" title="409（冲突）"></a>409（冲突）</h3><p>服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 <code>PUT</code> 请求时可能会返回此代码，同时会提供两个请求的差异列表。</p><h3 id="410（已删除）"><a href="#410（已删除）" class="headerlink" title="410（已删除）"></a>410（已删除）</h3><p>如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 <code>404</code>（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 <code>404</code> 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。</p><h3 id="411（需要有效长度）"><a href="#411（需要有效长度）" class="headerlink" title="411（需要有效长度）"></a>411（需要有效长度）</h3><p>服务器不会接受包含无效内容长度标头字段的请求。</p><h3 id="412（未满足前提条件）"><a href="#412（未满足前提条件）" class="headerlink" title="412（未满足前提条件）"></a>412（未满足前提条件）</h3><p>服务器未满足请求者在请求中设置的其中一个前提条件。</p><h3 id="413（请求实体过大）"><a href="#413（请求实体过大）" class="headerlink" title="413（请求实体过大）"></a>413（请求实体过大）</h3><p>服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。</p><h2 id="414（请求的-URI-过长）"><a href="#414（请求的-URI-过长）" class="headerlink" title="414（请求的 URI 过长）"></a>414（请求的 URI 过长）</h2><p>请求的 URI（通常为网址）过长，服务器无法进行处理。</p><h3 id="415（不支持的媒体类型）"><a href="#415（不支持的媒体类型）" class="headerlink" title="415（不支持的媒体类型）"></a>415（不支持的媒体类型）</h3><p>请求的格式不受请求页面的支持。</p><h3 id="416（请求范围不符合要求）"><a href="#416（请求范围不符合要求）" class="headerlink" title="416（请求范围不符合要求）"></a>416（请求范围不符合要求）</h3><p>如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。</p><h3 id="417（未满足期望值）"><a href="#417（未满足期望值）" class="headerlink" title="417（未满足期望值）"></a>417（未满足期望值）</h3><p>服务器未满足”期望”请求标头字段的要求。</p><h3 id="5xx（服务器错误）"><a href="#5xx（服务器错误）" class="headerlink" title="5xx（服务器错误）"></a>5xx（服务器错误）</h3><p>这些状态代码表示，服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</p><h3 id="500（服务器内部错误"><a href="#500（服务器内部错误" class="headerlink" title="500（服务器内部错误"></a>500（服务器内部错误</h3><p>服务器遇到错误，无法完成请求。</p><h3 id="501（尚未实施）"><a href="#501（尚未实施）" class="headerlink" title="501（尚未实施）"></a>501（尚未实施）</h3><p>服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。</p><h3 id="502（错误网关）"><a href="#502（错误网关）" class="headerlink" title="502（错误网关）"></a>502（错误网关）</h3><p>服务器作为网关或代理，从上游服务器收到了无效的响应。</p><h3 id="503（服务不可用）"><a href="#503（服务不可用）" class="headerlink" title="503（服务不可用）"></a>503（服务不可用）</h3><p>目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。</p><h3 id="504（网关超时）"><a href="#504（网关超时）" class="headerlink" title="504（网关超时）"></a>504（网关超时）</h3><p>服务器作为网关或代理，未及时从上游服务器接收请求。</p><h3 id="505（HTTP-版本不受支持）"><a href="#505（HTTP-版本不受支持）" class="headerlink" title="505（HTTP 版本不受支持）"></a>505（HTTP 版本不受支持）</h3><p>服务器不支持相应请求中所用的 HTTP 协议版本。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）JS 原型与原型链详解</title>
      <link href="/277.html"/>
      <url>/277.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-普通对象与函数对象"><a href="#一-普通对象与函数对象" class="headerlink" title="一. 普通对象与函数对象"></a>一. 普通对象与函数对象</h3><p><code>JavaScript</code> 中，万物皆对象！但对象也是有区别的。分为<strong>普通对象</strong>和<strong>函数对象</strong>，<code>Object</code> 、<code>Function</code> 是 <code>JS</code> 自带的函数对象。下面举例说明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> f1();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'str'</span>, <span class="string">'console.log(str)'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>); <span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f2); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f3); <span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o1); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o2); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o3); <span class="comment">//object</span></span><br></pre></td></tr></table></figure><p>在上面的例子中 <code>o1 o2 o3</code> 为普通对象，<code>f1 f2 f3</code> 为函数对象。怎么区分，其实很简单，<strong>凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。</strong> 一定要分清楚普通对象和函数对象，下面我们会常常用到它。</p><h3 id="二-构造函数"><a href="#二-构造函数" class="headerlink" title="二. 构造函数"></a>二. 构造函数</h3><p>我们先复习一下构造函数的知识：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Zaxlct'</span>, <span class="number">28</span>, <span class="string">'Software Engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Mick'</span>, <span class="number">23</span>, <span class="string">'Doctor'</span>);</span><br></pre></td></tr></table></figure><p>上面的例子中 <code>person1</code> 和 <code>person2</code> 都是 <code>Person</code> 的<strong>实例</strong>。这两个实例都有一个 <code>constructor</code> （构造函数）属性，该属性（是一个指针）指向 <code>Person</code>。 即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor == Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>我们要记住两个概念（构造函数，实例）： <strong>person1 和 person2 都是构造函数 Person 的实例。</strong> 一个公式： <strong>实例的构造函数属性（constructor）指向构造函数。</strong></p><h3 id="三-原型对象"><a href="#三-原型对象" class="headerlink" title="三. 原型对象"></a>三. 原型对象</h3><p>在 <code>JavaScript</code> 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个<strong>函数对象</strong>都有一个 <code>prototype</code> 属性，这个属性指向函数的<strong>原型对象</strong>。 （先用不管什么是 <code>__proto__</code> 第二节的课程会详细的剖析）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'Zaxlct'</span>;</span><br><span class="line">Person.prototype.age = <span class="number">28</span>;</span><br><span class="line">Person.prototype.job = <span class="string">'Software Engineer'</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// 'Zaxlct'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">// 'Zaxlct'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>我们得到了本文第一个定律：</p><p><strong>每个对象都有 **proto</strong> 属性，但只有函数对象才有 prototype 属性**</p><p>那什么是<strong>原型对象</strong>呢？ 我们把上面的例子改一改你就会明白了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">'Zaxlct'</span>,</span><br><span class="line">  age: <span class="number">28</span>,</span><br><span class="line">  job: <span class="string">'Software Engineer'</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原型对象，顾名思义，它就是一个普通对象（废话 = =!）。从现在开始你要牢牢记住原型对象就是 <code>Person.prototype</code> ，如果你还是害怕它，那就把它想想成一个字母 <code>A</code>： <code>var A = Person.prototype</code></p><p>在上面我们给 <code>A</code> 添加了 四个属性：<code>name、age、job、sayName</code>。其实它还有一个默认的属性：<code>constructor</code></p><blockquote><p>在默认情况下，所有的原型对象都会自动获得一个 <code>constructor</code>（构造函数）属性，这个属性（是一个指针）指向 <code>prototype</code> 属性所在的函数（Person）</p></blockquote><p>上面这句话有点拗口，我们「翻译」一下：A 有一个默认的 <code>constructor</code> 属性，这个属性是一个指针，指向 <code>Person</code>。即： <code>Person.prototype.constructor == Person</code></p><p>在上面第二小节《构造函数》里，我们知道实例的构造函数属性（<code>constructor</code>）指向构造函数 ：<code>person1.constructor == Person</code></p><p>这两个「公式」好像有点联系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person1.constructor == Person;</span><br><span class="line">Person.prototype.constructor == Person;</span><br></pre></td></tr></table></figure><p><code>person1</code> 为什么有 <code>constructor</code> 属性？那是因为 <code>person1</code> 是 <code>Person</code> 的实例。 那 <code>Person.prototype</code> 为什么有 <code>constructor</code> 属性？？同理， <code>Person.prototype</code> （你把它想象成 <code>A</code>） 也是 <code>Person</code> 的实例。 也就是在 <code>Person</code> 创建的时候，创建了一个它的实例对象并赋值给它的 <code>prototype</code>，基本过程如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = A;</span><br></pre></td></tr></table></figure><p><strong>结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。</strong></p><p>原型对象其实就是普通对象（但 F<code>unction.prototype</code> 除外，它是函数对象，但它很特殊，他没有 <code>prototype</code> 属性（前面说道函数对象都有 <code>prototype</code> 属性））。看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype); <span class="comment">//Person&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype); <span class="comment">//Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype); <span class="comment">// Function，这个特殊</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype); <span class="comment">// Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.prototype); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p><code>Function.prototype</code> 为什么是函数对象呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">Function</span>.prototype = A;</span><br></pre></td></tr></table></figure><p><strong>上文提到凡是通过 new Function( ) 产生的对象都是函数对象。因为 A 是函数对象，所以 Function.prototype 是函数对象。</strong></p><p>那原型对象是用来做什么的呢？主要作用是用于继承。举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name; <span class="comment">// tip: 当函数执行时这个 this 指的是谁？</span></span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name; <span class="comment">// tip: 当函数执行时这个 this 指的是谁？</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> person(<span class="string">'Mick'</span>);</span><br><span class="line">person1.getName(); <span class="comment">//Mick</span></span><br></pre></td></tr></table></figure><p>从这个例子可以看出，通过给 <code>Person.prototype</code> 设置了一个函数对象的属性，那有 <code>Person</code> 的实例（<code>person1</code>）出来的普通对象就继承了这个属性。具体是怎么实现的继承，就要讲到下面的原型链了。</p><p>小问题，上面两个 <code>this</code> 都指向谁？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> person(<span class="string">'Mick'</span>);</span><br><span class="line">person1.name = <span class="string">'Mick'</span>; <span class="comment">// 此时 person1 已经有 name 这个属性了</span></span><br><span class="line">person1.getName(); <span class="comment">//Mick</span></span><br></pre></td></tr></table></figure><p>故两次 <code>this</code> 在函数执行时都指向 <code>person1</code>。</p><h3 id="四-proto"><a href="#四-proto" class="headerlink" title="四. __proto__"></a>四. <code>__proto__</code></h3><p><code>JS</code> 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<code>__proto__</code>的内置属性，用于指向创建它的构造函数的原型对象。 对象 <code>person1</code> 有一个<code>__proto__</code>属性，创建它的构造函数是 <code>Person</code>，构造函数的原型对象是 P<code>erson.prototype</code>，所以： <code>person1.__proto__ == Person.prototype</code></p><p><img src="http://cdn.flqin.com/p277-1.jpg" alt="__proto__"></p><p>根据上面这个连接图，我们能得到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor == Person;</span><br><span class="line">person1.__proto__ == Person.prototype;</span><br><span class="line">person1.constructor == Person;</span><br></pre></td></tr></table></figure><p><strong>不过，要明确的真正重要的一点就是，这个连接存在于实例（<code>person1</code>）与构造函数（<code>Person</code>）的原型对象（<code>Person.prototype</code>）之间，而不是存在于实例（<code>person1</code>）与构造函数（<code>Person</code>）之间。</strong></p><p>注意：因为绝大部分浏览器都支持<code>__proto__</code>属性，所以它才被加入了 <code>ES6</code> 里（<code>ES5</code> 部分浏览器也支持，但还不是标准）。</p><h3 id="五-构造器"><a href="#五-构造器" class="headerlink" title="五. 构造器"></a>五. 构造器</h3><p>熟悉 <code>Javascript</code> 的童鞋都知道，我们可以这样创建一个对象： <code>var obj = {}</code> 它等同于下面这样： <code>var obj = new Object()</code></p><p><code>obj</code> 是构造函数（<code>Object</code>）的一个实例。所以： <code>obj.constructor === Object</code> <code>obj.__proto__ === Object.prototype</code></p><p>新对象 <code>obj</code> 是使用 <code>new</code> 操作符后跟一个<strong>构造函数</strong>来创建的。构造函数（<code>Object</code>）本身就是一个函数（就是上面说的函数对象），它和上面的构造函数 <code>Person</code> 差不多。只不过该函数是出于创建新对象的目的而定义的。所以不要被 <code>Object</code> 吓倒。</p><p>同理，可以创建对象的构造器不仅仅有 <code>Object</code>，也可以是 <code>Array，Date，Function</code> 等。 所以我们也可以构造函数来创建 <code>Array、 Date、Function</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">b.constructor === <span class="built_in">Array</span>;</span><br><span class="line">b.__proto__ === <span class="built_in">Array</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">c.constructor === <span class="built_in">Date</span>;</span><br><span class="line">c.__proto__ === <span class="built_in">Date</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">d.constructor === <span class="built_in">Function</span>;</span><br><span class="line">d.__proto__ === <span class="built_in">Function</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>,<span class="built_in">Function</span>,<span class="built_in">Array</span>,<span class="built_in">Date</span>,<span class="built_in">Number</span>,<span class="built_in">String</span>,<span class="built_in">Boolean</span> 这些构造器都是函数对象.</span><br></pre></td></tr></table></figure><h3 id="六-原型链"><a href="#六-原型链" class="headerlink" title="六. 原型链"></a>六. 原型链</h3><p>小测试来检验一下你理解的怎么样：</p><p>1.<code>person1.__proto__</code> 是什么？ 2.<code>Person.__proto__</code> 是什么？ 3.<code>Person.prototype.__proto__</code> 是什么？ 4.<code>Object.__proto__</code> 是什么？ 5.<code>Object.prototype__proto__</code> 是什么？</p><p>答案： 第一题： 因为 <code>person1.__proto__ === person1 的构造函数.prototype</code> 因为 <code>person1的构造函数 === Person</code> 所以 <code>person1.__proto__ === Person.prototype</code></p><p>第二题： 因为 <code>Person.__proto__ === Person的构造函数.prototype</code> 因为 <code>Person的构造函数 === Function</code> 所以 <code>Person.__proto__ === Function.prototype</code></p><p>第三题： <code>Person.prototype</code> 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。 因为一个 <code>普通对象的构造函数 === Object</code> 所以 <code>Person.prototype.__proto__ === Object.prototype</code></p><p>第四题，参照第二题，因为 <code>Person</code> 和 <code>Object</code> 一样都是构造函数</p><p>第五题： <code>Object.prototype</code> 对象也有 <code>proto</code> 属性，但它比较特殊，为 <code>null</code>。因为 <code>null</code> 处于原型链的顶端，这个只能记住。 <code>Object.prototype.__proto__ === null</code></p><h3 id="七-函数对象-（复习一下前面的知识点）"><a href="#七-函数对象-（复习一下前面的知识点）" class="headerlink" title="七. 函数对象 （复习一下前面的知识点）"></a>七. 函数对象 （复习一下前面的知识点）</h3><p><strong>所有函数对象的 <code>proto</code> 都指向 <code>Function.prototype</code>，它是一个空函数（<code>Empty function</code>）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.constructor == <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RegExp</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">RegExp</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Error</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Date</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><code>JavaScript</code> 中有内置(<code>build-in</code>)构造器/对象共计 12 个（<code>ES5</code> 中新加了 <code>JSON</code>），这里列举了可访问的 8 个构造器。剩下如 <code>Global</code> <code>不能直接访问，Arguments</code> 仅在函数调用时由 <code>JS</code> 引擎创建，<code>Math</code>，<code>JSON</code> 是以对象形式存在的，无需 <code>new</code>。它们的<code>__proto__</code>是 <code>Object.prototype</code>。如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Math</span>.construrctor == <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.construrctor == <span class="built_in">Object</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>上面说的<strong>函数对象</strong>当然包括自定义的。如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> Perosn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Man.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这说明什么呢？</p><p><strong>所有的构造器都来自于 <code>Function.prototype</code>，甚至包括根构造器 <code>Object</code> 及 <code>Function</code> 自身。所有构造器都继承了 <code>Function.prototype</code> 的属性及方法。如 <code>length、call、apply、bind</code></strong></p><p>（你应该明白第一句话，第二句话我们下一节继续说，先挖个坑：）） <code>Function.prototype</code>也是唯一一个 <code>typeof XXX.prototype</code> 为 <code>function</code> 的 <code>prototype</code>。其它的构造器的 <code>prototype</code> 都是一个对象（原因第三节里已经解释过了）。如下（又复习了一遍）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Number</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Boolean</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">RegExp</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Error</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>噢，上面还提到它是一个空的函数，<code>console.log(Function.prototype)</code> 下看看（留意，下一节会再说一下这个）</p><p>知道了所有构造器（含内置及自定义）的<code>__proto__</code>都是<code>Function.prototype</code>，那<code>Function.prototype</code>的<code>__proto__</code>是谁呢？ 相信都听说过 <code>JavaScript</code> 中函数也是一等公民，那从哪能体现呢？如下 <code>console.log(Function.prototype.__proto__ === Object.prototype) // true</code> 这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了 <code>Object.prototype</code> 上的所有方法：<code>toString、valueOf、hasOwnProperty</code> 等。（你也应该明白第一句话，第二句话我们下一节继续说，不用挖坑了，还是刚才那个坑；））</p><p>最后 <code>Object.prototype</code> 的 <code>__proto__</code> 是谁？ <code>Object.prototype.__proto__ === null // true</code> 已经到顶了，为 <code>null</code>。(读到现在，再回过头看第五章，能明白吗？)</p><h3 id="八-Prototype"><a href="#八-Prototype" class="headerlink" title="八. Prototype"></a>八. Prototype</h3><blockquote><p>在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 <code>prototype</code> 属性了。对于 ECMAScript 中的引用类型而言，prototype 是保存着它们所有实例方法的真正所在。换句话所说，诸如 toString()和 valuseOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。</p></blockquote><p>我们知道 JS 内置了一些方法供我们使用，比如： 对象可以用 <code>constructor/toString()/valueOf()</code> 等方法; 数组可以用 <code>map()/filter()/reducer()</code> 等方法； 数字可用用 <code>parseInt()/parseFloat()</code>等方法； Why ？？？</p><p><strong>当我们创建一个函数时：</strong> <code>var Person = new Object()</code> <code>Person</code> 是 <code>Object</code> 的实例，所以 <code>Person</code> 继承了 <code>Object</code> 的原型对象 <code>Object.prototype</code> 上所有的方法。</p><p><strong>Object 的每个实例都具有 Object.prototype 的属性和方法。</strong> 所以我可以用 <code>Person.constructor</code> 也可以用 <code>Person.hasOwnProperty</code>。</p><p><strong>当我们创建一个数组时：</strong></p><p><code>var num = new Array()</code> <code>num</code> 是 <code>Array</code> 的实例，所以 <code>num</code> <strong>继承</strong>了 <code>Array</code> 的原型对象 <code>Array.prototype</code> 上所有的方法。 <code>Array.prototype =&gt; []</code> 这尼玛怎么是一个空数组？？？</p><p>我们可以用一个 <code>ES5</code> 提供的新方法：<code>Object.getOwnPropertyNames</code> 获取所有（包括不可枚举的属性）的属性名不包括 <code>prototy</code> 中的属性，返回一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayAllKeys = <span class="built_in">Array</span>.prototype; <span class="comment">// [] 空数组</span></span><br><span class="line"><span class="comment">// 只得到 arrayAllKeys 这个对象里所有的属性名(不会去找 arrayAllKeys.prototype 中的属性)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(arrayAllKeys));</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">    ["length", "constructor", "toString", "toLocaleString", "join", "pop", "push",</span></span><br><span class="line"><span class="comment">    "concat", "reverse", "shift", "unshift", "slice", "splice", "sort", "filter", "forEach",</span></span><br><span class="line"><span class="comment">    "some", "every", "map", "indexOf", "lastIndexOf", "reduce", "reduceRight",</span></span><br><span class="line"><span class="comment">    "entries", "keys", "copyWithin", "find", "findIndex", "fill"]</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><p>这样你就明白了随便声明一个数组，它为啥能用那么多方法了。</p><p>细心的你肯定发现了 <code>Object.getOwnPropertyNames(arrayAllKeys)</code> 输出的数组里并没有 <code>constructor/hasOwnPrototype</code> 等<strong>对象</strong>的方法（你肯定没发现）。 但是随便定义的数组也能用这些方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(num.hasOwnPrototype()); <span class="comment">// false (输出布尔值而不是报错)</span></span><br></pre></td></tr></table></figure><p>Why ？？？</p><p>因为<code>Array.prototype</code>虽然没这些方法，但是它有原型对象（<code>__proto__</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面我们说了 Object.prototype 就是一个普通对象。</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype;</span><br></pre></td></tr></table></figure><p>所以 <code>Array.prototype</code> 继承了对象的所有方法，当你用 <code>num.hasOwnPrototype()</code> 时，<code>JS</code> 会先查一下它的构造函数 （<code>Array</code>） 的原型对象 <code>Array.prototype</code> 有没有有 <code>hasOwnPrototype()</code> 方法，没查到的话继续查一下 <code>Array.prototype</code> 的原型对象 <code>Array.prototype.__proto__</code>有没有这个方法。</p><p><strong>当我们创建一个函数时：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'return x*x;'</span>);</span><br><span class="line"><span class="comment">//当然你也可以这么创建 f = function(x)&#123; return x*x &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.arguments); <span class="comment">// arguments 方法从哪里来的？</span></span><br><span class="line"><span class="built_in">console</span>.log(f.call(<span class="built_in">window</span>)); <span class="comment">// call 方法从哪里来的？</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype); <span class="comment">// function() &#123;&#125; （一个空的函数）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Function</span>.prototype));</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">    ["length", "name", "arguments", "caller", "constructor", "bind", "toString", "call", "apply"]</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><p>我们再复习第八小节这句话：</p><blockquote><p>所有<strong>函数对象 proto</strong>都指向 <code>Function.prototype</code>，它是一个空函数（<code>Empty function</code>）</p></blockquote><p>嗯，我们验证了它就是空函数。不过不要忽略前半句。我们枚举出了它的所有的方法，所以所有的<strong>函数对象</strong>都能用。</p><p>如果你还没搞懂啥是函数对象？</p><p>还有，我建议你可以再复习下为什么：</p><blockquote><p><code>Function.prototype</code> 是唯一一个 <code>typeof XXX.prototype</code> 为 <code>function</code> 的 <code>prototype</code></p></blockquote><h3 id="九-复习一下"><a href="#九-复习一下" class="headerlink" title="九. 复习一下"></a>九. 复习一下</h3><p>第八小节我们总结了：</p><p><strong>所有函数对象的 <code>__proto__</code> 都指向 <code>Function.prototype</code>，它是一个空函数（<code>Empty function</code>）</strong></p><p>但是你可别忘了在第三小节我们总结的：</p><p><strong>所有对象的 <code>__proto__</code> 都指向其构造器的 <code>prototype</code></strong></p><p>先看看 <code>JS</code> 内置构造器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'jack'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/hello/g</span>;</span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'exception'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__ === <span class="built_in">Array</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.__proto__ === <span class="built_in">RegExp</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(date.__proto__ === <span class="built_in">Date</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(err.__proto__ === <span class="built_in">Error</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>再看看自定义的构造器，这里定义了一个 <code>Person</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>p</code> 是 <code>Person</code> 的实例对象，<code>p</code> 的内部原型总是指向其构造器 <code>Person</code> 的原型对象 <code>prototype</code>。</p><p>每个对象都有一个 <code>constructor</code> 属性，可以获取它的构造器，因此以下打印结果也是恒等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面的 <code>Person</code> 没有给其原型添加属性或方法，这里给其原型添加一个 <code>getName</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>p.__proto__</code> 与 <code>Person.prototype</code>，<code>p.constructor.prototype</code> 都是恒等的，即都指向同一个对象。</p><p>如果换一种方式设置原型，结果就有些不同了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写原型</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这里直接重写了 <code>Person.prototype</code>（注意：上一个示例是修改原型）。输出结果可以看出 <code>p.__proto__</code> 仍然指向的是 <code>Person.prototype</code>，而不是 <code>p.constructor.prototype</code>。</p><p>这也很好理解，给<code>Person.prototype</code>赋值的是一个对象直接量<code>{getName: function(){}}</code>，使用对象直接量方式定义的对象其构造器（<code>constructor</code>）指向的是根构造器 <code>Object</code>，<code>Object.prototype</code> 是一个空对象<code>{}</code>，<code>{}</code>自然与<code>{getName: function(){}}</code>不等。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype); <span class="comment">// 为一个空的对象&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.constructor === <span class="built_in">Object</span>); <span class="comment">// 对象直接量方式定义的对象其constructor为Object</span></span><br><span class="line"><span class="built_in">console</span>.log(p.constructor.prototype === <span class="built_in">Object</span>.prototype); <span class="comment">// 为true，不解释(๑ˇ3ˇ๑)</span></span><br></pre></td></tr></table></figure><h3 id="十-原型链（再复习一下：）"><a href="#十-原型链（再复习一下：）" class="headerlink" title="十. 原型链（再复习一下：）"></a>十. 原型链（再复习一下：）</h3><p>下面这个例子你应该能明白了！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">Person.__proto__ == <span class="built_in">Function</span>.prototype; <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype); <span class="comment">// function()&#123;&#125; (空函数)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__ == <span class="built_in">Array</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype); <span class="comment">// [] (空数组)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__ == <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>疑点解惑：</p><p>1.<code>Object.__proto__ === Function.prototype // true</code> <code>Object</code> 是函数对象，是通过<code>new Function()</code>创建的，所以<code>Object.__proto__</code>指向<code>Function.prototype</code>。（参照第八小节：「所有函数对象的<code>__proto__</code>都指向<code>Function.prototype</code>」）</p><p>2.<code>Function.__proto__ === Function.prototype // true</code> <code>Function</code> 也是对象函数，也是通过<code>new Function()</code>创建，所以<code>Function.__proto__</code>指向<code>Function.prototype</code>。</p><blockquote><p>自己是由自己创建的，好像不符合逻辑，但仔细想想，现实世界也有些类似，你是怎么来的，你妈生的，你妈怎么来的，你姥姥生的，……类人猿进化来的，那类人猿从哪来，一直追溯下去……，就是无，（NULL 生万物） 正如《道德经》里所说“无，名天地之始”。</p></blockquote><p>3.<code>Function.prototype.__proto__ === Object.prototype //true</code></p><blockquote><p>其实这一点我也有点困惑，不过也可以试着解释一下。 <code>Function.prototype</code>是个函数对象，理论上他的<code>__proto__</code>应该指向 <code>Function.prototype</code>，就是他自己，自己指向自己，没有意义。 JS 一直强调万物皆对象，函数对象也是对象，给他认个祖宗，指向<code>Object.prototype</code>。<code>Object.prototype.__proto__ === null</code>，保证原型链能够正常结束。</p></blockquote><h3 id="十一-总结"><a href="#十一-总结" class="headerlink" title="十一.总结"></a>十一.总结</h3><ul><li>原型和原型链是 JS 实现继承的一种模型。</li><li>原型链的形成是真正是靠<code>__proto__</code>而非<code>prototype</code></li></ul><p>要深入理解这句话，我们再举个例子，看看前面你真的理解了吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">animal.price = <span class="number">2000</span>;</span><br><span class="line">dog.prototype = animal;</span><br><span class="line"><span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line"><span class="built_in">console</span>.log(dog.price); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(tidy.price); <span class="comment">// 2000</span></span><br></pre></td></tr></table></figure><p>这里解释一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">dog.prototype.price = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line"><span class="built_in">console</span>.log(tidy.price); <span class="comment">// 2000</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.price); <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line">tidy.price = <span class="number">2000</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dog.price); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>这个明白吧？想一想我们上面说过这句话：</p><blockquote><p>实例（<code>tidy</code>）和 原型对象（<code>dog.prototype</code>）存在一个连接。不过，要明确的真正重要的一点就是，这个连接存在于实例（<code>tidy</code>）与构造函数的原型对象（<code>dog.prototype</code>）之间，而不是存在于实例（<code>tidy</code>）与构造函数（<code>dog</code>）之间。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同一台电脑关于多个SSH KEY管理</title>
      <link href="/273.html"/>
      <url>/273.html</url>
      
        <content type="html"><![CDATA[<h2 id="比如有-aaa-bbb-ccc-三个帐号需要生成不同的-PUBLIC-KEY"><a href="#比如有-aaa-bbb-ccc-三个帐号需要生成不同的-PUBLIC-KEY" class="headerlink" title="比如有 aaa,bbb,ccc 三个帐号需要生成不同的 PUBLIC KEY"></a>比如有 aaa,bbb,ccc 三个帐号需要生成不同的 PUBLIC KEY</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa):/root/.ssh/id_rsa_aaa</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa_aaa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa_aaa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">9b:92:f6:1f:d2:72:bd:72:19:45:42:5f:e4:65:33:64 root@AY140122145815620396Z</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+--[ RSA 2048]----+</span></span><br><span class="line"><span class="string">|           .. .E=|</span></span><br><span class="line"><span class="string">|            ..o++|</span></span><br><span class="line"><span class="string">|             o. .|</span></span><br><span class="line"><span class="string">|              .  |</span></span><br><span class="line"><span class="string">|        S    .   |</span></span><br><span class="line"><span class="string">|       . + ..    |</span></span><br><span class="line"><span class="string">|      + = + .o   |</span></span><br><span class="line"><span class="string">|     . o +..o.   |</span></span><br><span class="line"><span class="string">|        ...o.    |</span></span><br><span class="line"><span class="string">+-----------------+</span></span><br></pre></td></tr></table></figure><p>我们在 <code>/root/.ssh/</code> 目录下创建 <code>id_rsa_aaa</code> 私钥 和 <code>id_rsa_aaa.pub</code> 公钥.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa):/root/.ssh/id_rsa_aaa  <span class="comment">#设置路径,如果不设置默认生成 id_rsa  和  id_rsa.pub</span></span><br></pre></td></tr></table></figure><h2 id="按照上面的步骤逐个生成-bbb-和-ccc-对应的公钥和私钥"><a href="#按照上面的步骤逐个生成-bbb-和-ccc-对应的公钥和私钥" class="headerlink" title="按照上面的步骤逐个生成 bbb 和 ccc 对应的公钥和私钥"></a>按照上面的步骤逐个生成 bbb 和 ccc 对应的公钥和私钥</h2><h2 id="查看系统-ssh-key-代理-执行如下命令"><a href="#查看系统-ssh-key-代理-执行如下命令" class="headerlink" title="查看系统 ssh-key 代理,执行如下命令"></a>查看系统 ssh-key 代理,执行如下命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add -l</span><br><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure><p>如果发现上面的提示,说明系统代理里没有任何 <code>key</code>,执行如下操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> ssh-agent bash</span><br></pre></td></tr></table></figure><p>如果系统已经有 <code>ssh-key</code> 代理 ,执行下面的命令可以删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -D</span><br></pre></td></tr></table></figure><h2 id="把-ssh-目录下的-3-个私钥添加的-ssh-agent"><a href="#把-ssh-目录下的-3-个私钥添加的-ssh-agent" class="headerlink" title="把 .ssh 目录下的 3 个私钥添加的 ssh-agent"></a>把 .ssh 目录下的 3 个私钥添加的 ssh-agent</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa_aaa</span><br><span class="line">ssh-add ~/.ssh/id_rsa_bbb</span><br><span class="line">ssh-add ~/.ssh/id_rsa_ccc</span><br></pre></td></tr></table></figure><p>依次执行上面三条 <code>shell</code> 把三个私钥添加到 <code>ssh-key</code> 代理里面。</p><h2 id="打开-github-或者-开源中国-ssh-管理页面把-对应的公钥提交保存到代码管理服务器-pub-结尾"><a href="#打开-github-或者-开源中国-ssh-管理页面把-对应的公钥提交保存到代码管理服务器-pub-结尾" class="headerlink" title="打开 github 或者 开源中国 ssh 管理页面把 对应的公钥提交保存到代码管理服务器 (.pub 结尾)"></a>打开 github 或者 开源中国 ssh 管理页面把 对应的公钥提交保存到代码管理服务器 (.pub 结尾)</h2><h2 id="在-ssh-目录创建-config-配置文件"><a href="#在-ssh-目录创建-config-配置文件" class="headerlink" title="在 .ssh 目录创建 config 配置文件"></a>在 .ssh 目录创建 config 配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.ssh/config</span><br></pre></td></tr></table></figure><p>输入如下配置信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#aaa  (github 配置)</span></span><br><span class="line">Host aaa</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_aaa</span><br><span class="line"></span><br><span class="line"><span class="comment">#bbb  (开源中国 配置)</span></span><br><span class="line">Host bbb</span><br><span class="line">    HostName git.oschina.net</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_bbb</span><br><span class="line"></span><br><span class="line"><span class="comment">#ccc</span></span><br><span class="line">........</span><br></pre></td></tr></table></figure><h2 id="记住上面一步-Host-里设置的别名-开始克隆项目-以开源中国为例"><a href="#记住上面一步-Host-里设置的别名-开始克隆项目-以开源中国为例" class="headerlink" title="记住上面一步 Host 里设置的别名,开始克隆项目,以开源中国为例"></a>记住上面一步 Host 里设置的别名,开始克隆项目,以开源中国为例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@git.oschina.net:userName/projectName.git</span><br></pre></td></tr></table></figure><p>到此为止多个 <code>ssh-key</code> 已经可以同时使用.</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）JavaScript 垃圾回收</title>
      <link href="/259.html"/>
      <url>/259.html</url>
      
        <content type="html"><![CDATA[<p>根据 Wiki 的定义，垃圾回收是一种自动的内存管理机制。当计算机上的动态内存不再需要时，就应该予以释放，以让出内存。直白点讲，就是程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量、函数等只有产生没有消亡的过程，那迟早内存有被完全占用的时候。这个时候，不仅自己的程序无法正常运行，连其他程序也会受到影响。好比生物只有出生没有死亡，地球总有被撑爆的一天。所以，在计算机中，我们需要垃圾回收。需要注意的是，定义中的“自动”的意思是语言可以帮助我们回收内存垃圾，但并不代表我们不用关心内存管理，如果操作失当，<code>JavaScript</code> 中依旧会出现内存溢出的情况。</p><p>垃圾回收基于两个原理：</p><ul><li>考虑某个变量或对象在未来的程序运行中将不会被访问</li><li>向这些对象要求归还内存</li></ul><p>而这两个原理中，最主要的也是最艰难的部分就是找到“所分配的内存确实已经不再需要了”。</p><h2 id="垃圾回收方法"><a href="#垃圾回收方法" class="headerlink" title="垃圾回收方法"></a>垃圾回收方法</h2><p>下面我们看看在 <code>JavaScript</code> 中是如何找到不再使用的内存的。主要有两种方式：引用计数和标记清除。</p><h3 id="引用计数（reference-counting）"><a href="#引用计数（reference-counting）" class="headerlink" title="引用计数（reference counting）"></a>引用计数（reference counting）</h3><p>在内存管理环境中，对象 <code>A</code> 如果有访问对象 <code>B</code> 的权限，叫做对象 <code>A</code> 引用对象 <code>B</code>。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收。上例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;; <span class="comment">// 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1</span></span><br><span class="line"><span class="keyword">let</span> obj2 = obj1; <span class="comment">// A 的引用个数变为 2</span></span><br><span class="line"></span><br><span class="line">obj1 = <span class="number">0</span>; <span class="comment">// A 的引用个数变为 1</span></span><br><span class="line">obj2 = <span class="number">0</span>; <span class="comment">// A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了</span></span><br></pre></td></tr></table></figure><p>但是引用计数有个最大的问题： 循环引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  obj1.a = obj2; <span class="comment">// obj1 引用 obj2</span></span><br><span class="line">  obj2.a = obj1; <span class="comment">// obj2 引用 obj1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数 <code>func</code> 执行结束后，返回值为 <code>undefined</code>，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，<code>obj1</code> 和 <code>obj2</code> 的引用次数都不为 0，所以他们不会被回收。</p><p>要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。上面的例子可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1 = <span class="literal">null</span>;</span><br><span class="line">obj2 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="标记-清除（mark-and-sweep）"><a href="#标记-清除（mark-and-sweep）" class="headerlink" title="标记-清除（mark and sweep）"></a>标记-清除（mark and sweep）</h3><p>这是 <code>JavaScript</code> 中最常见的垃圾回收方式。为什么说这是种最常见的方法，因为从 2012 年起，所有现代浏览器都使用了<code>标记-清除</code>的垃圾回收方法，除了低版本 IE…它们采用的是引用计数方法。</p><p>那什么叫标记清除呢？</p><p><code>JavaScript</code> 中有个全局对象，浏览器中是 <code>window</code>。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象…对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。</p><p>标记－清除法的一个问题就是不那么有效率，因为在标记－清除阶段，整个程序将会等待，所以如果程序出现卡顿的情况，那有可能是收集垃圾的过程。</p><p>2012 年起，所有现代浏览器都使用了这个方法，所有的改进也都是基于这个方法，比如<code>标记-整理</code>方法。</p><p>标记清除有一个问题，就是在清除之后，内存空间是不连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而<code>标记-整理</code>方法可以有效地解决这个问题。标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。不过可以想象，这种做法的效率没有标记-清除高。计算机中的很多做法都是互相妥协的结果，哪有什么十全十美的事儿呢。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>在谈什么是良好实践（这里指有益于内存管理）之前，我想先谈谈内存泄漏，也就是差的实践。内存泄漏是指计算机可用的内存越来越少，主要是因为程序不能释放那些不再使用的内存。</p><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>这个没什么好说的，上面已经介绍了。</p><p>需要强调的一点就是，一旦数据不再使用，最好通过将其值设为 <code>null</code> 来释放其引用，这个方法被称为“解除引用”。</p><h3 id="无意的全局变量"><a href="#无意的全局变量" class="headerlink" title="无意的全局变量"></a>无意的全局变量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bar = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>当 <code>foo</code> 函数执行后，变量 <code>bar</code> 就会被标记为可回收。因为当函数执行时，函数创造了一个作用域来让函数里的变量在里面声明。进入这个作用域后，浏览器就会为变量 <code>bar</code> 创建一个内存空间。当这个函数结束后，其所创建的作用域里的变量也会被标记为垃圾，在下一个垃圾回收周期到来时，这些变量将会被回收。</p><p>但事情并不会那么顺利。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  bar = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面的代码就无意中声明了一个全局变量，会得到 <code>window</code> 的引用，<code>bar</code> 实际上是 <code>window.bar</code>，它的作用域在 <code>window</code> 上，所以 <code>foo</code> 函数执行结束后，<code>bar</code> 也不会被内存收回。</p><p>另外一种无意的全局变量的情况是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.bar = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>foo</code> 函数中，<code>this</code> 指的是 <code>window</code>，犯的错误跟上面类似。</p><h3 id="被遗忘的计时器和回调函数"><a href="#被遗忘的计时器和回调函数" class="headerlink" title="被遗忘的计时器和回调函数"></a>被遗忘的计时器和回调函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someResource = getData();</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'Node'</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面的例子中，我们每隔一秒就将得到的数据放入到文档节点中去。但在 <code>setInterval</code> 没有结束前，回调函数里的变量以及回调函数本身都无法被回收。那什么才叫结束呢？就是调用了 <code>clearInterval</code>。如果回调函数内没有做什么事情，并且也没有被 <code>clear</code> 掉的话，就会造成内存泄漏。不仅如此，如果回调函数没有被回收，那么回调函数内依赖的变量也没法被回收。上面的例子中，<code>someResource</code> 就没法被回收。同样的，<code>setTiemout</code> 也会有同样的问题。所以，当不需要 <code>interval</code> 或者 <code>timeout</code> 时，最好调用 <code>clearInterval</code> 或者 <code>clearTimeout</code>。</p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>在 IE8 以下的版本里，<code>DOM</code> 对象经常会跟 <code>JavaScript</code> 之间产生循环引用。看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">'id'</span>);</span><br><span class="line">  ele.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>DOM</code> 对象通过 <code>onclick</code> 引用了一个函数，然而这个函数通过外部的词法环境引用了这个 <code>DOM</code> 对象，形成了循环引用。不过现在不必担心，因为所有现代浏览器都采用了标记－整理方法，避免了循环引用的问题。</p><p>除了这种情况，我们现在还会在其他时候在使用 <code>DOM</code> 时出现内存泄漏的问题。当我们需要多次访问同一个 <code>DOM</code> 元素时，一个好的做法是将 <code>DOM</code> 元素用一个变量存储在内存中，因为访问 <code>DOM</code> 的效率一般比较低，应该避免频繁地反问 <code>DOM</code> 元素。所以我们会这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</span><br></pre></td></tr></table></figure><p>当删除这个按钮时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`document.body.removeChild(document.getElementById('button'));</span></span><br></pre></td></tr></table></figure><p>虽然这样看起来删除了这个 <code>DOM</code> 元素，但这个 <code>DOM</code> 元素仍然被 <code>button</code> 这个变量引用，所以在内存上，这个 <code>DOM</code> 元素是没法被回收的。所以在使用结束后，还需要将 <code>button</code> 设成 <code>null。</code></p><p>另外一个值得注意的是，代码中保存了一个列表 <code>ul</code> 的某一项 <code>li</code> 的引用，将来决定删除整个列表时，我们自觉上会认为内存仅仅会保留那个特定的 <code>li</code>，而将其他列表项都删除。但事实并非如此，因为 <code>li</code> 是 <code>ul</code> 的子元素，子元素与父元素是引用关系，所以如果代码保存 <code>li</code> 的引用，那么整个 <code>ul</code> 将会继续呆在内存里。</p><h2 id="良好实践"><a href="#良好实践" class="headerlink" title="良好实践"></a>良好实践</h2><ol><li><p>优化内存的一个最好的衡量方式就是只保留程序运行时需要的数据，对于已经使用的或者不需要的数据，应该将其值设为 <code>null</code>，这上面说过，叫“解除引用”。需要注意的是，解除一个值的引用不代表垃圾回收器会立即将这段内存回收，这样做的目的是让垃圾回收器在下一个回收周期到来时知道这段内存需要回收。</p></li><li><p>在内存泄漏部分，我们讨论了无意的全局变量会带来无法回收的内存垃圾。但有些时候，我们会有意识地声明一些全局变量，这个时候需要注意，如果声明的变量占用大量的内存，那么在使用完后将变量声明为 <code>null</code>。</p></li><li><p>减少内存垃圾的另一个方法就是避免创建对象。<code>new Object()</code> 是一个比较明显的创建对象的方式，另外 <code>const arr = [];、const obj = {};</code> 也会创建新的对象。另外下面这种写法在每次调用函数时都会创建一个新的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当清空一个数组时，我们通常的做法是 <code>array = []</code>，但这种做法的背后是新建了一个新的数组然后将原来的数组当作内存垃圾。建议的做法是 <code>array.length = 0</code>，这样做不仅可以重用原来的变量，而且还避免创建了新的数组。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）js数组去重</title>
      <link href="/257.html"/>
      <url>/257.html</url>
      
        <content type="html"><![CDATA[<h2 id="嵌套循环比较"><a href="#嵌套循环比较" class="headerlink" title="嵌套循环比较"></a>嵌套循环比较</h2><p>两层 <code>for</code> 循环，<code>for</code> 循环中每次从原数组中取出一个元素，用这个元素循环与结果数组对比。若结果数组中没有该元素，则存到结果数组中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_towFor =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_towFor ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">    result.push(<span class="keyword">this</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> notIn = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; result.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>[i] == result[j]) &#123;</span><br><span class="line">          notIn = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (notIn) &#123;</span><br><span class="line">        result.push(<span class="keyword">this</span>[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="临时数组保存"><a href="#临时数组保存" class="headerlink" title="临时数组保存"></a>临时数组保存</h2><p>算法的基本思想就是把去重后的结果放在一个临时数组中。对原来数组的元素与临时数组元素比较，临时数组中不存在这个元素的，放入临时数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_tempArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_tempArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = []; <span class="comment">//临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result.indexOf(<span class="keyword">this</span>[i]) == <span class="number">-1</span>) &#123;</span><br><span class="line">        result.push(<span class="keyword">this</span>[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="利用对象去重-基础常用"><a href="#利用对象去重-基础常用" class="headerlink" title="利用对象去重(基础常用)"></a>利用对象去重(基础常用)</h2><p>创建一个新的数组存放结果，和一个空对象。<code>for</code> 循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值，存入到对象中。这个方法用作统计也很方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_objectArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_objectArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj[<span class="keyword">this</span>[i]]) &#123;</span><br><span class="line">        obj[<span class="keyword">this</span>[i]] = <span class="number">1</span>;</span><br><span class="line">        result.push(<span class="keyword">this</span>[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj[<span class="keyword">this</span>[i]]++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="先排序，后去重"><a href="#先排序，后去重" class="headerlink" title="先排序，后去重"></a>先排序，后去重</h2><p>先把数组排序，然后比较相邻的两个值。 排序的时候用的 <code>JS</code> 原生的 <code>sort</code> 方法，<code>JS</code> 引擎内部用的是快速排序，此方法速度比较快！无语中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_sortArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_sortArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sort();</span><br><span class="line">    <span class="keyword">var</span> result = [<span class="keyword">this</span>[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>[i] !== result[result.length - <span class="number">1</span>]) &#123;</span><br><span class="line">        result.push(<span class="keyword">this</span>[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="利用-ES6-的-Set-对象和-Array-from-方法"><a href="#利用-ES6-的-Set-对象和-Array-from-方法" class="headerlink" title="利用 ES6 的 Set 对象和 Array.from 方法"></a>利用 ES6 的 Set 对象和 Array.from 方法</h2><ul><li><code>Set</code> 对象可以是任何类型的单个值的集合。它是 <code>ES6</code> 新增的有序列表集合，它不会包含重复项。之前我们通常用对象(<code>Object</code>)或者数组(<code>Array</code>)来实现没有重复项的集合。</li><li><code>Array.from()</code>方法可以将一个类数组对象或可遍历对象转换成真正的数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_es6SetArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_esSetArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>));</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="利用-filter-和-Map-对象"><a href="#利用-filter-和-Map-对象" class="headerlink" title="利用 filter 和 Map 对象"></a>利用 filter 和 Map 对象</h2><p><code>filter()</code> 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_filterArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_filterArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> arr.indexOf(item) === index;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>既然可以使用 <code>filter</code> 的方法，那么也可以使用 <code>filter</code> 加 <code>object</code> 的方法，这里使用 <code>Map</code> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_es6MapArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_es6MapArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">      !seen.has(item) &amp;&amp; seen.set(item, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>这里的 <code>filter</code> 函数可以简化，当然也有人这样写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_es6MapArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_es6MapArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="params">a</span> =&gt;</span> !seen.has(a) &amp;&amp; seen.set(a, <span class="number">1</span>));</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="使用第三方"><a href="#使用第三方" class="headerlink" title="使用第三方"></a>使用第三方</h2><p>最后，可以使用第三方库函数 <code>jquery</code> 和 <code>underscore</code> 或者 <code>lodash</code>。 下面以 <code>lodash</code> 和 <code>underscore</code> 为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_3partyArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_3partyArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.uniq(arr); <span class="comment">//要先引入lodash.js或者underscore.js</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js判断变量是否是dom对象</title>
      <link href="/254.html"/>
      <url>/254.html</url>
      
        <content type="html"><![CDATA[<p>我们在写 <code>js</code> 代码时有时需要判断某个对象是不是 <code>DOM</code> 对象，然后再进行后续的操作，这里我给出一种兼容各大浏览器，同时又算是比较稳妥的一种方法。</p><p>要判断一个对象是否 <code>DOM</code> 对象，首先想到的无非就是它是否具有 <code>DOM</code> 对象的各种属性或特征，比如是否有 <code>nodeType</code> 属性，有 <code>tagName</code> 属性，等等。判断的特征越多，也就越可靠，因为毕竟我们自定义的 <code>js</code> 对象也可以有那些属性。还有其他方法吗?</p><p>在 <code>DOM Level2</code> 标准中定义了一个 <code>HTMLElement</code> 对象，它规定所有的 <code>DOM</code> 对象都是 <code>HTMLElement</code> 的实例，所以我们可以利用这点来判断一个对象是不是 <code>DOM</code> 对象: 如果该对象是 <code>HTMLElement</code> 的实例，则它肯定是一个 <code>DOM</code> 对象。在不支持 <code>HTMLElement</code> 的浏览器中我们则还是使用特征检测法。</p><p>首先要对 <code>HTMLElement</code> 进行类型检查，因为即使在支持 <code>HTMLElement</code> 的浏览器中，类型却是有差别的，在<code>Chrome,Opera</code> 中 <code>HTMLElement</code> 的类型为 <code>function</code>，此时就不能用它来判断了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isDOM =</span><br><span class="line">  <span class="keyword">typeof</span> HTMLElement === <span class="string">'object'</span></span><br><span class="line">    ? <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj <span class="keyword">instanceof</span> HTMLElement;</span><br><span class="line">      &#125;</span><br><span class="line">    : <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; obj.nodeType === <span class="number">1</span> &amp;&amp; <span class="keyword">typeof</span> obj.nodeName === <span class="string">'string'</span>;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 中神奇的 this</title>
      <link href="/240.html"/>
      <url>/240.html</url>
      
        <content type="html"><![CDATA[<h2 id="误以为-this-指向函数自身"><a href="#误以为-this-指向函数自身" class="headerlink" title="误以为 this 指向函数自身"></a>误以为 this 指向函数自身</h2><p>根据 <code>this</code> 的英语语法，很容易将函数中出现的 <strong>this</strong> 理解为函数自身。在 <code>javascript</code> 当中函数作为一等公民，确实可以在调用的时候将属性值存储起来。但是如果使用方法不对，就会发生与实际预期不一致的情况。具体情况，请看下面代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  fn(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn.count); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>如果 <code>fn</code> 函数里面的 <code>this</code> 指向自身函数，那么 <code>count</code> 属性的属性值就应该产生变化，但实际上却是纹丝不动。对于这个问题，有些人会利用作用域来解决，比如这么写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  data.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  fn(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data.count); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>又或者更直接的这么写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  fn.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  fn(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn.count); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>虽然这两种方式都输出了正确的结果，但是却避开了 <code>this</code> 到底绑定在哪里的问题。如果对一个事物的工作原理不清晰，就往往会产生头痛治头，脚痛治脚的问题，从而导致代码变得的丑陋，而且维护性也会变得很差。</p><h2 id="this-神奇的绑定规则"><a href="#this-神奇的绑定规则" class="headerlink" title="this 神奇的绑定规则"></a>this 神奇的绑定规则</h2><h3 id="默认绑定规则"><a href="#默认绑定规则" class="headerlink" title="默认绑定规则"></a>默认绑定规则</h3><h4 id="全局环境中，this-默认绑定到-window"><a href="#全局环境中，this-默认绑定到-window" class="headerlink" title="全局环境中，this 默认绑定到 window"></a>全局环境中，this 默认绑定到 window</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="函数独立调用时，this-默认绑定到-window"><a href="#函数独立调用时，this-默认绑定到-window" class="headerlink" title="函数独立调用时，this 默认绑定到 window"></a>函数独立调用时，this 默认绑定到 window</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span> === <span class="keyword">this</span>); <span class="comment">//浏览器环境</span></span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>函数 <code>fn</code> 是直接在全局作用域下调用的，没有带其他任何修饰，这种情况下，函数调用的时候使用了 <code>this</code> 的默认绑定，指向了全局对象。</p><p><code>fn</code> 函数中的 <code>this</code> 指向了全局变量，所以 <code>this.count++</code> 相当于 <code>window.count++</code>(浏览器环境下)，当然不会对 <code>fn</code> 函数的 <code>count</code> 属性产生影响。</p><p>有一点要说明的是，上面种情况只能在非严格模式(<code>strict mode</code>)下才能发生，在严格模式下，会将 <code>this</code> 默认绑定为 <code>undefined</code>。以避免全局变量的污染。</p><h4 id="被嵌套的函数独立调用时，this-默认绑定到-window"><a href="#被嵌套的函数独立调用时，this-默认绑定到-window" class="headerlink" title="被嵌套的函数独立调用时，this 默认绑定到 window"></a>被嵌套的函数独立调用时，this 默认绑定到 window</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虽然test()函数被嵌套在obj.foo()函数中，但test()函数是独立调用，而不是方法调用。所以this默认绑定到window</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h4 id="IIFE-立即执行函数-实际上是函数声明后直接调用执行"><a href="#IIFE-立即执行函数-实际上是函数声明后直接调用执行" class="headerlink" title="IIFE(立即执行函数)实际上是函数声明后直接调用执行"></a>IIFE(立即执行函数)实际上是函数声明后直接调用执行</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">//0</span></span><br><span class="line"><span class="comment">//等价于上例</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h4 id="闭包-类似地，test-函数是独立调用，而不是方法调用，所以-this-默认绑定到-window"><a href="#闭包-类似地，test-函数是独立调用，而不是方法调用，所以-this-默认绑定到-window" class="headerlink" title="[闭包]类似地，test()函数是独立调用，而不是方法调用，所以 this 默认绑定到 window"></a>[闭包]类似地，test()函数是独立调用，而不是方法调用，所以 this 默认绑定到 window</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo()(); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h3 id="隐式绑定规则"><a href="#隐式绑定规则" class="headerlink" title="隐式绑定规则"></a>隐式绑定规则</h3><p>如果函数在以对象为上下文进行调用，那么 <code>this</code> 的绑定就会产生变化。<code>this</code> 会绑定到调用这个函数的对象，查看下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.fn(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>即使函数声明不在对象当中，<code>this</code> 指向仍会产生变化:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  fn: fn</span><br><span class="line">&#125;;</span><br><span class="line">obj.fn(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>由此可见，<code>this</code> 的绑定，不与函数定义的位置有关，而是与调用者和调用方式有关。</p><p>在隐式的绑定规则下，有一些特殊的地方，需要注意。</p><h4 id="多层对象调用-this-的指向"><a href="#多层对象调用-this-的指向" class="headerlink" title="多层对象调用 this 的指向"></a>多层对象调用 this 的指向</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  fn: fn</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  obj3: obj3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.obj2.obj3.fn(); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>在多层对象引用下，<code>this</code> 指向的是调用的函数的那个对象。</p><h4 id="隐式赋值可能存在丢失现象"><a href="#隐式赋值可能存在丢失现象" class="headerlink" title="隐式赋值可能存在丢失现象"></a>隐式赋值可能存在丢失现象</h4><h5 id="函数别名"><a href="#函数别名" class="headerlink" title="[函数别名]"></a>[函数别名]</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        a : <span class="number">2</span>,</span><br><span class="line">        foo:foo</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把obj.foo赋予别名bar，造成了隐式丢失，因为只是把foo()函数赋给了bar，而bar与obj对象则毫无关系</span></span><br><span class="line">    <span class="keyword">var</span> bar = obj.foo;</span><br><span class="line">    bar();<span class="comment">//0</span></span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">    bar();<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">虽然 bar 引用了 obj.foo ，但是函数的调用方式，仍是不带任何修饰的，所以 <span class="keyword">this</span> 还是绑定在了 <span class="built_in">window</span> 上。</span><br></pre></td></tr></table></figure><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="[参数传递]"></a>[参数传递]</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//把obj.foo当作参数传递给bar函数时，有隐式的函数赋值fn=obj.foo。与上例类似，只是把foo函数赋给了fn，而fn与obj对象则毫无关系</span></span><br><span class="line">bar(obj.foo); <span class="comment">//0</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="内置函数"><a href="#内置函数" class="headerlink" title="[内置函数]"></a>[内置函数]</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">setTimeout(obj.foo, <span class="number">100</span>); <span class="comment">//0</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;, <span class="number">100</span>); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>隐式绑定 <code>this</code> 不是一种很推荐的方式，因为很有可能就发生丢失的情况，如果业务当中对 <code>this</code> 的绑定有要求，建议还是使用显示绑定的方式。</p><h3 id="显式绑定规则"><a href="#显式绑定规则" class="headerlink" title="显式绑定规则"></a>显式绑定规则</h3><p>显示绑定就是利用函数原型上的 <code>apply</code> 与 <code>call</code> 方法来对 <code>this</code> 进行绑定。用法就是把想要绑定的对象作为第一个参数传进去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">fn.call(obj); <span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>有些时候会想将函数的 <code>this</code> 绑定在某个对象上，但是不需要立即调用，这样的话，直接利用 <code>call</code> 或者 <code>apply</code> 是无法做的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  fn: fn</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bind.call(obj, fn); <span class="comment">//window</span></span><br></pre></td></tr></table></figure><p>上面这个例子，看似好像可以，但实际上是 <code>bind</code> 函数的 <code>this</code> 绑定到了 <code>obj</code> 这个对象，但是 <code>fn</code> 仍然是没有任何修饰的调用，所以 <code>fn</code> 仍然是默认的绑定方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  fn: fn</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = bind(fn, obj);</span><br><span class="line">fun(); <span class="comment">//obj</span></span><br></pre></td></tr></table></figure><p>这样调用，就可以将灵活多变的 <code>this</code>，牢牢的控制住了，因为 <code>fn</code> 的调用方式为 <code>apply</code> 调用。所以，<code>this</code> 就被绑定在传入的 <code>obj</code> 对象上，在 <code>ES5</code> 当中，函数的原型方法上多了一个 <code>bind</code>。效果与上面的函数基本一致，具体用法限于篇幅就不多说了。</p><h3 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h3><p><code>new</code> 是一个被很多人误解的一个关键字，但实际上 <code>javascript</code> 的 <code>new</code> 与传统面向对象的语言完全不同。 个人把 <code>new</code> 理解为一种特殊的函数调用，当使用 <code>new</code> 关键字来调用函数的时候，会执行下面操作:</p><ol><li>创建一个全新的对象</li><li>将空对象的 <strong>proto</strong> 指向构造函数的 <code>prototype</code></li><li>将新对象的 <code>this</code> 绑定到调用的函数上.</li><li>如果函数返回值为基本类型或者为 <code>this</code> 又或者不返回任何值，那么将会返回这个创建的新对象，如果返回了一个对象，那么则会返回这个对象，而不会返回创建的新对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line">fn.prototype.hi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> fn(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><h3 id="特殊的传参"><a href="#特殊的传参" class="headerlink" title="特殊的传参"></a>特殊的传参</h3><p><code>null</code> 和 <code>undefined</code> 也是可以作为 <code>this</code> 的绑定对象的，但是实际上应用的是默认的绑定。 但是这种传参的实际效用是什么呢？ 常见的用法是将一个数组展开，作为参数传入参数。比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a:'</span>, a, <span class="string">'b:'</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// a: 1 b: 2</span></span><br></pre></td></tr></table></figure><p>但是这种用法会有一个坑，那就是如果函数存在了 <code>this</code> ，那么就会应用默认的绑定规则，将 <code>this</code> 绑定在全局对象上，发生于预期不一致的情况。为了代码更加稳健，可以使创建一个比空对象更空的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.__proto__); <span class="comment">//Object &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><code>Object</code> 原型上有一个 <code>create</code> 方法，这个方法会创建一个对象，然后将对象的原型指向传入的参数，所以传入 <code>null</code> 的话，产生一个没有 <code>prototype</code> 的对象，所以会比空对象更加”空”。</p><p>所以传入这个对象，会比传入 <code>null</code> 更加安全。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">fn.apply(obj, [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><h3 id="根据作用域来决定-this-的绑定"><a href="#根据作用域来决定-this-的绑定" class="headerlink" title="根据作用域来决定 this 的绑定"></a>根据作用域来决定 this 的绑定</h3><p>在 <code>ES6</code> 当中，出现了一个新的函数类型，箭头函数。</p><p>如果使用箭头函数，那么就不会使用上面提到的四种 <code>this</code> 绑定方式，而是根据作用域来决定。</p><p>比较常见的是用于事件函数和定时器的情况。</p><p>下面是比较常见的传统 <code>this</code> 写法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(_this.a);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fn.call(obj); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>如果使用箭头函数则可以这么写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//this 来源于 fn 函数的作用域</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fn.call(obj); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h3 id="事件函数当中-this-的绑定机制"><a href="#事件函数当中-this-的绑定机制" class="headerlink" title="事件函数当中 this 的绑定机制"></a>事件函数当中 this 的绑定机制</h3><p>如果是在事件函数当中，<code>this</code> 的绑定是指向触发事件的 <code>DOM</code> 元素的，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'body'</span>)[<span class="number">0</span>].addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>点击 <code>body</code> 元素之后，控制台则会显示 <code>body</code> 元素。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果想判断一个函数的 <code>this</code> 绑定在哪里，首先是找到函数的调用位置，之后是按照规则来判断。</p><ul><li>如果函数调用时没有任何修饰条件，那么在严格模式下则会绑定到 <code>undefined</code>，非严格模式下会绑定到全局。</li><li>如果是用对象做上下文，来对函数进行调用，那么则会绑定到调用的这个对象上。</li><li>如果是用 <code>call</code> 或者 <code>apply</code> 方法来进行调用的，则会绑定到第一个传入参数上。</li><li>如果是使用 <code>new</code> 关键字来调用函数的，则会绑定到新创建的那个对象上.</li><li>如果是在事件函数内，则会绑定到触发事件的那个 <code>DOM</code> 元素上。</li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）JavaScript类型识别</title>
      <link href="/237.html"/>
      <url>/237.html</url>
      
        <content type="html"><![CDATA[<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><blockquote><p>javascript 类型系统可以分为标准类型和对象类型，进一步标准类型又可以分为原始类型和引用类型，而对象类型又可以分为内置对象类型、普通对象类型、自定义对象类型。</p></blockquote><p><img src="http://cdn.flqin.com/p237-1.jpeg" alt="类型系统"></p><h3 id="类型转化表"><a href="#类型转化表" class="headerlink" title="类型转化表"></a>类型转化表</h3><p><img src="http://cdn.flqin.com/p237-2.png" alt="类型转化表"></p><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><ul><li>typeof</li><li>instanceof</li><li>Object.prototype.toString</li><li>constructor</li></ul><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul><li>可以识别标准类型(<code>null</code> 除外)</li><li>不可识别具体的对象类型(<code>Function</code> 除外)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 可以识别标准类型(`null`除外)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">//"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">''</span>; <span class="comment">//"string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">//"undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">//"boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">//"object"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 不可识别具体的对象类型(`Function`除外)</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">//"object"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">//"object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">//"function"</span></span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote><p><code>instanceof</code> 左侧为查询变量,右侧为标识对象的类</p></blockquote><ul><li>能够判别内置对象类型</li><li>不能判别原始类型</li><li>能够判别自定义类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 能够判别内置对象类型</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line">/\d/ <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 不能判别原始类型</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>; <span class="comment">//false</span></span><br><span class="line"><span class="string">'xiaohong'</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 能够判别自定义类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">c <span class="keyword">instanceof</span> Point; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><ul><li>可以识别标准类型,及内置对象类型</li><li>不能识别自定义类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 可以识别标准类型,及内置对象类型</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">21</span>); <span class="comment">//"[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">//"[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/[A-Z]/</span>); <span class="comment">//"[object RegExp]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 不能识别自定义类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//c instanceof Point;//true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(c); <span class="comment">//"[object Object]"</span></span><br></pre></td></tr></table></figure><p>为了方便使用,使用函数封装如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeProto</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeProto(<span class="string">'guo'</span>); <span class="comment">//"String"</span></span><br><span class="line">typeProto(&#123;&#125;); <span class="comment">//"Object"</span></span><br></pre></td></tr></table></figure><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><blockquote><p>constructor 指向构造这个对象的构造函数本身..</p></blockquote><ul><li>可识别原始类型</li><li>可识别内置对象类型</li><li>可识别自定义类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 可识别原始类型</span></span><br><span class="line"><span class="string">'guo'</span>.constructor === <span class="built_in">String</span>; <span class="comment">//true</span></span><br><span class="line">(<span class="number">1</span>).constructor === <span class="built_in">Number</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>; <span class="comment">//true</span></span><br><span class="line">(&#123;&#125;.constructor === <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 可识别内置对象类型</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().constructor === <span class="built_in">Date</span>; <span class="comment">//true</span></span><br><span class="line">[].constructor === <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 可识别自定义类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> People(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">c.constructor === People; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>为了方便使用,使用函数封装如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getConstructorName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor.toString().match(<span class="regexp">/function\s*([^(]*)/</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getConstructorName(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">//"Date"</span></span><br><span class="line">getConstructorName(<span class="literal">null</span>); <span class="comment">//null</span></span><br><span class="line">getConstructorName(<span class="number">12</span>); <span class="comment">//"Number"</span></span><br></pre></td></tr></table></figure><h2 id="类型判断对比表"><a href="#类型判断对比表" class="headerlink" title="类型判断对比表"></a>类型判断对比表</h2><p>其中红色的单元格表示该判断方式不支持的类型。</p><p><img src="http://cdn.flqin.com/p237-3.png" alt="类型判断对比表"></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）浅谈JavaScript中的接口</title>
      <link href="/235.html"/>
      <url>/235.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>接口是面向对象 <code>JavaScript</code> 程序员的工具箱中最有用的工具之一。在设计模式中提出的可重用的面向对象设计的原则之一就是“针对接口编程而不是实现编程”，即我们所说的面向接口编程，这个概念的重要性可见一斑。但问题在于，在 <code>JavaScript</code> 的世界中，没有内置的创建或实现接口的方法，也没有可以判断一个对象是否实现了与另一个对象相同的一套方法，这使得对象之间很难互换使用，好在 <code>JavaScript</code> 拥有出色的灵活性，这使得模拟传统面向对象的接口，添加这些特性并非难事。接口提供了一种用以说明一个对象应该具有哪些方法的手段，尽管它可以表明这些方法的含义，但是却不包含具体实现。有了这个工具，就能按对象提供的特性对它们进行分组。例如，假如 <code>A</code> 和 <code>B</code> 以及接口 <code>I</code>，即便 A 对象和 <code>B</code> 对象有极大的差异，只要他们都实现了 <code>I</code> 接口，那么在 <code>A.I(B)</code> 方法中就可以互换使用 <code>A</code> 和 <code>B</code>，如 <code>B.I(A)</code>。还可以使用接口开发不同的类的共同性。如果把原本要求以一个特定的类为参数的函数改为要求以一个特定的接口为参数的函数，那么所有实现了该接口的对象都可以作为参数传递给它，这样一来，彼此不相关的对象也可以被相同地对待。</p><h3 id="接口的利与弊"><a href="#接口的利与弊" class="headerlink" title="接口的利与弊"></a>接口的利与弊</h3><p>既定的接口具有自我描述性，并能够促进代码的重用性，接口可以提供一种信息，告诉外部一个类需要实现哪些方法。还有助于稳定不同类之间的通信方式，减少了继承两个对象的过程中出现的问题。这对于调试也是有帮助的，在 <code>JavaScript</code> 这种弱类型语言中，类型不匹配很难追踪，使用接口时，如果出现了问题，会有更明确的错误提示信息。当然接口并非完全没有缺点，如果大量使用接口会一定程度上弱化其作为弱类型语言的灵活性，另一方面，<code>JavaScript</code> 并没有对接口的内置的支持，只是对传统的面向对象的接口进行模拟，这会使本身较为灵活的 <code>JavaScript</code> 变得更加难以驾驭。此外，任何实现接口的方式都会对性能造成影响，某种程度上归咎于额外的方法调用开销。接口使用的最大的问题在于，<code>JavaScript</code> 不像是其他的强类型语言，如果不遵守接口的约定，就会编译失败，其灵活性可以有效地避开上述问题，如果是在协同开发的环境下，其接口很有可能被破坏而不会产生任何错误，也就是不可控性。</p><p>在面向对象的语言中，使用接口的方式大体相似。接口中包含的信息说明了类需要实现的方法以及这些方法的签名。类的定义必须明确地声明它们实现了这些接口，否则是不会编译通过的。显然在 <code>JavaScript</code> 中我们不能如法炮制，因为不存在 <code>interface</code> 和 <code>implement</code> 关键字，也不会在运行时对接口是否遵循约定进行检查，但是我们可以通过辅助方法和显式地检查模仿出其大部分特性。</p><h3 id="在-JavaScript-中模仿接口"><a href="#在-JavaScript-中模仿接口" class="headerlink" title="在 JavaScript 中模仿接口"></a>在 JavaScript 中模仿接口</h3><p>在 <code>JavaScript</code> 中模仿接口主要有三种方式：通过注释、属性检查和鸭式辩型法，以上三种方式有效结合，就会产生类似接口的效果。</p><p>注释是一种比较直观地把与接口相关的关键字（如 <code>interface、implement</code> 等）与 <code>JavaScript</code> 代码一同放在注释中来模拟接口，这是最简单的方法，但是效果最差。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以注释的形式模仿描述接口</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    interface Composite&#123;</span></span><br><span class="line"><span class="comment">        function add(child);</span></span><br><span class="line"><span class="comment">        function remove(child);</span></span><br><span class="line"><span class="comment">        function getName(index);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    interface FormItem&#123;</span></span><br><span class="line"><span class="comment">        function save();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以注释的形式模仿使用接口关键字</span></span><br><span class="line"><span class="keyword">var</span> CompositeForm = <span class="function"><span class="keyword">function</span>(<span class="params">id, method, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//implements Composite , FormItem</span></span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模拟实现具体的接口方法 此处实现Composite接口</span></span><br><span class="line">CompositeForm.prototype.Add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CompositeForm.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CompositeForm.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟实现具体的接口方法 此处实现FormItem接口</span></span><br><span class="line">Composite.prototype.save = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方式其实并不是很好，因为这种模仿还只停留在文档规范的范畴，开发人员是否会严格遵守该约定有待考量，对接口的遵守完全依靠开发人员的自觉性。另外，这种方式并不会去检查某个函数是否真正地实现了我们约定的“接口”。尽管如此，这种方式也有优点，它易于实现而不需要额外的类或者函数，可以提高代码的可重用性，因为类实现的接口都有注释说明。这种方式不会影响到文件占用的空间或执行速度，因为注释的代码可以在部署的时候轻松剔除。但是由于不会提供错误消息，它对测试和调试没什么帮助。下面的一种方式会对是否实现接口进行检查，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以注释的形式模仿使用接口关键字</span></span><br><span class="line"><span class="keyword">var</span> CompositeForm = <span class="function"><span class="keyword">function</span>(<span class="params">id, method, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//implements Composite , FormItem</span></span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="keyword">this</span>.implementsinterfaces = [<span class="string">'Composite'</span>, <span class="string">'FormItem'</span>]; <span class="comment">//显式地把接口放在implementsinterfaces中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查接口是否实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">implements</span>(<span class="params">Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> interfaceName = <span class="built_in">arguments</span>[i];</span><br><span class="line">    <span class="keyword">var</span> interfaceFound = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="built_in">Object</span>.implementsinterfaces.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Object</span>.implementsinterfaces[j] == interfaceName) &#123;</span><br><span class="line">        interfaceFound = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!interfaceFound) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AddForm</span>(<span class="params">formInstance</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!implements(formInstance, <span class="string">'Composite'</span>, <span class="string">'FormItem'</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Object does not implements required interface!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是在方式一的基础上进行完善，在这个例子中，<code>CompositeForm</code> 宣称自己实现了 <code>Composite</code> 和 <code>FormItem</code> 这两个接口，其做法是把这两个接口的名称加入一个 <code>implementsinterfaces</code> 的数组。显式地声明自己支持什么接口。任何一个要求其参数属性为特定类型的函数都可以对这个属性进行检查，并在所需要的接口未在声明之中时抛出错误。这种方式相对于上一种方式，多了一个强制性的类型检查。但是这种方法的缺点在于它并未保证类真正地实现了自称实现的接口，只是知道它声明自己实现了这些接口。其实类是否声明自己支持哪些接口并不重要，只要它具有这些接口中的方法就行。鸭式辩型（像鸭子一样走路并且嘎嘎叫的就是鸭子）正是基于这样的认识，它把对象实现的方法集作为判断它是不是某个类的实例的唯一标准。这种技术在检查一个类是否实现了某个接口时也可以大显身手。这种方法的背后观点很简单：如果对象具有与接口定义的方法同名的所有方法，那么就可以认为它实现了这个接口。可以使用一个辅助函数来确保对象具有所有必需的方法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interface</span></span><br><span class="line"><span class="keyword">var</span> Composite = <span class="keyword">new</span> Interface(<span class="string">'Composite'</span>, [<span class="string">'add'</span>, <span class="string">'remove'</span>, <span class="string">'getName'</span>]);</span><br><span class="line"><span class="keyword">var</span> FormItem = <span class="keyword">new</span> Interface(<span class="string">'FormItem'</span>, [<span class="string">'save'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//class</span></span><br><span class="line"><span class="keyword">var</span> Composite = <span class="function"><span class="keyword">function</span>(<span class="params">id, method, action</span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Common Method</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AddForm</span>(<span class="params">formInstance</span>) </span>&#123;</span><br><span class="line">  ensureImplements(formInstance, Composite, FormItem);</span><br><span class="line">  <span class="comment">//如果该函数没有实现指定的接口，这个函数将会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与另外两种方式不同，这种方式无需注释，其余的各个方面都是可以强制实施的。<code>EnsureImplements</code> 函数需要至少两个参数。第一个参数是想要检查的对象，其余的参数是被检查对象的接口。该函数检查器第一个参数代表的对象是否实现了那些接口所声明的方法，如果漏掉了任何一个，就会抛错，其中会包含被遗漏的方法的有效信息。这种方式不具备自我描述性，需要一个辅助类和辅助函数来帮助实现接口检查，而且它只关心方法名称，并不检查参数的名称、数目或类型。</p><h3 id="Interface-类"><a href="#Interface-类" class="headerlink" title="Interface 类"></a>Interface 类</h3><p>在下面的代码中，对 <code>Interface</code> 类的所有方法的参数都进行了严格的控制，如果参数没有验证通过，那么就会抛出异常。加入这种检查的目的就是，如果在执行过程中没有抛出异常，那么就可以肯定接口得到了正确的声明和实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Interface = <span class="function"><span class="keyword">function</span>(<span class="params">name ,methods</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'2 arguments required!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.methods=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;len=methods.length;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span>(methods[i]!==<span class="string">'String'</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'method name must be String!'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.methods.push(methods[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Interface.ensureImplements=<span class="function"><span class="keyword">function</span>(<span class="params">object</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'2 arguments required at least!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;len=<span class="built_in">arguments</span>.length;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> interface=<span class="built_in">arguments</span>[i];</span><br><span class="line">        <span class="keyword">if</span>(interface.constructor!==Interface)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'instance must be Interface!'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;methodLength=interface.methods.length;j&lt;methodLength;j++)&#123;</span><br><span class="line">            <span class="keyword">var</span> method=interface.methods[j];</span><br><span class="line">            <span class="keyword">if</span>(!object[method]||<span class="keyword">typeof</span>(object[method])==<span class="string">'function'</span>))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'object does not implements method!'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实多数情况下，接口并不是经常被使用的，严格的类型检查并不总是明智的。但是在设计复杂的系统的时候，接口的作用就体现出来了，这看似降低了灵活性，却同时也降低了耦合性，提高了代码的重用性。这在大型系统中是比较有优势的。在下面的例子中，声明了一个 <code>displayRoute</code> 方法，要求其参数具有三个特定的方法，通过 <code>Interface</code> 对象和 <code>ensureImplements</code> 方法来保证这三个方法的实现，否则将会抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个接口，描述该接口包含的方法</span></span><br><span class="line"> <span class="keyword">var</span> DynamicMap=<span class="keyword">new</span> Interface&#123;<span class="string">'DynamicMap'</span>,[<span class="string">'centerOnPoint'</span>,<span class="string">'zoom'</span>,<span class="string">'draw'</span>]&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//声明一个displayRoute方法</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">displayRoute</span>(<span class="params">mapInstance</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//检验该方法的map</span></span><br><span class="line">    <span class="comment">//检验该方法的mapInsstance是否实现了DynamicMap接口，如果未实现则会抛出</span></span><br><span class="line">    Interface.ensureImplements(mapInstance,DynamicMap);</span><br><span class="line">    <span class="comment">//如果实现了则正常执行</span></span><br><span class="line">    mapInstance.centerOnPoint(<span class="number">12</span>,<span class="number">22</span>);</span><br><span class="line">    mapInstance.zoom(<span class="number">5</span>);</span><br><span class="line">    mapInstance.draw();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>下面的例子会将一些数据以网页的形式展现出来，这个类的构造器以一个 <code>TestResult</code> 的实例作为参数。该类会对 <code>TestResult</code> 对象所包含的数据进行格式化（<code>Format</code>）后输出，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ResultFormatter=<span class="function"><span class="keyword">function</span>(<span class="params">resultObject</span>)</span>&#123;</span><br><span class="line">     <span class="comment">//对resultObject进行检查，保证是TestResult的实例</span></span><br><span class="line">     <span class="keyword">if</span>(!(resultObject <span class="keyword">instanceof</span> TestResult))&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'arguments error!'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">this</span>.resultObject=resultObject;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ResultFormatter.prototype.renderResult=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> dateOfTest=<span class="keyword">this</span>.resultObject.getData();</span><br><span class="line">     <span class="keyword">var</span> resultArray=<span class="keyword">this</span>.resultObject.getResults();</span><br><span class="line">     <span class="keyword">var</span> resultContainer=<span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">     <span class="keyword">var</span> resultHeader=<span class="built_in">document</span>.createElement(<span class="string">'h3'</span>);</span><br><span class="line">     resultHeader.innerHTML=<span class="string">'Test Result from '</span>+dateOfTest.toUTCString();</span><br><span class="line">     resultContainer.appendChild(resultHeader);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> resultList=<span class="built_in">document</span>.createElement(<span class="string">'ul'</span>);</span><br><span class="line">     resultContainer.appendChild(resultList);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;len=resultArray.length;i&lt;len;i++)&#123;</span><br><span class="line">         <span class="keyword">var</span> listItem=<span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">         listItem.innerHTML=resultArray[i];</span><br><span class="line">         resultList.appendChild(<span class="string">'listItem'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> resultContainer;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该类的构造器会对参数进行检查，以确保其的确为 <code>TestResult</code> 的类的实例。如果参数达不到要求，构造器将会抛出一个错误。有了这样的保证，在编写 <code>renderResult</code> 方法的时候，就可以认定有 <code>getData</code> 和 <code>getResult</code> 两个方法。但是，构造函数中，只对参数的类型进行了检查，实际上这并不能保证所需要的方法都得到了实现。<code>TestResult</code> 类会被修改，致使其失去这两个方法，但是构造器中的检查依旧会通过，只是 <code>renderResult</code> 方法不再有效。</p><p>此外，构造器中的这个检查施加了一些不必要的限制。它不允许使用其他的类的实例作为参数，否则会直接抛错，但是问题来了，如果有另一个类也包含并实现了 <code>getData</code> 和 <code>getResult</code> 方法，它本来可以被 <code>ResultFormatter</code> 使用，却因为这个限制而无用武之地。</p><p>解决问题的办法就是删除构造器中的校验，并使用接口代替。我们采用这个方案对代码进行优化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口的声明</span></span><br><span class="line"><span class="keyword">var</span> resultSet = <span class="keyword">new</span> Interface(<span class="string">'ResultSet'</span>, [<span class="string">'getData'</span>, <span class="string">'getResult'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后的方案</span></span><br><span class="line"><span class="keyword">var</span> ResultFormatter = <span class="function"><span class="keyword">function</span>(<span class="params">resultObject</span>) </span>&#123;</span><br><span class="line">  Interface.ensureImplements(resultObject, resultSet);</span><br><span class="line">  <span class="keyword">this</span>.resultObject = resultObject;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>renderResult</code> 方法保持不变，而构造器却采用的 <code>ensureImplements</code> 方法，而不是 <code>typeof</code> 运算符。现在的这个构造器可以接受任何符合接口的类的实例了。</p><h3 id="依赖于接口的设计模式"><a href="#依赖于接口的设计模式" class="headerlink" title="依赖于接口的设计模式"></a>依赖于接口的设计模式</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>对象工厂所创建的具体对象会因具体情况而不同。使用接口可以确保所创建的这些对象可以互换使用，也就是说对象工厂可以保证其生产出来的对象都实现了必需的方法；</p><h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p>如果不使用接口就不可能使用这个模式，其中心思想是可以将对象群体与其组成对象同等对待。这是通过接口来做到的。如果不进行鸭式辩型或类型检查，那么组合模式就会失去大部分意义;</p><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p>装饰者通过透明地为另一个对象提供包装而发挥作用。这是通过实现与另外那个对象完全一致的接口实现的。对于外界而言，一个装饰者和它所包装的对象看不出有什么区别，所以使用 Interface 来确保所创建的装饰者实现了必需的方法;</p><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>代码中所有的命令对象都有实现同一批方法（如 <code>run、ecxute、do</code> 等）通过使用接口，未执行这些命令对象而创建的类可以不必知道这些对象具体是什么，只要知道他们都正确地实现了接口即可。借此可以创建出模块化程度很高的、耦合度很低的 <code>API</code>。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数声明、函数表达式等浅析</title>
      <link href="/230.html"/>
      <url>/230.html</url>
      
        <content type="html"><![CDATA[<p><code>javascript</code> 和其他编程语言相比比较随意，所以 <code>javascript</code> 代码中充满各种奇葩的写法，有时雾里看花，当然，能理解各型各色的写法也是对 <code>javascript</code> 语言特性更进一步的深入理解。</p><h2 id="函数基本概念"><a href="#函数基本概念" class="headerlink" title="函数基本概念"></a>函数基本概念</h2><h3 id="函数声明-function-declaration"><a href="#函数声明-function-declaration" class="headerlink" title="函数声明(function declaration)"></a>函数声明(function declaration)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnName</span> (<span class="params"></span>) </span>&#123;…&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>function</code> 关键字声明一个函数，再指定一个函数名，叫函数声明。</p><h3 id="函数表达式-function-expression"><a href="#函数表达式-function-expression" class="headerlink" title="函数表达式(function expression)"></a>函数表达式(function expression)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fnName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;…&#125;;</span><br></pre></td></tr></table></figure><p>将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。</p><h3 id="匿名函数-Anonymous-Function"><a href="#匿名函数-Anonymous-Function" class="headerlink" title="匿名函数(Anonymous Function)"></a>匿名函数(Anonymous Function)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>function</code> 关键字声明一个函数，但未给函数命名，所以叫匿名函数。</p><p>匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。</p><p>匿名函数可以有效的保证在页面上写入 <code>Javascript</code>，而不会造成全局变量的污染。 这在给一个不是很熟悉的页面增加 <code>Javascript</code> 时非常有效，也很优美。</p><p><code>javascript</code> 中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据 <code>javascript</code> 函数作用域链的特性，可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以 <code>( function(){…} )()</code> 内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。</p><h3 id="立即执行函数-IIFE"><a href="#立即执行函数-IIFE" class="headerlink" title="立即执行函数(IIFE)"></a>立即执行函数(IIFE)</h3><p>函数体后面加括号就能立即调用，则这个函数必须是函数表达式，不能是函数声明。 在理解了一些函数基本概念后，回头看看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;…&#125; )()</span><br><span class="line">( <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;…&#125; () )</span><br></pre></td></tr></table></figure><p>这是两种立即执行函数的写法，一个括号包裹匿名函数，并直接在 ① 匿名函数的后面或者 ② 包含匿名函数括号的后面加个括号 就可以立即调用函数。</p><p>在 <code>function</code> 前面加<code>（）、！、+、 -</code> 甚至是逗号等到都可以起到函数定义后立即执行的效果，而 <code>（）、！、+、-、=</code> 等运算符，都将函数声明转换成函数表达式，消除了 <code>javascript</code> 引擎识别函数表达式和函数声明的歧义，告诉 <code>javascript</code> 引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码。</p><p>加括号是最安全的做法，因为<code>！、+、-</code>等运算符还会和函数的返回值进行运算，有时造成不必要的麻烦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//firebug输出123,使用（）运算符</span></span><br><span class="line">&#125;)(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//firebug输出1234，使用（）运算符</span></span><br><span class="line">&#125;)(<span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">!(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//firebug输出12345,使用！运算符</span></span><br><span class="line">&#125;)(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">+(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//firebug输出123456,使用+运算符</span></span><br><span class="line">&#125;)(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line">-(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//firebug输出1234567,使用-运算符</span></span><br><span class="line">&#125;)(<span class="number">1234567</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//firebug输出12345678，使用=运算符</span></span><br><span class="line">&#125;)(<span class="number">12345678</span>);</span><br></pre></td></tr></table></figure><h2 id="函数声明和函数表达式区别"><a href="#函数声明和函数表达式区别" class="headerlink" title="函数声明和函数表达式区别"></a>函数声明和函数表达式区别</h2><ol><li><p><code>Javascript</code> 引擎在解析 <code>javascript</code> 代码时会 <code>函数声明提升（Function declaration Hoisting）</code> 当前执行环境（作用域）上的函数声明，而函数表达式必须等到 <code>Javascript</code> 引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fnName();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正常，因为‘提升'了函数声明，函数调用可在函数声明之前</span></span><br><span class="line"></span><br><span class="line">fnName();</span><br><span class="line"><span class="keyword">var</span> fnName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错，变量fnName还未保存对函数的引用，函数调用必须在函数表达式之后</span></span><br></pre></td></tr></table></figure></li><li><p>函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以 <code>fnName()</code> 形式调用 。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fnName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">//函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">//不会报错，但是javascript引擎只解析函数声明，忽略后面的括号，函数声明不会被调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">//语法错误，虽然匿名函数属于函数表达式，但是未进行赋值操作，</span></span><br><span class="line"><span class="comment">//所以javascript引擎将开头的function关键字当做函数声明，报错：要求需要一个函数名</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）谈谈使用 promise 时候的一些反模式</title>
      <link href="/226.html"/>
      <url>/226.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接 <code>https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html</code></p></blockquote><p>各位 <code>JavaScript</code> 程序员，是时候承认了，我们在使用 <code>promise</code> 的时候，会写出许多有问题的 <code>promise</code> 代码。 当然并不是 <code>promise</code> 本身的问题，<code>A+ spec</code> 规范定义的 <code>promise</code> 非常棒。 在过去的几年中，笔者看到了很多程序员在调用 <code>PouchDB</code> 或者其他 <code>promise</code> 化的 <code>API</code> 时遇到了很多困难。这让笔者认识到，在 <code>JavaScript</code> 程序员之中，只有少数人是真正理解了 <code>promise</code> 规范的。如果这个事实让你难以接受，那么思考一下我在 <code>Twitter</code> 上出的题：</p><p>问：下面四个使用 promise 的语句之间的不同点在哪儿？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">&#125;)；</span><br><span class="line"></span><br><span class="line">doSomethin().then(functiuoin () &#123;</span><br><span class="line">    doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse());</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse);</span><br></pre></td></tr></table></figure><p>如果你知道这个问题的答案，那么恭喜你，你已经是一个 <code>promise</code> 大师并且可以直接关闭这个网页了。</p><p>但是对于不能回答这个问题的程序员中 99.9% 的人，别担心，你们不是少数派。没有人能够在笔者的 <code>tweet</code> 上完全正确的回答这个问题，而且对于 #3 最终答案也令我感到震惊，即便我是出题人。</p><p>答案在本文的底部，但是首先，笔者必须先探究一下 <code>promise</code> 为何如此复杂，为什么不管是新手还是专家都有被 <code>promise</code> 折磨的经历。同时，笔者也会给出自认为能够快速、准确理解 <code>promise</code> 的方法。而且笔者确信读过这篇文章之后，理解 <code>promise</code> 不会那么难了。</p><p>在此之前，我们先了解一下有关 <code>promise</code> 的一些常识。</p><h2 id="Promise-的起源"><a href="#Promise-的起源" class="headerlink" title="Promise 的起源"></a>Promise 的起源</h2><p>如果你读过有关 <code>promise</code> 的文章，你会发现文章中一定会提到 <code>Callback hell</code>，不说别的，在视觉上，回调金字塔会让你的代码最终超过屏幕的宽度。</p><p><code>promise</code> 是能够解决这个问题的，但是它解决的问题不仅仅是缩进。在讨论到如何 解决 <code>Callback hell</code> 问题 的时候，我们遇到真正的难题是回调函数剥夺了程序员使用 <code>return</code> 和 <code>throw</code> 的能力。而程序的执行流程的基础建立于一个函数在执行过程中调用另一个函数时产生的副作用。(译者注：个人对这里副作用的理解是，函数调用函数会产生函数调用栈，而回调函数是不运行在栈上的，因此不能使用 <code>return</code> 和 <code>throw</code>)。</p><p>事实上，回调函数还有更恼人的——剥夺我们在栈上执行代码的能力，而在其他语言当中，我们始终都能够在栈上执行代码。编写不在栈上运行的代码就像开没有刹车的车一样，在你真正需要它的时候，才明白它有多么的重要。</p><p><code>promise</code> 被设计为能够让我们重新使用那些编程语言的基本要素：<code>return，throw，栈。</code> 在想要使用 <code>promise</code> 之前，我们首先要学会正确使用它。</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>一些人尝试使用 漫画 的方式解释 <code>promise</code>，或者是像是解释名词一样解释它：它表示同步代码中的值，并且能在代码中被传递。</p><p>笔者并没有觉得这些解释对理解 <code>promise</code> 有用。笔者自己的理解是：<code>promise</code> 是关于代码结构和代码运行流程的。因此，笔者认为展示一些常见错误，并告诉大家如何修正它才是王道。</p><p>扯远一点，对于 <code>promise</code>，不同的人有不同的理解，为了本文的最终目的，我在这里只讨论 <code>promise</code> 的官方 规范，在较新版本的浏览器会作为 <code>window</code> 对象的一个属性被暴露出来。然而并不是所有的浏览器都支持这一特性，但是到目前为止有许多 <code>polyfill</code>，比如这个名字很大胆并且实现非常简洁的 <code>promise</code> 库：<code>Lie</code>。</p><h3 id="新手错误-1：Callback-hell"><a href="#新手错误-1：Callback-hell" class="headerlink" title="新手错误 1：Callback hell"></a>新手错误 1：Callback hell</h3><p><code>PouchDB</code> 有许多 <code>promise</code> 风格的 <code>API</code>，程序员在写有关 <code>PouchDB</code> 的代码的时候，常常将 <code>promise</code> 用的一塌糊涂。下面给出一种很常见的糟糕写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">remote.allDocs(&#123;</span><br><span class="line">    include_docs: <span class="literal">true</span>,</span><br><span class="line">    attachment: <span class="literal">true</span></span><br><span class="line">&#125;).then(functionb (result) &#123;</span><br><span class="line">    <span class="keyword">var</span> docs = result.rows;</span><br><span class="line">    docs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        localdb.put(element.doc).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">'pulled doc with id'</span> + element.doc._id + <span class="string">'and added to local db.'</span>);&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err.status == <span class="number">409</span>) &#123;</span><br><span class="line">            localdb.get(element.doc._id).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">             localdb.remove(resp._id, resp._rev).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line"><span class="comment">// et cetera...</span></span><br></pre></td></tr></table></figure><p>你确实可以将 <code>promise</code> 当做回调函数来使用，但这却是一种杀鸡用牛刀的行为。不过这么做也是可行的。 你可能会认为这种错误是那些刚入行的新手才会犯的。但是笔者在黑莓的 开发者博客 上曾经看到类似的代码。过去的书写回调函数的习惯是很难改变的。</p><p>下面给出一种代码风格更好的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(...).then(functioin (resultofAllDocs) &#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfPut</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.get(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfGet</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这就是 <code>promise</code> 的链式调用，它体现 <code>promise</code> 的强大之处，每个函数在上一个 <code>promise</code> 的状态变为 <code>resolved</code> 的时候才会被调用，并且能够得到上一个 <code>promise</code> 的输出结果。稍后还有详细的解释。</p><h3 id="新手错误-2：怎样用-forEach-处理-promise"><a href="#新手错误-2：怎样用-forEach-处理-promise" class="headerlink" title="新手错误 2：怎样用 forEach() 处理 promise"></a>新手错误 2：怎样用 forEach() 处理 promise</h3><p>这个问题是大多数人掌握 <code>promise</code> 的绊脚石，当这些人想在代码中使用他们熟悉的 <code>forEach()</code> 方法或者是写一个 <code>for</code> 循环，抑或是 <code>while</code> 循环的时候，都会为如何使用 <code>promise</code> 而疑惑不已。他们会写下这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// I want to remove() all docs</span></span><br><span class="line">db.allDocs(&#123; <span class="attr">include_docs</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    result.rows.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">row</span>) </span>&#123;</span><br><span class="line">      db.remove(row.doc);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// I naively believe all docs have been removed() now!</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这段代码的问题在于第一个回调函数实际上返回的是 <code>undefined</code>，也就意味着第二个函数并不是在所有的 <code>db.remove()</code> 执行结束之后才执行。事实上，第二个函数的执行不会有任何延时，它执行的时候被删除的 <code>doc</code> 数量可能为任意整数。</p><p>这段代码看起来是能够正常工作的，因此这个 <code>bug</code> 也具有一定的隐藏性。写这代码的人以为 <code>PouchDB</code> 已经删除了这些 <code>docs</code>，可以更新 <code>UI</code> 了。这个 <code>bug</code> 会在一定几率下出现，或者是特定的浏览器。而一旦出现，这种 <code>bug</code> 是很难调试的。</p><p>一言以蔽之，你需要的不是 <code>forEach()/for/while</code> 而是 <code>Promise.all()：</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.allDocs(&#123; <span class="attr">include_docs</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">      result.rows.map(<span class="function"><span class="keyword">function</span>(<span class="params">row</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> db.remove(row.doc);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">arrayObject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// All docs have really been removed() now!</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>从根本上说，<code>Promise.all()</code> 以一个 <code>promise</code> 对象组成的数组为输入，返回另一个 <code>promise</code> 对象。这个对象的状态只会在数组中所有的 <code>promise</code> 对象的状态都变为 <code>resolved</code> 的时候才会变成 <code>resolved</code>。可以将其理解为异步的 <code>for</code> 循环。</p><p><code>Promise.all()</code> 还会将计算结果以数组的形式传递给下一个函数，这一点十分有用。举例来说，如果你想用 <code>get()</code> 方法从 <code>PouchDB</code> 得到多个值的时候，就可以利用这个特性。同时，作为输入的一系列 <code>promise</code> 对象中，如果有一个的状态变为 <code>rejected</code>，那么 <code>all()</code> 返回的 <code>promise</code> 对象的状态也会变为 <code>rejected</code>。</p><h3 id="新手错误-3：忘记添加-catch-方法"><a href="#新手错误-3：忘记添加-catch-方法" class="headerlink" title="新手错误 3：忘记添加 catch() 方法"></a>新手错误 3：忘记添加 catch() 方法</h3><p>这是一个很常见的错误。很多程序员对他们代码中的 <code>promise</code> 调用十分自信，觉得代码永远不会抛出一个 <code>error</code>，也可能他们只是简单的忘了加 <code>catch()</code> 方法。不幸的是，不加 <code>catch()</code> 方法会让回调函数中抛出的异常被吞噬，在你的控制台是看不到相应的错误的，这对调试来说是非常痛苦的。</p><p>为了避免这种糟糕的情况，我已经养成了在自己的 <code>promise</code> 调用链最后添加如下代码的习惯：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">somePromise()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> anotherPromise();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> yetAnotherPromise();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)); <span class="comment">// &lt;-- this is badass</span></span><br></pre></td></tr></table></figure><p>即使你并不打算在代码中处理异常，在代码中添加 <code>catch()</code> 也是一个谨慎的编程风格的体现。在某种情况下你原先的假设出错的时候，这会让你的调试工作轻松一些。</p><h3 id="新手错误-4：使用-“deferred”"><a href="#新手错误-4：使用-“deferred”" class="headerlink" title="新手错误 4：使用 “deferred”"></a>新手错误 4：使用 “deferred”</h3><p>这类型 错误 笔者经常看到，在这里我也不想重复它了。简而言之，<code>promise</code> 经过了很长一段时间的发展，有一定的历史包袱。<code>JavaScript</code> 社区用了很长的时间才纠正了发展道路上的一些错误。<code>jQuery</code> 和 <code>Angular</code> 早期都在使用 <code>deferred</code> 类型的 <code>promise</code>。而在最新的 <code>ES6</code> 的 <code>Promise</code> 标准中，这种实现方式已经被替代了，同时，一些 <code>Promise</code> 的库，比如 <code>Q，bluebid，Lie</code> 也是参照 <code>ES6</code> 的标准来实现的。</p><p>如果你还在代码中使用 <code>deferred</code> 的话，那么你就是走在错误的道路上了，这里笔者给出一些修正的办法。</p><p>首先，绝大多数的库都给出了将第三方库的方法包装成 <code>promise</code> 对象的方法。举例来说，<code>Angular</code> 的 <code>$q</code> 模块可以使用 <code>$q.when()</code> 完成这一包装过程。因此，在 <code>Angular</code> 中，包装 <code>PouchDB</code> 的 <code>promise API</code> 的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$q.when(db.put(doc)).then(...) <span class="comment">// &lt;-- this is all the code you need</span></span><br></pre></td></tr></table></figure><p>另一种方法就是使用暴露给程序员的 构造函数。<code>promise</code> 的构造函数能够包装那些非 <code>promise</code> 的 <code>API</code>。下面给出一个例子，在该例中将 <code>Node.js</code> 提供的 f<code>s.readFile()</code> 方法包装成 <code>promise</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'myfile.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(file);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(...)</span><br></pre></td></tr></table></figure><p>齐活！</p><p>如果你想更多的了解为什么这样的写法是一个反模式，猛戳这里 <a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern" target="_blank" rel="noopener">the Bluebird wiki page on promise anti-patterns</a></p><h3 id="新手错误-5：不显式调用-return"><a href="#新手错误-5：不显式调用-return" class="headerlink" title="新手错误 5：不显式调用 return"></a>新手错误 5：不显式调用 return</h3><p>下面这段代码的问题在哪里？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">somePromise()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    someOtherPromise();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Gee, I hope someOtherPromise() has resolved</span></span><br><span class="line">    <span class="comment">// Spoiler alert: it hasn't</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>现在该讨论所有需要了解的关于 <code>promise</code> 的知识点了。理解了这一个知识点，笔者提到的一些错误你都不会犯了。</p><p>正如笔者前面所说的，<code>promise</code> 的神奇之处在于让我们能够在回调函数里面使用 <code>return</code> 和 <code>throw</code>。但是实践的时候是什么样子呢？</p><p>每一个 <code>promise</code> 对象都会提供一个 <code>then</code> 方法或者是 <code>catch</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I'm inside a then() function!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 <code>then</code> 方法内部，我们可以做三件事：</p><ul><li><code>return</code> 一个 <code>promise</code> 对象</li><li><code>return</code> 一个同步的值或者是 <code>undefined</code></li><li>同步的 <code>throw</code> 一个错误</li></ul><p>理解这三种情况之后，你就会理解 <code>promise</code> 了。</p><h4 id="返回另一个-promise-对象"><a href="#返回另一个-promise-对象" class="headerlink" title="返回另一个 promise 对象"></a>返回另一个 promise 对象</h4><p>在有关 <code>promise</code> 的相关文章中，这种写法很常见，就像上文提到的构成 <code>promise</code> 链的一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">userAccount</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>这段代码里面的 <code>return</code> 非常关键，没有这个 <code>return</code> 的话，<code>getUserAccountById</code> 只是一个普通的被别的函数调用的函数。下一个回调函数会接收到 <code>undefined</code> 而不是 <code>userAccount</code>。</p><h4 id="返回一个同步的值或者是-undefined"><a href="#返回一个同步的值或者是-undefined" class="headerlink" title="返回一个同步的值或者是 undefined"></a>返回一个同步的值或者是 <code>undefined</code></h4><p>返回一个 <code>undefined</code> 大多数情况下是错误的，但是返回一个同步的值确实是一个将同步代码转化成 <code>promise</code> 风格代码的好方法。举个例子，现在在内存中有 <code>users</code>。我们可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">      <span class="keyword">return</span> inMemoryCache[user.id]; <span class="comment">// returning a synchronous value!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id]; <span class="comment">// returning a promise</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// I got a user account</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>第二个回调函数并不关心 <code>userAccount</code> 是通过同步的方式得到的还是异步的方式得到的，而第一个回调函数即可以返回同步的值又可以返回异步的值。</p><p>不幸的是，如果不显式调用 <code>return</code> 语句的话，<code>JavaScript</code> 里的函数会返回 <code>undefined</code>。这也就意味着在你想返回一些值的时候，不显式调用 <code>return</code> 会产生一些副作用。</p><p>鉴于以上原因，笔者养成了一个在 <code>then</code> 方法内部永远显式的调用 <code>return</code> 或者 <code>throw</code> 的习惯。建议你也这样做。</p><h4 id="抛出一个同步的错误"><a href="#抛出一个同步的错误" class="headerlink" title="抛出一个同步的错误"></a>抛出一个同步的错误</h4><p>说到 <code>throw</code>，这又体现了 <code>promise</code> 的功能强大。在用户退出的情况下，我们的代码中会采用抛出异常的方式进行处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user.isLoggedOut()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'user logged out!'</span>); <span class="comment">// throwing a synchronous error!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">      <span class="keyword">return</span> inMemoryCache[user.id]; <span class="comment">// returning a synchronous value!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id); <span class="comment">// returning a promise!</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// I got a user account!</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Boo, I got an error!</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>如果用户已经登出的话，<code>catch()</code> 会收到一个同步的错误，如果有 <code>promise</code> 对象的状态变为 <code>rejected</code> 的话，它还会收到一个异步的错误。<code>catch()</code> 的回调函数不用关心错误是异步的还是同步的。</p><p>在使用 <code>promise</code> 的时候抛出异常在开发阶段很有用，它能帮助我们定位代码中的错误。比方说，在 <code>then</code> 函数内部调用 <code>JSON.parse（）</code>，如果 <code>JSON</code> 对象不合法的话，可能会抛出异常，在回调函数中，这个异常会被吞噬，但是在使用 <code>promise</code> 之后，我们就可以捕获到这个异常了。</p><h2 id="进阶错误"><a href="#进阶错误" class="headerlink" title="进阶错误"></a>进阶错误</h2><p>接下来我们讨论一下使用 <code>promise</code> 的边界情况。</p><p>下面的错误笔者将他们归类为 “进阶错误”，因为这些错误发生在那些已经相对熟练使用 <code>promise</code> 的程序员身上。但是为了解决本文开头提出的问题，还是有必要对其进行讨论。</p><h3 id="进阶错误-1：不了解-Promise-resolve"><a href="#进阶错误-1：不了解-Promise-resolve" class="headerlink" title="进阶错误 1：不了解 Promise.resolve()"></a>进阶错误 1：不了解 Promise.resolve()</h3><p>就像之前所说的，<code>promise</code> 能够将同步代码包装成异步的形式。然而，如果你经常写出如下的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(someSynchronousValue);</span><br><span class="line">&#125;).then(...);</span><br></pre></td></tr></table></figure><p>你可以使用 <code>Promise.resolve()</code> 将上述代码精简。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(someSynchronousValue).then(...);</span><br></pre></td></tr></table></figure><p>在捕获同步异常的时候这个做法也是很有效的。我在编写 <code>API</code> 的时候已经养成了使用 <code>Promise.resolve()</code> 的习惯：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">somePromiseAPI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSomethingThatMayThrow();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">  &#125;).then(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住，有可能抛出错误的代码都有可能因为错误被吞噬而对你的工作造成困扰。但是如果你用 <code>Promise.resolve()</code> 包装了代码的话，你永远都可以在代码后面加上 <code>catch()</code>。</p><p>相同的，使用 <code>Promise.reject()</code> 可以立即返回一个状态为 <code>rejected</code> 的 <code>promise</code> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'some awful error'</span>));</span><br></pre></td></tr></table></figure><h3 id="进阶错误-2：cacth-和-then-null-…-并不完全相同"><a href="#进阶错误-2：cacth-和-then-null-…-并不完全相同" class="headerlink" title="进阶错误 2：cacth() 和 then(null, …) 并不完全相同"></a>进阶错误 2：cacth() 和 then(null, …) 并不完全相同</h3><p>笔者提到过 <code>cacth()</code> 是 <code>then(null, ...)</code> 的语法糖，因此下面两个代码片段是等价的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somePromise().catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是，这并不意味着下面的两个代码片段是等价的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">somePromise()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果你不理解的话，那么请思考一下如果第一个回调函数抛出一个错误会发生什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">somePromise()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// I caught your error! :)</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// I didn't catch your error! :(</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>结论就是，当使用 <code>then(resolveHandler, rejectHandler)</code>，<code>rejectHandler</code> 不会捕获在 <code>resolveHandler</code> 中抛出的错误。</p><p>因为，笔者的个人习惯是从不使用 <code>then</code> 方法的第二个参数，转而使用 <code>catch()</code> 方法。但是也有例外，就是在笔者写异步的 <code>Mocha</code> 的测试用例的时候，如果想确认一个错误被抛出的话，代码是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should throw an error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingThatThrows().then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I expected an error!'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      should.exist(err);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>说到测试，将 <code>mocha</code> 和 <code>Chai</code> 联合使用是一种很好的测试 <code>promise API</code> 的方案。</p><h3 id="进阶错误-3：promise-vs-promise-factories"><a href="#进阶错误-3：promise-vs-promise-factories" class="headerlink" title="进阶错误 3：promise vs promise factories"></a>进阶错误 3：promise vs promise factories</h3><p>某些情况下你想一个接一个的执行一系列 <code>promise</code>，这时候你想要一个类似于 <code>Promise.all()</code> 的方法，但是 <code>Proimise.all()</code> 是并行执行的，不符合要求。你可能一时脑抽写下这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  promises.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    result = result.then(promise);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，这段代码不会按照你所想的那样执行，那些 <code>promise</code> 对象里的异步调用还是会并行的执行。原因是你根本不应当在 <code>promise</code> 对象组成的数组这个层级上操作。对于每个 <code>promise</code> 对象来说，一旦它被创建，相关的异步代码就开始执行了。因此，这里你真正想要的是一个 <code>promise</code> 工厂。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promiseFactories</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  promiseFactories.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">promiseFactory</span>) </span>&#123;</span><br><span class="line">    result = result.then(promiseFactory);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 <code>promise</code> 工厂非常简单，它就是一个返回 <code>promise</code> 对象的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromiseFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> somethingThatCreatesAPromise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么采用 <code>promise</code> 对象就可以达到目的呢？因为 <code>promise</code> 工厂只有在调用的时候才会创建 <code>promise</code> 对象。它和 <code>then()</code> 方法的工作方式很像，事实上，它们就是一样的东西。</p><h3 id="进阶错误-4：如果我想要两个-promise-的结果应当如何做呢"><a href="#进阶错误-4：如果我想要两个-promise-的结果应当如何做呢" class="headerlink" title="进阶错误 4：如果我想要两个 promise 的结果应当如何做呢"></a>进阶错误 4：如果我想要两个 promise 的结果应当如何做呢</h3><p>很多时候，一个 <code>promise</code> 的执行是依赖另一个 <code>promise</code> 的。但是在某些情况下，我们想得到两个 <code>promise</code> 的执行结果，比方说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// dangit, I need the "user" object too!</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>为了避免金字塔问题，我们可能会在外层作用域存储 <code>user</code> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user;</span><br><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    user = result;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// okay, I have both the "user" and the "userAccount"</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码能够到达想要的效果，但是这种显得不够专业，我建议抛开成见，拥抱金字塔：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span>(<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// okay, I have both the "user" and the "userAccount"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至少，是暂时拥抱金字塔。如果缩进真的成为了你代码中的一个大问题，那么你可以像每一个 <code>JavaScript</code> 程序员从开始写代码起就被教导的一样，将其中的部分抽出来作为一个单独的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUserAndUserAccount</span>(<span class="params">user, userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomething(user, userAccount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span>(<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> onGetUserAndUserAccount(user, userAccount);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .then(onGetUser)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// at this point, doSomething() is done, and we are back to indentation 0</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>随着你的 <code>promise</code> 代码越来越复杂，你会将越来越多的代码作为函数抽离出来。笔者发现这会促进代码风格变得优美：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">putYourRightFootIn()</span><br><span class="line">  .then(putYourRightFootOut)</span><br><span class="line">  .then(putYourRightFootIn)</span><br><span class="line">  .then(shakeItAllAbout);</span><br></pre></td></tr></table></figure><p>这就是 <code>promise</code> 的最终目的。</p><h3 id="进阶错误-5：promise-穿透"><a href="#进阶错误-5：promise-穿透" class="headerlink" title="进阶错误 5：promise 穿透"></a>进阶错误 5：promise 穿透</h3><p>这个错误我在前文中提到的问题中间接的给出了。这是个非常令人费解的案例，或许你永远不会写出这样的代码，但是这种写法还是让笔者感到震惊。 你认为下面的代码会输出什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>如果你认为输出的是 <code>bar</code>，那么你就错了。实际上它输出的是 <code>foo</code>！</p><p>产生这样的输出是因为你给 <code>then</code> 方法传递了一个非函数（比如 <code>promise</code> 对象）的值，代码会这样理解：<code>then(null)</code>，因此导致前一个 <code>promise</code> 的结果产生了坠落的效果。你可以自己测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line">  .then(<span class="literal">null</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>随便添加任意多个 <code>then(null)</code>，结果都是不变的</p><p>让我们回到之前讲解 <code>promise vs promise factoriesde</code> 的地方。简而言之，如果你直接给 <code>then</code> 方法传递一个 <code>promise</code> 对象，代码的运行是和你所想的不一样的。<code>then</code> 方法应当接受一个函数作为参数。因此你应当这样书写代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这样就会如愿输出 <code>bar</code>。</p><h3 id="答案来了"><a href="#答案来了" class="headerlink" title="答案来了"></a>答案来了</h3><p>下面给出前文题目的解答</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#1</span><br><span class="line"></span><br><span class="line">    doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">    &#125;).then(finalHandler);</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line">    doSomething</span><br><span class="line">    |-----------------|</span><br><span class="line">                      doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">                      |------------------|</span><br><span class="line">                                         finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                         |------------------|</span><br><span class="line"></span><br><span class="line">#2</span><br><span class="line"></span><br><span class="line">    doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      doSomethingElse();</span><br><span class="line">    &#125;).then(finalHandler);</span><br><span class="line"><span class="string">``</span></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line">    doSomething</span><br><span class="line">    |-----------------|</span><br><span class="line">                      doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">                      |------------------|</span><br><span class="line">                      finalHandler(<span class="literal">undefined</span>)</span><br><span class="line">                      |------------------|</span><br><span class="line"></span><br><span class="line">#3</span><br><span class="line"></span><br><span class="line">    doSomething().then(doSomethingElse())</span><br><span class="line">      .then(finalHandler);</span><br><span class="line"></span><br><span class="line">答案</span><br><span class="line"></span><br><span class="line">    doSomething</span><br><span class="line">    |-----------------|</span><br><span class="line">    doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">    |---------------------------------|</span><br><span class="line">                      finalHandler(resultOfDoSomething)</span><br><span class="line">                      |------------------|</span><br><span class="line"></span><br><span class="line">#4</span><br><span class="line"></span><br><span class="line">    doSomething().then(doSomethingElse)</span><br><span class="line">      .then(finalHandler);</span><br><span class="line"></span><br><span class="line">答案</span><br><span class="line"></span><br><span class="line">    doSomething</span><br><span class="line">    |-----------------|</span><br><span class="line">                      doSomethingElse(resultOfDoSomething)</span><br><span class="line">                      |------------------|</span><br><span class="line">                                         finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                         |------------------|</span><br></pre></td></tr></table></figure><p>需要说明的是，在上述的例子中，我都假设 <code>doSomething()</code> 和 <code>doSomethingElse()</code> 返回一个 <code>promise</code> 对象，这些 <code>promise</code> 对象都代表了一个异步操作，这样的操作会在当前 <code>event loop</code> 之外结束，比如说有关 <code>IndexedDB，network</code> 的操作，或者是使用 <code>setTimeout</code>。这里给出 <a href="http://jsbin.com/tuqukakawo/1/edit?js,console,output" target="_blank" rel="noopener">JSBin</a> 上的示例。</p><h3 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h3><p><code>promise</code> 是个好东西。如果你还在使用传统的回调函数的话，我建议你迁移到 <code>promise</code> 上。这样你的代码会更简洁，更优雅，可读性也更强。</p><p>有这样的观点：<code>promise</code> 是不完美的。<code>promise</code> 确实比使用回调函数好，但是，如果你有别的选择的话，这两种方式最好都不要用。</p><p>尽管相比回调函数有许多优点，promise 仍然是难于理解的，并且使用起来很容易出错。新手和卖家都会经常将 <code>promise</code> 用的乱七八糟。不过这并不是他们的错。问题在于 <code>promise</code> 和我们写的同步代码非常相似，但仅此而已，并不尽然。</p><p>在同步环境下，你无需学习这些晦涩难懂的规则和新的 <code>API</code>。你可以随意使用像 <code>return</code>、<code>catch</code> 和 <code>throw</code> 这样的关键字以及 <code>for</code> 循环。你不需要时刻在脑中保持两个相并列的编程思想。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC等Formatting Contexts浅析</title>
      <link href="/224.html"/>
      <url>/224.html</url>
      
        <content type="html"><![CDATA[<h3 id="BFC-是什么"><a href="#BFC-是什么" class="headerlink" title="BFC 是什么"></a>BFC 是什么</h3><p><code>BFC(Block formatting context)</code> 直译为”块级格式化上下文”。它是一个独立的渲染区域，只有 <code>Block-level box</code> 参与，它规定了内部的 <code>Block-level Box</code> 如何布局，并且与这个区域外部毫不相干。同理，还有 <code>inline-level box，run-in box</code>。</p><h3 id="BFC-布局规则"><a href="#BFC-布局规则" class="headerlink" title="BFC 布局规则"></a>BFC 布局规则</h3><ul><li>内部的 <code>Box</code> 会在垂直方向，一个接一个地放置。</li><li><code>Box</code> 垂直方向的距离由 <code>margin</code> 决定。属于同一个 <code>BFC</code> 的两个相邻 <code>Box</code> 的 <code>margin</code> 会发生重叠。</li><li>每个元素的 <code>margin box</code> 的左边， 与包含块 <code>border box</code> 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li><code>BFC</code> 的区域不会与 <code>float box</code> 重叠。</li><li><code>BFC</code> 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算 <code>BFC</code> 的高度时，浮动元素也参与计算。</li></ul><h3 id="哪些元素是-BFC"><a href="#哪些元素是-BFC" class="headerlink" title="哪些元素是 BFC"></a>哪些元素是 BFC</h3><ul><li>根元素，即 <code>HTML</code> 元素</li><li><code>float</code> 属性不为 <code>none</code></li><li><code>position</code> 为 <code>absolute</code> 或 <code>fixed</code></li><li><code>display</code> 为 <code>inline-block, table-cell, table-caption, flex, inline-flex</code></li><li><code>overflow</code> 不为 <code>visible</code></li></ul><h3 id="BFC-有什么用"><a href="#BFC-有什么用" class="headerlink" title="BFC 有什么用"></a>BFC 有什么用</h3><ul><li>自适应两栏布局</li><li>清除内部浮动（如给父元素加 <code>overflow:hidden</code>）</li><li>分属于不同的 <code>BFC</code> 时可以阻止 <code>margin</code> 重叠</li></ul><h3 id="什么是-FC"><a href="#什么是-FC" class="headerlink" title="什么是 FC"></a>什么是 FC</h3><p><code>FC</code> 的全称是：<code>Formatting Contexts</code>，是 <code>W3C CSS2.1</code> 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p><code>FC</code> 一共包含 <code>BFC、IFC、GFC、FFC</code> 四种类型。<code>CSS2.1</code> 规范中只有 <code>BFC、IFC。CSS3</code> 推出 <code>GFC、FFC</code> 两种新类型。</p><h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><p><code>IFC(Inline Formatting Contexts)</code> 直译为”内联格式化上下文”，<code>IFC</code> 的 <code>line box</code>（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 <code>padding/margin</code> 影响)。</p><h4 id="IFC-特性"><a href="#IFC-特性" class="headerlink" title="IFC 特性"></a>IFC 特性</h4><ul><li><code>IFC</code> 中的 <code>line box</code> 一般左右都贴紧整个 <code>IFC</code>，但是会因为 <code>float</code> 元素而扰乱。<code>float</code> 元素会位于 <code>IFC</code> 与与 <code>line box</code> 之间，使得 l<code>ine box</code> 宽度缩短。</li><li><code>IFC</code> 中时不可能有块级元素的，当插入块级元素时（如 <code>p</code> 中插入 <code>div</code>）会产生两个匿名块与 <code>div</code> 分隔开，即产生两个 <code>IFC</code>，每个 <code>IFC</code> 对外表现为块级元素，与 <code>div</code> 垂直排列。</li></ul><h4 id="IFC-作用"><a href="#IFC-作用" class="headerlink" title="IFC 作用"></a>IFC 作用</h4><ul><li>水平居中：当一个块要在环境中水平居中时，设置其为 <code>inline-block</code> 则会在外层产生 <code>IFC</code>，通过 <code>text-align</code> 则可以使其水平居中。</li><li>垂直居中：创建一个 <code>IFC</code>，用其中一个元素撑开父元素的高度，然后设置其 <code>vertical-align:middle</code>，其他行内元素则可以在此父元素下垂直居中。</li></ul><h3 id="GFC"><a href="#GFC" class="headerlink" title="GFC"></a>GFC</h3><p><code>GFC(GridLayout Formatting Contexts)</code> 直译为”网格布局格式化上下文”，当为一个元素设置 <code>display</code> 值为 <code>grid</code> 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（<code>grid container</code>）上定义网格定义行（<code>grid definition rows</code>）和网格定义列（<code>grid definition columns</code>）属性各在网格项目（<code>grid item</code>）上定义网格行（<code>grid row</code>）和网格列（<code>grid columns</code>）为每一个网格项目（<code>grid item</code>）定义位置和空间。</p><p><code>GFC</code> 将改变传统的布局模式，他将让布局从一维布局变成了二维布局。简单的说，有了 <code>GFC</code> 之后，布局不再局限于单个维度了。这个时候你要实现类似九宫格，拼图之类的布局效果显得格外的容易。</p><h3 id="FFC"><a href="#FFC" class="headerlink" title="FFC"></a>FFC</h3><p><code>FFC(Flex Formatting Contexts)</code> 直译为”自适应格式化上下文”，<code>display</code> 值为 <code>flex</code> 或者 <code>inline-flex</code> 的元素将会生成自适应容器<code>（flex container）</code>。</p><p><code>Flex Box</code> 由伸缩容器和伸缩项目组成。通过设置元素的 <code>display</code> 属性为 <code>flex</code> 或 <code>inline-flex</code> 可以得到一个伸缩容器。设置为 <code>flex</code> 的容器被渲染为一个块级元素，而设置为 <code>inline-flex</code> 的容器则渲染为一个行内元素。</p><p>伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，<code>Flexbox</code> 定义了伸缩容器内伸缩项目该如何布局。</p><p>整体来说，<code>FFC</code> 与 <code>BFC</code> 有点儿类似，但仍有以下几点区别：</p><ul><li><code>Flexbox</code> 不支持 <code>::first-line</code> 和 <code>::first-letter</code> 这两种伪元素</li><li><code>vertical-align</code> 对 <code>Flexbox</code> 中的子元素是没有效果的</li><li><code>float</code> 和 <code>clear</code> 属性对 <code>Flexbox</code> 中的子元素是没有效果的，也不会使子元素脱离文档流(但是对 <code>Flexbox</code> 是有效果的！)</li><li>多栏布局（<code>column-*</code>） 在 <code>Flexbox</code> 中也是失效的，就是说我们不能使用多栏布局在 <code>Flexbox</code> 排列其下的子元素</li><li><code>Flexbox</code> 下的子元素不会继承父级容器的宽</li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端前端适配方案总结</title>
      <link href="/218.html"/>
      <url>/218.html</url>
      
        <content type="html"><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>在介绍各方案之前，先有必要了解一些必备的名词。</p><h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>全称 <code>pixel</code>，像素。一个像素就是计算机屏幕所能显示一种特定颜色的最小区域。屏幕上显示数据最基本的点，不是长度单位。 如果点很小，那画面就清晰，我们称它为“分辨率高”，反之，就是“分辨率低”。</p><h3 id="ppi"><a href="#ppi" class="headerlink" title="ppi"></a>ppi</h3><p>全称 <code>Pixels Per Inch</code>，屏幕像素密度。单位是 <code>dpi</code>，表示的是每英寸所拥有的像素(<code>Pixel</code>)数目。 越大屏幕越高清。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量，iphone5 屏幕上垂直有 1136 个物理像素，水平有 640 个物理像素。<a href="https://www.sven.de/dpi/" target="_blank" rel="noopener">查询设备的分辨率及 ppi</a></p><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>相对长度单位。相对于根元素(即 <code>html</code> 元素)的 <code>font-size</code> 计算值的倍数。</p><h3 id="物理像素（设备像素）"><a href="#物理像素（设备像素）" class="headerlink" title="物理像素（设备像素）"></a>物理像素（设备像素）</h3><p>设备屏幕上的实际像素。如 <code>iphone6</code> 宽为 <code>750</code>。</p><h3 id="设备独立像素（逻辑像素-css-像素）"><a href="#设备独立像素（逻辑像素-css-像素）" class="headerlink" title="设备独立像素（逻辑像素/css 像素）"></a>设备独立像素（逻辑像素/css 像素）</h3><p>设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: <code>css</code> 像素)，然后由相关系统转换为物理像素。如 <code>iphone6</code> 为 <code>375×667</code>。</p><h3 id="设备像素比-device-pixel-ratio-屏幕分辩比-dpr"><a href="#设备像素比-device-pixel-ratio-屏幕分辩比-dpr" class="headerlink" title="设备像素比(device pixel ratio/屏幕分辩比/dpr)"></a>设备像素比(device pixel ratio/屏幕分辩比/dpr)</h3><p><code>设备像素比 = 物理像素 / 设备独立像素</code></p><p>在某一方向上，<code>x</code> 方向或者 <code>y</code> 方向。在控制台通过 <code>window.devicePixelRatio</code> 可得。</p><h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h3><p><code>scale</code> 是屏幕拉伸比。也就是视口上的 <code>initial-scale</code> , <code>maximum-sacle</code> 等属性。</p><h3 id="视口（viewport）"><a href="#视口（viewport）" class="headerlink" title="视口（viewport）"></a>视口（viewport）</h3><ul><li><p>布局视口：网页在开始设计时候的 <code>dom</code> 宽度（比如 <code>960px</code>）</p></li><li><p>可视视口：整个屏幕的视口（比如 <code>iphone6</code> <code>375px</code>）</p></li><li><p>完美视口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1.0,width=device-width,user-scalable=0,maximum-scale=1.0"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  width：设置布局视口的宽 </span></span><br><span class="line"><span class="comment">  init-scale：设置页面的初始缩放程度 </span></span><br><span class="line"><span class="comment">  minimum-scale：设置了页面最小缩放程度</span></span><br><span class="line"><span class="comment">  maximum-scale：设置了页面最大缩放程度 </span></span><br><span class="line"><span class="comment">  user-scalable：是否允许用户对页面进行缩放操作</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="目前主流的自适应布局解决方案"><a href="#目前主流的自适应布局解决方案" class="headerlink" title="目前主流的自适应布局解决方案"></a>目前主流的自适应布局解决方案</h2><h3 id="响应式（Responsive-web-design"><a href="#响应式（Responsive-web-design" class="headerlink" title="响应式（Responsive web design)"></a>响应式（Responsive web design)</h3><p>通过媒体查询根据不同的屏幕分辨率来进行适配。</p><p>优点:</p><ul><li><code>media query</code> 可以做到设备像素比的判断，方法简单，成本低，特别是对移动和 <code>PC</code> 维护同一套代码的时候。目前像 <code>Bootstrap</code> 等框架使用这种方式布局。</li><li>图片便于修改，只需修改 <code>css</code> 文件。</li><li>调整屏幕宽度的时候不用刷新页面即可响应式展示。</li></ul><p>缺点:</p><ul><li>代码量比较大，维护不方便。</li><li>为了兼顾大屏幕或高清设备，会造成其他设备资源浪费，特别是加载图片资源。</li><li>为了兼顾移动端和 <code>PC</code> 端各自响应式的展示效果，难免会损失各自特有的交互方式。</li></ul><h3 id="流式布局（推荐）"><a href="#流式布局（推荐）" class="headerlink" title="流式布局（推荐）"></a>流式布局（推荐）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=width=device-width,initial-scale=1,maximum-scale=1, minimum-scale=1,user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>流式布局需要用到<code>百分比</code>或者 <code>flex</code>，即宽度永远铺满页面宽度，但高度和其他单位仍然用 <code>px</code>。它的字体精度可以保持跟设备系统一致（<code>dpi</code>）。</p><h3 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h3><h4 id="法一（推荐）"><a href="#法一（推荐）" class="headerlink" title="法一（推荐）"></a>法一（推荐）</h4><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>(100vw / 7.5);</span><br><span class="line">&#125; <span class="comment">/* 以iphone6 750的设计稿为准 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他元素用rem作为单位 */</span></span><br></pre></td></tr></table></figure><p>js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeRootFont</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> designWidth = <span class="number">750</span>,</span><br><span class="line">      rem2px = <span class="number">100</span>; <span class="comment">//这个100理论上可以是任何值</span></span><br><span class="line">    <span class="built_in">document</span>.documentElement.style.fontsize = (<span class="built_in">window</span>.innerWidth / designWidth) * rem2px + <span class="string">'px'</span>; <span class="comment">//iphone6: (375 / 750) * 100 + 'px';</span></span><br><span class="line">    <span class="comment">// 因为chrome下最小字体大小为12px，所以不能把html的font-size设置成0.5px或者5px，50px是我们最好的选择。</span></span><br><span class="line">  &#125;</span><br><span class="line">  changeRootFont();</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, changeRootFont, <span class="literal">false</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>此方法简单粗暴，无需考虑 <code>dpr</code>，物理像素之类。但缺陷就是 1px，图片高清，文字字体大小问题。文字大小可通过媒体查询来处理。计算量大，可通过 <code>px2rem</code> 插件来处理。</p><h4 id="法二（不推荐）"><a href="#法二（不推荐）" class="headerlink" title="法二（不推荐）"></a>法二（不推荐）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dpr, rem, scale;</span><br><span class="line"><span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement;</span><br><span class="line"><span class="keyword">var</span> fontEl = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line"><span class="keyword">var</span> metaEl = <span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>);</span><br><span class="line"></span><br><span class="line">dpr = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>;</span><br><span class="line">rem = (docEl.clientWidth * dpr) / <span class="number">10</span>;</span><br><span class="line">scale = <span class="number">1</span> / dpr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置viewport，进行缩放，达到高清效果</span></span><br><span class="line">metaEl.setAttribute(<span class="string">'content'</span>, <span class="string">'width='</span> + dpr * docEl.clientWidth + <span class="string">',initial-scale='</span> + scale + <span class="string">',maximum-scale='</span> + scale + <span class="string">', minimum-scale='</span> + scale + <span class="string">',user-scalable=no'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置data-dpr属性，留作的css hack之用</span></span><br><span class="line">docEl.setAttribute(<span class="string">'data-dpr'</span>, dpr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态写入样式</span></span><br><span class="line">docEl.firstElementChild.appendChild(fontEl);</span><br><span class="line">fontEl.innerHTML = <span class="string">'html&#123;font-size:'</span> + rem + <span class="string">'px!important;&#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给js调用的，某一dpr下rem和px之间的转换函数</span></span><br><span class="line"><span class="built_in">window</span>.rem2px = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  v = <span class="built_in">parseFloat</span>(v);</span><br><span class="line">  <span class="keyword">return</span> v * rem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.px2rem = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  v = <span class="built_in">parseFloat</span>(v);</span><br><span class="line">  <span class="keyword">return</span> v / rem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.dpr = dpr;</span><br><span class="line"><span class="built_in">window</span>.rem = rem;</span><br></pre></td></tr></table></figure><p>引入以上代码即可用。通过 <code>hack</code> 的 <code>data-dpr</code> 来单独控制字体。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span>: 16<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-attr">[data-dpr='2']</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">32px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方案原理是动态修改 <code>scale</code> 和 <code>font-size</code> 来达到高清效果。类似的可参照阿里的 <code>flexible</code>。</p><p>此方法解决了方法一存在的问题，缺陷是计算量大，可通过 <code>px2rem</code> 插件来处理。</p><h3 id="scale-伸缩布局"><a href="#scale-伸缩布局" class="headerlink" title="scale 伸缩布局"></a>scale 伸缩布局</h3><p>视觉稿、页面宽度、<code>viewport width</code> 使用统一宽度，利用浏览器自身缩放完成适配。页面样式（包括图像元素）完全按照视觉稿的尺寸，使用定值单位 （<code>px、em</code>）即可完成。</p><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>通过 <code>js</code> 更改 <code>viewport</code> 的 <code>initial-scale</code>。</p><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p>写死 <code>viewport</code> 的宽度.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=360, user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>优点:</p><ul><li>开发简单：缩放交给浏览器，完全按视觉稿切图。</li><li>还原精准：绝对等比例缩放，可以精准还原视觉稿（不考虑清晰度的情况下）。</li><li>测试方便：在 <code>PC</code> 端即可完成大部分测试，手机端只需酌情调整一些细节（比如图标、字体混合排列时，因为字体不同造成的对齐问题）。</li></ul><p>缺点:</p><ul><li>像素丢失：对于一些分辨率较低的手机，可能设备像素还未达到指定的 <code>viewport</code> 宽度，此时屏幕的渲染可能就不准确了。比较常见的是边框“消失”了，不过随着手机硬件的更新，这个问题会越来越少的。</li><li>缩放失效：某些安卓机不能正常的根据 <code>meta</code> 标签中 <code>width</code> 的值来缩放 <code>viewport</code>，需要配合 <code>initial-scale</code>。</li><li>文本折行：存在于缩放失效的机型中，某些手机为了便于文本的阅读，在文本到达 <code>viewport</code> 边缘（非元素容器的边缘）时即进行折行，而当 <code>viewport</code> 宽度被修正后，浏览器并没有正确的重绘，所以就发现文本没有占满整行。一些常用的段落性文本标签会存在该问题。</li><li>不能开启 <code>gpu raster</code> 硬件加速：不能显式设置 <code>minimum-scale=1.0</code>，否则就达不到效果。而这个值是 <code>chromium37</code> 以上的 <code>webview</code> 触发 <code>gpu raster</code> 的一个条件，所以用这种方法就没法利用 <code>gpu raster</code> 硬件加速。</li></ul><p>注：</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="retina-下图片高清方案"><a href="#retina-下图片高清方案" class="headerlink" title="retina 下图片高清方案"></a>retina 下图片高清方案</h3><ol><li>两倍图片(<code>@2x</code>)，然后图片容器缩小 <code>50%</code>(方便但会造成资源浪费)。</li><li>不同的 <code>dpr</code> 下，加载不同的尺寸的图片。</li></ol><h3 id="retina-下-1px-解决方案"><a href="#retina-下-1px-解决方案" class="headerlink" title="retina 下 1px 解决方案"></a>retina 下 1px 解决方案</h3><h4 id="元素-scale（方便但圆角等无法用）"><a href="#元素-scale（方便但圆角等无法用）" class="headerlink" title="元素 scale（方便但圆角等无法用）"></a>元素 <code>scale</code>（方便但圆角等无法用）</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scale</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scaleY</span>(0.5);</span><br><span class="line">  <span class="attribute">-webkit-transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="页面-scale（通用但页面整体都被缩放）"><a href="#页面-scale（通用但页面整体都被缩放）" class="headerlink" title="页面 scale（通用但页面整体都被缩放）"></a>页面 <code>scale</code>（通用但页面整体都被缩放）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=width=device-width,initial-scale=0.5,maximum-scale=0.5, minimum-scale=0.5,user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）书写高效CSS</title>
      <link href="/213.html"/>
      <url>/213.html</url>
      
        <content type="html"><![CDATA[<p><code>css</code> 规范并不会强行规定浏览器必须如何实现样式系统，只会规定浏览器必须实现什么。因此，不同的样式系统引擎拥有不同的性能，开源的 Gecko 和 Webkit 算法类似，因此优缺点也类似。因此，下面的建议在大部分的 <code>web</code> 浏览器上应该是有意义的。</p><p>第一部分简单介绍样式系统规则分类；后面的章节主要指导如何利用样式系统的实现原理，来书写更有效率的规则。</p><h2 id="样式系统如何建立规则"><a href="#样式系统如何建立规则" class="headerlink" title="样式系统如何建立规则"></a>样式系统如何建立规则</h2><p>样式系统的规则分为四大类</p><ol><li>ID</li><li>class</li><li>tag</li><li>通用规则</li></ol><p>理解这四类规则非常关键，这是规则匹配的基础。</p><p>在接下来的段落中，我会使用”关键选择“（<code>key selector</code>)术语。<code>key selector</code> 是选择器的最后一部分。</p><p>例如，在下面的规则中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">img</span>,</span><br><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">p</span>,</span><br><span class="line"><span class="selector-tag">h1</span> + <span class="selector-tag">title</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>key selector</code> 是 <code>img</code>,<code>p</code> 和 <code>title</code>。</p><h3 id="ID-rules"><a href="#ID-rules" class="headerlink" title="ID rules"></a>ID rules</h3><p>第一类是使用 <code>ID</code> 选择器作为 <code>key selector</code>.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-id">#backButton</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* This is an ID-categorized rule */</span></span><br><span class="line"><span class="selector-id">#urlBar</span><span class="selector-attr">[type='autocomplete']</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* This is an ID-categorized rule */</span></span><br><span class="line"><span class="selector-tag">treeitem</span> &gt; <span class="selector-tag">treerow</span> &gt; <span class="selector-tag">treecell</span><span class="selector-id">#myCell</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* This is an ID-categorized rule */</span></span><br></pre></td></tr></table></figure><h3 id="Class-rules"><a href="#Class-rules" class="headerlink" title="Class rules"></a>Class rules</h3><p>第二类是使用了 <code>class</code> 选择器作为 <code>key selector</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-class">.toolbarButton</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* A class-based rule */</span></span><br><span class="line"><span class="selector-class">.fancyText</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* A class-based rule */</span></span><br><span class="line"><span class="selector-tag">menuitem</span> &gt; <span class="selector-class">.menu-left</span><span class="selector-attr">[checked='true']</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* A class-based rule */</span></span><br></pre></td></tr></table></figure><h3 id="Tag-rules"><a href="#Tag-rules" class="headerlink" title="Tag rules"></a>Tag rules</h3><p>如果既不是 <code>class</code> 也不是 <code>ID</code> 作为 <code>key selector</code>,下一个候选是 <code>tag</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">td</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* A tag-based rule */</span></span><br><span class="line"><span class="selector-tag">treeitem</span> &gt; <span class="selector-tag">treerow</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* A tag-based rule */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type='checkbox']</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* A tag-based rule */</span></span><br></pre></td></tr></table></figure><h3 id="Universal-rules"><a href="#Universal-rules" class="headerlink" title="Universal rules"></a>Universal rules</h3><p>剩下的均为此类。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[hidden='true']</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* A universal rule */</span></span><br><span class="line">* &#123;</span><br><span class="line">&#125; <span class="comment">/* A universal rule */</span></span><br><span class="line"><span class="selector-tag">tree</span> &gt; <span class="selector-attr">[collapsed='true']</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* A universal rule */</span></span><br></pre></td></tr></table></figure><h2 id="样式系统如何匹配规则"><a href="#样式系统如何匹配规则" class="headerlink" title="样式系统如何匹配规则"></a>样式系统如何匹配规则</h2><p>样式系统从 <code>key selector</code> 开始匹配，然后向左继续，寻找选择器的任意祖先。只要选择器的子树继续导出（这样翻译感觉怪怪的），样式系统会继续往左移动，直到要么匹配规则，要么因为不匹配终止。</p><p>最基本的概念是了解规则过滤。这些类别存在的目的是过滤掉不相关的规则，这样样式系统不用浪费时间去匹配它们。</p><p>这是提升性能的关键：检查一个指定的元素，规则越少，系统解析就越快。</p><p>例如，如果元素指定了 <code>ID</code>，那么只有与元素 <code>ID</code> 相同的 <code>ID rule</code> 会进行检查。只有存在于元素 <code>class</code> 列表的 <code>class</code> 规则才会进行检查。只有与标签相同的 <code>tag rule</code> 会被进行检查。通用规则总是会被检查。</p><h2 id="高效-css-建议"><a href="#高效-css-建议" class="headerlink" title="高效 css 建议"></a>高效 css 建议</h2><h3 id="避免使用通用规则"><a href="#避免使用通用规则" class="headerlink" title="避免使用通用规则"></a>避免使用通用规则</h3><p>避免一个规则的结束是通用规则这一类。</p><h3 id="不要使用-tag-或者-class-修饰-ID-rule"><a href="#不要使用-tag-或者-class-修饰-ID-rule" class="headerlink" title="不要使用 tag 或者 class 修饰 ID rule"></a>不要使用 tag 或者 class 修饰 ID rule</h3><p>如果一个规则使用了 <code>ID</code> 选择器作为 <code>key selector</code>，不要再添加 <code>tag</code> 标签指定。因为 <code>ID</code> 是唯一的，增加 <code>tag name</code> 会增加不必要的额外的匹配工作。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BAD */</span></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-id">#backButton</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu-left</span><span class="selector-id">#newMenuIcon</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GOOD */</span></span><br><span class="line"><span class="selector-id">#backButton</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#newMenuIcon</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例外：当需要通过改变元素的 class 来应用不同的样式，但是同样的 class 将会被其他元素共享。</p></blockquote><h4 id="不要使用-tag-修饰-class-规则"><a href="#不要使用-tag-修饰-class-规则" class="headerlink" title="不要使用 tag 修饰 class 规则"></a>不要使用 tag 修饰 class 规则</h4><p>尽管 <code>class</code> 可以在同一个页面重复出现，但是它的唯一性比 <code>tag</code> 更强。</p><p>你可以约定在 <code>class</code> 名称中包含 <code>tag</code> 名称，但是这会损失一些灵活性。当设计改变 <code>tag</code> 时，<code>class</code> 也会跟着变化。最好的是使用语义名称的 <code>class name</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BAD */</span></span><br><span class="line"><span class="selector-tag">treecell</span><span class="selector-class">.indented</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GOOD */</span></span><br><span class="line"><span class="selector-class">.treecell-indented</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BEST */</span></span><br><span class="line"><span class="selector-class">.hierarchy-deep</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用最特定的一类规则"><a href="#使用最特定的一类规则" class="headerlink" title="使用最特定的一类规则"></a>使用最特定的一类规则</h3><p><code>tag</code> 这类会匹配太多的规则，这会大大的降低效率。通过给元素增加 <code>class</code>，我们可以回 <code>class</code> 分类进行细分，减少匹配时间。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BAD */</span></span><br><span class="line"><span class="selector-tag">treeitem</span><span class="selector-attr">[mailfolder='true']</span> &gt; <span class="selector-tag">treerow</span> &gt; <span class="selector-tag">treecell</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GOOD */</span></span><br><span class="line"><span class="selector-class">.treecell-mailfolder</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免使用后代选择器"><a href="#避免使用后代选择器" class="headerlink" title="避免使用后代选择器"></a>避免使用后代选择器</h3><p>后代选择器是 <code>css</code> 中最耗时的选择器。尤其当选择器是 <code>tag</code> 或者通用这一类。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BAD */</span></span><br><span class="line"><span class="selector-tag">treehead</span> <span class="selector-tag">treerow</span> <span class="selector-tag">treecell</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BETTER, BUT STILL BAD (see next guideline) */</span></span><br><span class="line"><span class="selector-tag">treehead</span> &gt; <span class="selector-tag">treerow</span> &gt; <span class="selector-tag">treecell</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tag-分类规则永远不要包含孩子选择器"><a href="#tag-分类规则永远不要包含孩子选择器" class="headerlink" title="tag 分类规则永远不要包含孩子选择器"></a>tag 分类规则永远不要包含孩子选择器</h3><p>避免使用孩子选择器在 <code>tag</code> 分类规则中。这会显著增长匹配时间。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BAD */</span></span><br><span class="line"><span class="selector-tag">treehead</span> &gt; <span class="selector-tag">treerow</span> &gt; <span class="selector-tag">treecell</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GOOD */</span></span><br><span class="line"><span class="selector-class">.treecell-header</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="质疑所有使用孩子选择器的地方"><a href="#质疑所有使用孩子选择器的地方" class="headerlink" title="质疑所有使用孩子选择器的地方"></a>质疑所有使用孩子选择器的地方</h3><p>使用孩子选择器时务必谨慎，尽可能避免使用。</p><p>特别是，子选择器频繁适用于 <code>RDF</code> 树(这个自行 Google 吧)和 menus，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BAD */</span></span><br><span class="line"><span class="selector-tag">treeitem</span><span class="selector-attr">[IsImapServer='true']</span> &gt; <span class="selector-tag">treerow</span> &gt; <span class="selector-class">.tree-folderpane-icon</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="依靠继承"><a href="#依靠继承" class="headerlink" title="依靠继承"></a>依靠继承</h4><p>了解哪些属性继承，然后使用继承。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BAD */</span></span><br><span class="line"><span class="selector-id">#bookmarkMenuItem</span> &gt; <span class="selector-class">.menu-left</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-image</span>: <span class="built_in">url</span>(blah);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GOOD */</span></span><br><span class="line"><span class="selector-id">#bookmarkMenuItem</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-image</span>: <span class="built_in">url</span>(blah);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css居中完整版</title>
      <link href="/208.html"/>
      <url>/208.html</url>
      
        <content type="html"><![CDATA[<p>是时候对 <code>css</code> 居中的各种方式来波总结了！下面是一提到居中就应该联想到的关键属性：</p><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h3 id="行内元素-行内块级元素特有"><a href="#行内元素-行内块级元素特有" class="headerlink" title="行内元素/行内块级元素特有"></a>行内元素/行内块级元素特有</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="块级元素特有"><a href="#块级元素特有" class="headerlink" title="块级元素特有"></a>块级元素特有</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两者都可使用"><a href="#两者都可使用" class="headerlink" title="两者都可使用"></a>两者都可使用</h3><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法三"><a href="#法三" class="headerlink" title="法三"></a>法三</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">100px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法六"><a href="#方法六" class="headerlink" title="方法六"></a>方法六</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法七"><a href="#方法七" class="headerlink" title="方法七"></a>方法七</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法八"><a href="#方法八" class="headerlink" title="方法八"></a>方法八</h3><p><a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="noopener">ghost element</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ghost-center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ghost-center</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">' '</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1%</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ghost-center</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局总结</title>
      <link href="/203.html"/>
      <url>/203.html</url>
      
        <content type="html"><![CDATA[<p>布局的传统解决方案，基于盒状模型，依赖 <code>display 属性 + position 属性 + float 属性</code>。</p><h4 id="什么是-flex-布局"><a href="#什么是-flex-布局" class="headerlink" title="什么是 flex 布局"></a>什么是 flex 布局</h4><p><code>Flex</code>（<code>Flexible Box</code>），即为”弹性布局”。设为 <code>Flex</code> 布局以后，子元素的 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 属性将失效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex; <span class="comment">/* inline元素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h4><p>以下属性设置在 <code>flex</code> 布局中的父元素（即设有 <code>display:flex</code> 的元素），用来控制内部子元素的行为。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: <span class="built_in">row</span>(默) | row-reverse | column | column-reverse;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: <span class="built_in">nowrap</span>(默) | wrap | wrap-reverse;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; &lt;flex-wrap&gt;;</span><br><span class="line">  <span class="attribute">justify-content</span>: <span class="built_in">flex-start</span>(默) | flex-end | center | space-between | space-around;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | <span class="built_in">stretch</span>(默);</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | <span class="built_in">stretch</span>(默);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>flex-direction</code>: 子元素的排列方向。<ul><li><code>row</code>: 水平方向，起点在左端。</li><li><code>row-reverse</code>: 水平方向，起点在右端。</li><li><code>column</code>: 垂直方向，起点在上沿。</li><li><code>column-reverse</code>: 垂直方向，起点在下沿。</li></ul></li><li><code>flex-wrap</code>: 如果子元素一条线排不下，如何换行。<ul><li><code>nowrap</code>: 不换行。</li><li><code>wrap</code>: 换行，第一行在上方。</li><li><code>wrap-reverse</code>: 换行，第一行在下方。</li></ul></li><li><code>flex-flow</code>: <code>flex-direction</code> 和 <code>flex-wrap</code> 的简写形式。</li><li><code>justify-content</code>: 子元素在一条横线上的对齐方式。<ul><li><code>flex-start</code>: 左对齐。</li><li><code>flex-end</code>: 右对齐。</li><li><code>center</code>: 居中。</li><li><code>space-between</code>: 两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>: 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></li><li><code>align-items</code>: 每个子元素在垂直方向上的对齐方式。<ul><li><code>flex-start</code>: 对齐顶部。</li><li><code>flex-end</code>: 对齐底部。</li><li><code>center</code>: 垂直居中。</li><li><code>baseline</code>: 子元素的第一行文字的基线对齐。</li><li><code>stretch</code>: 如果子元素未设置高度或设为 <code>auto</code>，将占满整个容器的高度。</li></ul></li><li><code>align-content</code>: 定义数量超过一行的子元素的垂直对齐方式。<ul><li><code>flex-start</code>: 对齐顶部。</li><li><code>flex-end</code>: 对齐底部。</li><li><code>center</code>: 垂直居中。</li><li><code>space-between</code>: 垂直两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>: 垂直两端对齐，每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>: 如果子元素未设置高度或设为 <code>auto</code>，将占满整个容器的高度。</li></ul></li></ul><h4 id="容器内子元素的属性"><a href="#容器内子元素的属性" class="headerlink" title="容器内子元素的属性"></a>容器内子元素的属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;; <span class="comment">/* 定义子元素的排列顺序。数值越小，排列越靠前，默认为0。 */</span></span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* 定义子元素的放大比例，默认为0，即如果存在剩余空间，也不放大。 */</span></span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* 定义了子元素的缩小比例，默认为1，即如果空间不足，该项目将缩小。 */</span></span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* 定义了子元素所占固定空间（如100px），默认auto */</span></span><br><span class="line">  <span class="attribute">flex</span>: &lt;flex-grow&gt; &lt;flex-shrink（可选）&gt; &lt;flex-basis（可选）&gt; ]; <span class="comment">/* 快捷值：auto (1 1 auto) 和 none (0 0 auto) */</span></span><br><span class="line">  <span class="attribute">align-self</span>: auto（默） | flex-start | flex-end | center | baseline | stretch; <span class="comment">/* 该属性用来覆盖父元素统一的align-items属性，达到该子元素的个性化 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）css画三角形等各类图标</title>
      <link href="/196.html"/>
      <url>/196.html</url>
      
        <content type="html"><![CDATA[<p><code>css3</code> 的属性 <code>transform</code>(转换) 用途很广泛，功能也很强大，为了熟悉它的各种转换方式(平移 <code>translate</code>，旋转 <code>rotate</code>，扭曲 <code>skew</code>，放缩 <code>scale</code>)，我做了一些平常常用的一些简单的图标。</p><p>这些图标很多是通过三角形来拼贴起来的，所以我们需要知道怎么样画三角形。</p><ol><li>我们要将该 <code>div</code> 的 <code>width</code> 和 <code>height</code> 都设置为 0，三角形是通过设置 <code>border</code> 来实现；</li><li>通过我们需要画成的三角形的目标分析，这个三角形的朝向(只针对规则的朝向：上、右、下、左、上左、上右、下右、下左，不规则的朝向可以通过旋转来实现)；</li><li>如果是上、右、下、左四种中的一种，将朝向的对面的 <code>border-color</code> 设置为我们需要的颜色，该朝向的这一边不设置 <code>border</code>，其它两边的 <code>border-color</code> 设置为 <code>transparent</code>；</li><li>如果是上左、上右、下右、下左中的一种，以上右为例，设置相关的两边：上和右的 <code>border-color</code> 设置成我们想要的颜色，其它两边的 <code>border-width</code> 设置成 <code>transparent</code>。</li><li><code>border-width</code> 的值就是底边长和高。</li></ol><h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><p><img src="http://cdn.flqin.com/p196-1.jpg" alt="三角形1"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bottom</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">2em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">1.8em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1.8em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.flqin.com/p196-2.jpg" alt="三角形2"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bottomLeft</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">2em</span> <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent <span class="number">#000</span> <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.flqin.com/p196-3.jpg" alt="三角形3"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bottomLeftRotate</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">2em</span> <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent <span class="number">#000</span> <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(60deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向上"><a href="#向上" class="headerlink" title="向上"></a>向上</h2><p><img src="http://cdn.flqin.com/p196-4.png" alt="向上"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.top</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: .<span class="number">9em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: .<span class="number">9em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: .<span class="number">9em</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.top</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>; <span class="comment">/*针对before,after必须加上*/</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: .<span class="number">7em</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">45em</span>; <span class="comment">/*宽度的一半，结合 left: 50%; 使用*/</span></span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.3em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向右"><a href="#向右" class="headerlink" title="向右"></a>向右</h2><p><img src="http://cdn.flqin.com/p196-5.png" alt="向右"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.3em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">1.1em</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -.<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">9em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: .<span class="number">9em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: .<span class="number">9em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向下"><a href="#向下" class="headerlink" title="向下"></a>向下</h2><p><img src="http://cdn.flqin.com/p196-6.png" alt="向下"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bottom</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.3em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bottom</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">1.1em</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: .<span class="number">9em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">9em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: .<span class="number">9em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向左"><a href="#向左" class="headerlink" title="向左"></a>向左</h2><p><img src="http://cdn.flqin.com/p196-7.png" alt="向左"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">9em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: .<span class="number">9em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: .<span class="number">9em</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="comment">/*在绝对定位中，top: 0; bottom: 0; margin: auto; 结合使用能竖直居中*/</span></span><br><span class="line">    <span class="attribute">left</span>: .<span class="number">7em</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.3em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确"><a href="#正确" class="headerlink" title="正确"></a>正确</h2><p><img src="http://cdn.flqin.com/p196-8.png" alt="正确"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.true</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(60deg);</span><br><span class="line">    <span class="attribute">transform-origin</span>: right center;</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">15em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.true</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: .<span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">left</span>: -.<span class="number">85em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(60deg);</span><br><span class="line">    <span class="attribute">transform-origin</span>: right center;</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">15em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p><img src="http://cdn.flqin.com/p196-9.png" alt="错误"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.false</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg);</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">15em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.false</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(90deg);</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">15em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><p><img src="http://cdn.flqin.com/p196-10.png" alt="菜单"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">3em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">15em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: .<span class="number">15em</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid none;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单-2"><a href="#菜单-2" class="headerlink" title="菜单 2"></a>菜单 2</h2><p><img src="http://cdn.flqin.com/p196-11.png" alt="菜单 2"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menu2</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu2</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: -.<span class="number">75em</span>;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu2</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: .<span class="number">75em</span>;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><img src="http://cdn.flqin.com/p196-12.png" alt="下载"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.download</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">8em</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: none solid solid;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.download</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: .<span class="number">7em</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.download</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: .<span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: .<span class="number">6em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">6em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: .<span class="number">6em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p><img src="http://cdn.flqin.com/p196-13.png" alt="上传"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.upload</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">8em</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: none solid solid;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.upload</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: .<span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.upload</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">1.1em</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: .<span class="number">6em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: .<span class="number">6em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: .<span class="number">6em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><img src="http://cdn.flqin.com/p196-14.png" alt="视频"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.video</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.5em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.2em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">3em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.video</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">1.4em</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -.<span class="number">7em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">7em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: .<span class="number">6em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: .<span class="number">7em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h2><p><img src="http://cdn.flqin.com/p196-15.png" alt="语音"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.voice</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.4em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: .<span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: none none solid;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="selector-class">.voice</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: .<span class="number">05em</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">8em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.3em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">4em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.voice</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: -.<span class="number">6em</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: .<span class="number">6em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: .<span class="number">4em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: .<span class="number">6em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h2><p><img src="http://cdn.flqin.com/p196-16.png" alt="播放"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.play</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">border</span>: .<span class="number">2em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.play</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: auto;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">3em</span>; <span class="comment">/*没有让其左右居中，因为看起来右边更空一些*/</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">6em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: .<span class="number">6em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: .<span class="number">9em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h2><p><img src="http://cdn.flqin.com/p196-17.png" alt="暂停"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pause</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">border</span>: .<span class="number">2em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pause</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: auto;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">35em</span>;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pause</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: auto;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">    <span class="attribute">margin-left</span>: .<span class="number">15em</span>;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上一首-集"><a href="#上一首-集" class="headerlink" title="上一首(集)"></a>上一首(集)</h2><p><img src="http://cdn.flqin.com/p196-18.png" alt="上一首(集)"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.previous</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">border</span>: .<span class="number">2em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.previous</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: auto;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">65em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">45em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: .<span class="number">45em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: .<span class="number">6em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.previous</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: auto;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">45em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: .<span class="number">45em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: .<span class="number">6em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下一首-集"><a href="#下一首-集" class="headerlink" title="下一首(集)"></a>下一首(集)</h2><p><img src="http://cdn.flqin.com/p196-19.png" alt="下一首(集)"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.next</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">border</span>: .<span class="number">2em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.next</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: auto;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">45em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: .<span class="number">45em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: .<span class="number">6em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.next</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: auto;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">    <span class="attribute">margin-left</span>: .<span class="number">05em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">45em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: .<span class="number">45em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: .<span class="number">6em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p><img src="http://cdn.flqin.com/p196-20.png" alt="停止"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.stop</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">border</span>: .<span class="number">2em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.stop</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="当前位置"><a href="#当前位置" class="headerlink" title="当前位置"></a>当前位置</h2><p><img src="http://cdn.flqin.com/p196-21.png" alt="当前位置"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.position</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">6em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">6em</span>;</span><br><span class="line">    <span class="attribute">border</span>: .<span class="number">4em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.position</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: .<span class="number">55em</span>;</span><br><span class="line">    <span class="attribute">left</span>: -.<span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: .<span class="number">7em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: .<span class="number">7em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pc"><a href="#pc" class="headerlink" title="pc"></a>pc</h2><p><img src="http://cdn.flqin.com/p196-22.png" alt="pc"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pc</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.4em</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: .<span class="number">2em</span> .<span class="number">2em</span> .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#efefef</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pc</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">1.2em</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">6em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pc</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">1.6em</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.6em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="phone"><a href="#phone" class="headerlink" title="phone"></a>phone</h2><p><img src="http://cdn.flqin.com/p196-23.png" alt="phone"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.phone</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.4em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#efefef</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: .<span class="number">3em</span> .<span class="number">2em</span> .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">15em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.phone</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: -.<span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p><img src="http://cdn.flqin.com/p196-24.png" alt="搜索"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.search</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: .<span class="number">15em</span>;</span><br><span class="line">    <span class="attribute">border-bottom-right-radius</span>: .<span class="number">15em</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(40deg);</span><br><span class="line">    <span class="attribute">transform-origin</span>: right center;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="selector-class">.search</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">1.3em</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: -.<span class="number">6em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border</span>: .<span class="number">3em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五角星"><a href="#五角星" class="headerlink" title="五角星"></a>五角星</h2><p><img src="http://cdn.flqin.com/p196-25.png" alt="五角星"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.star</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">7em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -.<span class="number">7em</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">7em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(72deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -.<span class="number">7em</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">7em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-72deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p><img src="http://cdn.flqin.com/p196-26.png" alt="电子邮件"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.email</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: .<span class="number">7em</span> <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent <span class="number">#000</span> <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.email</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">     <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">     <span class="attribute">position</span>: absolute;</span><br><span class="line">     <span class="attribute">top</span>: -.<span class="number">7em</span>;</span><br><span class="line">     <span class="attribute">left</span>: <span class="number">1em</span>;</span><br><span class="line">     <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(180deg);</span><br><span class="line">     <span class="attribute">transform-origin</span>: left center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: .<span class="number">7em</span> <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent <span class="number">#000</span> <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.email</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -.<span class="number">7em</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: .<span class="number">6em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: .<span class="number">9em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: .<span class="number">9em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="眼睛"><a href="#眼睛" class="headerlink" title="眼睛"></a>眼睛</h2><p><img src="http://cdn.flqin.com/p196-27.png" alt="眼睛"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.eye</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.2em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.eye</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">8em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">8em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.eye</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="未锁"><a href="#未锁" class="headerlink" title="未锁"></a>未锁</h2><p><img src="http://cdn.flqin.com/p196-28.png" alt="未锁"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.unlock</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.6em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.4em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.unlock</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -.<span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">right</span>: -.<span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">6em</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: .<span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid solid none;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.unlock</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">bottom</span>: .<span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">15em</span>;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: .<span class="number">25em</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: .<span class="number">25em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="杯子"><a href="#杯子" class="headerlink" title="杯子"></a>杯子</h2><p><img src="http://cdn.flqin.com/p196-29.png" alt="杯子"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.cup</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.3em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: .<span class="number">2em</span> .<span class="number">2em</span> <span class="number">1.2em</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#efefef</span>;</span><br><span class="line">    <span class="attribute">border-bottom-left-radius</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">border-bottom-right-radius</span>: .<span class="number">3em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cup</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: .<span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">left</span>: -.<span class="number">7em</span>;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">7em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.4em</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: .<span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">border-bottom-left-radius</span>: .<span class="number">3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="心"><a href="#心" class="headerlink" title="心"></a>心</h2><p><img src="http://cdn.flqin.com/p196-30.png" alt="心"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.heart</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.4em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-45deg);</span><br><span class="line">    <span class="attribute">transform-origin</span>: center bottom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -.<span class="number">7em</span>;</span><br><span class="line">    <span class="attribute">left</span>: -.<span class="number">7em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.4em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(90deg);</span><br><span class="line">    <span class="attribute">transform-origin</span>: center bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h2><p><img src="http://cdn.flqin.com/p196-31.png" alt="主页"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.home</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.4em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="selector-class">.home</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -.<span class="number">7em</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: .<span class="number">8em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.home</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><p><img src="http://cdn.flqin.com/p196-32.png" alt="密码"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.password</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.8em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.4em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.password</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -.<span class="number">6em</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border</span>: .<span class="number">2em</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.password</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">bottom</span>: .<span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">15em</span>;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: .<span class="number">25em</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: .<span class="number">25em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户-账号"><a href="#用户-账号" class="headerlink" title="用户(账号)"></a>用户(账号)</h2><p><img src="http://cdn.flqin.com/p196-33.png" alt="用户(账号)"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.user</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.user</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -.<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.8em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: .<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: .<span class="number">9em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单-3"><a href="#菜单-3" class="headerlink" title="菜单 3"></a>菜单 3</h2><p><img src="http://cdn.flqin.com/p196-34.png" alt="菜单 3"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#menu</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">10px</span> solid; <span class="comment">/*没有设置颜色值，将同文本颜色一样*/</span></span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">10px</span> solid;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: currentColor; <span class="comment">/*颜色关键字，将同文本颜色一致*/</span></span><br><span class="line">    <span class="attribute">background-clip</span>: content-box; <span class="comment">/*背景将绘制在内容方框内*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）CSS实现单行、多行文本溢出显示省略号</title>
      <link href="/192.html"/>
      <url>/192.html</url>
      
        <content type="html"><![CDATA[<h2 id="单行文本的溢出"><a href="#单行文本的溢出" class="headerlink" title="单行文本的溢出"></a>单行文本的溢出</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.flqin.com/p192-1.png" alt="单行文本的溢出"></p><h2 id="多行文本的溢出"><a href="#多行文本的溢出" class="headerlink" title="多行文本的溢出"></a>多行文本的溢出</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical;</span><br><span class="line">  <span class="attribute">-webkit-line-clamp</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.flqin.com/p192-2.png" alt="方法一"></p><ul><li><code>display: -webkit-box;</code> 必须结合的属性，将对象作为弹性伸缩盒子模型显示.</li><li><code>-webkit-box-orient</code> 必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式.</li><li><code>-webkit-line-clamp</code> 用来限制在一个块元素显示的文本的行数。</li></ul><p>适用范围：因使用了 <code>WebKit</code> 的 <code>CSS</code> 扩展属性，该方法适用于 <code>WebKit</code> 浏览器及移动端。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'...'</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, transparent, #fff 55%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.flqin.com/p192-3.png" alt="方法二"></p><ul><li>将 <code>height</code> 设置为 <code>line-height</code> 的整数倍，防止超出的文字露出。</li><li>给 <code>p::after</code> 添加渐变背景可避免文字只显示一半。</li><li>由于 <code>ie6-7</code> 不显示 <code>content</code> 内容，所以要添加标签兼容 <code>ie6-7</code>（如：<code>…</code>）；兼容 <code>ie8</code> 需要将 <code>::after</code> 替换成 <code>:after</code>。</li></ul><p>适用范围：该方法适用范围广，但文字未超出行的情况下也会出现省略号,可结合 <code>js</code> 优化该方法。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）CSS选择器的权重与优先规则</title>
      <link href="/189.html"/>
      <url>/189.html</url>
      
        <content type="html"><![CDATA[<p>我们在使用 <code>CSS</code> 对网页元素定义样式时经常会遇到这种情况：要对一般元素应用一般样式，然后在更特殊的元素上覆盖它们。那么我们怎么样来保证我们所新定义的元素样式能覆盖目标元素上原有的样式呢？</p><p>在 <code>CSS</code> 中，会根据选择器的特殊性来决定所定义的样式规则的次序，具有更特殊选择器的规则优先于具有一般选择器的规则，如果两个规则的特殊性相同，那么后定义的规则优先。</p><p>那么，又怎么来计算选择器的特殊性呢？下面这张图介绍了特殊性的计算方法：</p><p><img src="http://cdn.flqin.com/p189-1.jpg" alt="选择器权值"></p><p>我们把特殊性分为 4 个等级，每个等级代表一类选择器，每个等级的值为其所代表的选择器的个数乘以这一等级的权值，最后把所有等级的值相加得出选择器的特殊值。</p><p>4 个等级的定义如下：</p><ul><li>第一等：代表内联样式，如：<code>style=””</code>，权值为 1000。</li><li>第二等：代表 <code>ID</code> 选择器，如：<code>#content</code>，权值为 100。</li><li>第三等：代表类，伪类和属性选择器，如： <code>.content</code>，权值为 10。</li><li>第四等：代表类型选择器和伪元素选择器，如： <code>div p</code>，权值为 1。</li></ul><p>例如上图为例，其中 <code>#NAV</code> 为二等选择器，<code>.ACTIVE</code> 为三等选择器，<code>UL</code>、<code>LI</code> 和 <code>A</code> 为四等选择器。则整个选择器表达式的特殊性的值为 <code>1_100+1_10+3\*1=113</code></p><p>下面是一些计算示例：</p><p><img src="http://cdn.flqin.com/p189-2.jpg" alt="计算示例"></p><p>注意：通用选择器（<code>*</code>），子选择器（<code>&gt;</code>）和相邻同胞选择器（<code>+</code>）并不在这四个等级中，所以他们的权值都为 <code>0</code>。</p><p>我们再来看一个具体的例子：假如有以下组样式规则，你能判断出 <code>HTML</code> 代码中的两个标题是什么颜色吗？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">div</span><span class="selector-id">#main-content</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#content</span> <span class="selector-id">#main-content</span> &gt; <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> <span class="selector-id">#content</span> <span class="selector-tag">div</span><span class="selector-attr">[id='main-content']</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main-content</span> <span class="selector-tag">div</span><span class="selector-class">.paragraph</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main-content</span> <span class="selector-attr">[class='paragraph']</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#main-content</span> <span class="selector-tag">div</span><span class="selector-class">.paragraph</span> <span class="selector-tag">h2</span><span class="selector-class">.first</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是 HTML 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main-content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>CSS简介<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>CSS（Cascading Style Sheet，可译为“层叠样式表”或“级联样式表”）是一组格式设置规则，用于控制Web页面的外观。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"paragraph"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"first"</span>&gt;</span>使用CSS布局的优点<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>1、表现和内容相分离 2、提高页面浏览速度 3、易于维护和改版 4、使用CSS布局更符合现在的W3C标准.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>判断出来了么？答案是：两个标题都是红色的！</p><p>让我们来一起算算六个样式规则各自的特殊性的值：</p><ul><li>第一个特殊性的值=<code>2_100+2_1=202</code></li><li>第二个特殊性的值=<code>2\*100+1=201</code></li><li>第三个特殊性的值=<code>1_100+1_10+3\*1=113</code></li><li>第四个特殊性的值=<code>1_100+1_10+2\*1=112</code></li><li>第五个特殊性的值=<code>1_100+1_10+1\*1=111</code></li><li>第六个特殊性的值=<code>1_100+2_10+3\*1=123</code></li></ul><p>清楚了吧，第一个样式规则以其 <code>202</code> 的高分一举夺得了本次样式选择器特殊性大赛的冠军，后面一些规则虽然看起来好像更复杂，但特殊性并不是拼谁的选择器表达式写得更长，<code>ID</code> 选择器才是王道！</p><p>理解选择器的特殊性很重要，特别是在修复 <code>bug</code> 的时候，因为你需要了解哪些规则优先及其原因。</p><p>如果你遇到了似乎没有起作用的 <code>CSS</code> 规则，很可能是出现了特殊性冲突。请在你的选择器中添加他的一个父元素的 <code>ID</code>，从而提高它的特殊性。如果这能解决问题，就说明样式表中其他地方很可能有更特殊的规则，它覆盖了你的规则。如果是这种情况，你可能需要检查代码，解决特殊性冲突，让代码尽可能简洁。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）CSS3中:nth-child和:nth-of-type的区别深入理解</title>
      <link href="/184.html"/>
      <url>/184.html</url>
      
        <content type="html"><![CDATA[<p><code>:nth-child</code> 可以选择父元素下的字元素，<code>:nth-of-type</code> 也可以。但是它们到底有什么区别呢？</p><p>其实区别很简单：<code>:nth-of-type</code> 为什么要叫 <code>:nth-of-type</code>？因为它是以”<code>type</code>“来区分的。也就是说：<code>ele:nth-of-type(n)</code>是指父元素下第 <code>n</code> 个 <code>ele</code> 元素，</p><p>而 <code>ele:nth-child(n)</code> 是指父元素下第 <code>n</code> 个元素且这个元素为 <code>ele</code>，若不是，则选择失败。</p><p>eg:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>zero<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>one<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这个例子，<code>.demo li:nth-child(2)</code> 选择的是 <code>&lt;li&gt;one&lt;/li&gt;</code> 节点，而 <code>.demo li:nth-of-type(2)</code> 则选择的是 <code>&lt;li&gt;two&lt;/li&gt;</code> 节点。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css3 media媒体查询器用法总结</title>
      <link href="/180.html"/>
      <url>/180.html</url>
      
        <content type="html"><![CDATA[<p>随着响应式设计模型的诞生，Web 网站又要发生翻天腹地的改革浪潮，可能有些人会觉得在国内 IE6 用户居高不下的情况下，这些新的技术还不会广泛的蔓延下去，那你就错了，如今淘宝，凡客，携程等等公司都已经在大胆的尝试了这项技术，并完美的应用在了自己的网站上了。再不更新知识你就老了。我今天就总结一下响应式设计的核心 CSS 技术 Media(媒体查询器)的用法。</p><h2 id="准备工作-1：设置-Meta-标签"><a href="#准备工作-1：设置-Meta-标签" class="headerlink" title="准备工作 1：设置 Meta 标签"></a>准备工作 1：设置 Meta 标签</h2><p>首先我们在使用 Media 的时候需要先设置下面这段代码，来兼容移动设备的展示效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码的几个参数解释：</p><ul><li><code>width = device-width</code>：宽度等于当前设备的宽度</li><li><code>initial-scale</code>：初始的缩放比例（默认设置为 1.0）</li><li><code>minimum-scale</code>：允许用户缩放到的最小比例（默认设置为 1.0）</li><li><code>maximum-scale</code>：允许用户缩放到的最大比例（默认设置为 1.0）</li><li><code>user-scalable</code>：用户是否可以手动缩放（默认设置为 no，因为我们不希望用户放大缩小页面）</li></ul><h2 id="准备工作-2：加载兼容文件-JS"><a href="#准备工作-2：加载兼容文件-JS" class="headerlink" title="准备工作 2：加载兼容文件 JS"></a>准备工作 2：加载兼容文件 JS</h2><p>因为 <code>IE8</code> 既不支持 <code>HTML5</code> 也不支持 <code>CSS3 Media</code>，所以我们需要加载两个 <code>JS</code> 文件，来保证我们的代码实现兼容效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">  &lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">  &lt;script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="准备工作-3：设置-IE-渲染方式默认为最高-这部分可以选择添加也可以不添加"><a href="#准备工作-3：设置-IE-渲染方式默认为最高-这部分可以选择添加也可以不添加" class="headerlink" title="准备工作 3：设置 IE 渲染方式默认为最高(这部分可以选择添加也可以不添加)"></a>准备工作 3：设置 IE 渲染方式默认为最高(这部分可以选择添加也可以不添加)</h2><p>现在有很多人的 IE 浏览器都升级到 IE9 以上了，所以这个时候就有又很多诡异的事情发生了，例如现在是 IE9 的浏览器，但是浏览器的文档模式却是 IE8。 为了防止这种情况，我们需要下面这段代码来让 IE 的文档模式永远都是最新的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>太给力了。 不过我最近又发现了一个更给力的写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=Edge，chrome=1"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>怎么这段代码后面加了一个 <code>chrome=1</code>，这个 Google Chrome Frame（谷歌内嵌浏览器框架 GCF），如果有的用户电脑里面装了这个 chrome 的插件，就可以让电脑里面的 IE 不管是哪个版本的都可以使用 Webkit 引擎及 V8 引擎进行排版及运算，无比给力，不过如果用户没装这个插件，那这段代码就会让 IE 以最高的文档模式展现效果。这段代码我还是建议你们用上，不过不用也是可以的。</p><h2 id="进入-CSS3-Media-写法"><a href="#进入-CSS3-Media-写法" class="headerlink" title="进入 CSS3 Media 写法"></a>进入 CSS3 Media 写法</h2><p>我们先来看下下面这段代码，估计很多人在响应式的网站 CSS 很经常看到类似下面的这段代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">960px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个应该算是一个 media 的一个标准写法，上面这段 CSS 代码意思是：当页面小于 960px 的时候执行它下面的 CSS.这个应该没有太大疑问。</p><p>应该有人会发现上面这段代码里面有个 screen，他的意思是在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。但是目前我发现很多网站都会直接省略 screen,因为你的网站可能不需要考虑用户去打印时，你可以直接这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> (max-width: <span class="number">960px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS2-Media-用法"><a href="#CSS2-Media-用法" class="headerlink" title="CSS2 Media 用法"></a>CSS2 Media 用法</h2><p>其实并不是只有 CSS3 才支持 Media 的用法，早在 CSS2 开始就已经支持 Media，具体用法，就是在 HTML 页面的 head 标签中插入如下的一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"screen"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>上面其实是 CSS2 实现的衬线用法，那 CSS3 的 media 难道就只能支持上面这一个功能吗？答案当然不是，他还有很多用法。 例如我们想知道现在的移动设备是不是纵向放置的显示屏，可以这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"screen and (orientation:portrait)"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>我们把第一段的代码也用 CSS2 来实现，让它一样可以让页面宽度小于 960 的执行指定的样式文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"screen and (max-width:960px)"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>既然 CSS2 可以实现 CSS 的这个效果为什么不用这个方法呢，很多人应该会问，但是上面这个方法，最大的弊端是他会增加页面 http 的请求次数，增加了页面负担，我们用 CSS3 把样式都写在一个文件里面才是最佳的方法。</p><h2 id="回归-CSS3-Media"><a href="#回归-CSS3-Media" class="headerlink" title="回归 CSS3 Media"></a>回归 CSS3 Media</h2><p>上面我们大概讲了下 CSS2 的媒体查询用法，现在我们重新回到 CSS3 的媒体查询，在第一段代码上面我用的是小于 960px 的尺寸的写法，那现在我们来实现等于 960px 尺寸的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-device-width: <span class="number">960px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是当浏览器尺寸大于 960px 时候的代码了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">960px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: orange;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以混合使用上面的用法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">960px</span>) and (max-width: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这段代码的意思是当页面宽度大于 960px 小于 1200px 的时候执行下面的 CSS。</p><h2 id="Media-所有参数汇总"><a href="#Media-所有参数汇总" class="headerlink" title="Media 所有参数汇总"></a>Media 所有参数汇总</h2><p>以上就是我们最常需要用到的媒体查询器的三个特性，大于，等于，小于的写法。媒体查询器的全部功能肯定不止这三个功能，下面是我总结的它的一些参数用法解释：</p><ul><li><code>width</code>:浏览器可视宽度。</li><li><code>height</code>:浏览器可视高度。</li><li><code>device-width</code>:设备屏幕的宽度。</li><li><code>device-height</code>:设备屏幕的高度。</li><li><code>orientation</code>:检测设备目前处于横向还是纵向状态。</li><li><code>aspect-ratio</code>:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9)</li><li><code>device-aspect-ratio</code>:检测设备的宽度和高度的比例。</li><li><code>color</code>:检测颜色的位数。（例如：min-color:32 就会检测设备是否拥有 32 位颜色）</li><li><code>color-index</code>:检查设备颜色索引表中的颜色，他的值不能是负数。</li><li><code>monochrome</code>:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到）</li><li><code>resolution</code>:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi 或 min-resolution:118dpcm)。</li><li><code>grid</code>：检测输出的设备是网格的还是位图设备。</li></ul>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）搞清clientHeight、scrollHeight、offsetHeight和scrollTop的区别与联系</title>
      <link href="/178.html"/>
      <url>/178.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://cdn.flqin.com/body.jpg" alt="clientHeight、scrollHeight、offsetHeight和scrollTop的区别与联系"></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试屏幕宽高</title>
      <link href="/174.html"/>
      <url>/174.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.flqin.com/demo/screen-test.html" target="_blank" rel="noopener">点此测试</a></p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML中_等6种空白空格的区别</title>
      <link href="/167.html"/>
      <url>/167.html</url>
      
        <content type="html"><![CDATA[<p><code>HTML</code> 提供了 5 种空格实体（<code>space entity</code>），它们拥有不同的宽度，非断行空格（<code>&amp;nbsp;</code>）是常规空格的宽度，可运行于所有主流浏览器。其他几种空格（<code>&amp;ensp; &amp;emsp; &amp;thinsp; &amp;zwnj; &amp;zwj;</code>）在不同浏览器中宽度各异。</p><h2 id="amp-nbsp"><a href="#amp-nbsp" class="headerlink" title="&amp;nbsp;"></a><code>&amp;nbsp;</code></h2><p>它叫<strong>不换行空格</strong>，全称 No-Break Space，它是最常见和我们使用最多的空格，大多数的人可能只接触了  ，它是按下 space 键产生的空格。在 HTML 中，如果你用空格键产生此空格，空格是不会累加的（只算 1 个）。要使用 html 实体表示才可累加，该空格占据宽度受字体影响明显而强烈。</p><h2 id="amp-ensp"><a href="#amp-ensp" class="headerlink" title="&amp;ensp;"></a><code>&amp;ensp;</code></h2><p>它叫<strong>半角空格</strong>，全称是 En Space，en 是字体排印学的计量单位，为 em 宽度的一半。根据定义，它等同于字体度的一半（如 16px 字体中就是 8px）。名义上是小写字母 n 的宽度。此空格传承空格家族一贯的特性：透明的，此空格有个相当稳健的特性，就是其占据的宽度正好是 1/2 个中文宽度，而且基本上不受字体影响。</p><h2 id="amp-emsp"><a href="#amp-emsp" class="headerlink" title="&amp;emsp;"></a><code>&amp;emsp;</code></h2><p>它叫<strong>全角空格</strong>，全称是 Em Space，em 是字体排印学的计量单位，相当于当前指定的点数。例如，1 em 在 16px 的字体中就是 16px。此空格也传承空格家族一贯的特性：透明的，此空格也有个相当稳健的特性，就是其占据的宽度正好是 1 个中文宽度，而且基本上不受字体影响。</p><h2 id="amp-thinsp"><a href="#amp-thinsp" class="headerlink" title="&amp;thinsp;"></a><code>&amp;thinsp;</code></h2><p>它叫<strong>窄空格</strong>，全称是 Thin Space。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。它是 em 之六分之一宽。</p><h2 id="amp-zwnj"><a href="#amp-zwnj" class="headerlink" title="&amp;zwnj;"></a><code>&amp;zwnj;</code></h2><p>它叫<strong>零宽不连字</strong>，全称是 Zero Width Non Joiner，简称“ZWNJ”，是一个不打印字符，放在电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制。 ‌</p><h2 id="amp-zwj"><a href="#amp-zwj" class="headerlink" title="&amp;zwj;"></a><code>&amp;zwj;</code></h2><p>它叫<strong>零宽连字</strong>，全称是 Zero Width Joiner，简称“ZWJ”，是一个不打印字符，放在某些需要复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果。</p><p>此外，浏览器还会把以下字符当作空白进行解析：空格（<code>&amp;#x0020;</code>）、制表位（<code>&amp;#x0009;</code>）、换行（<code>&amp;#x000A;</code>）和回车（<code>&amp;#x000D;</code>）还有（<code>&amp;#12288;</code>）等等。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）IE6/IE7/IE8/IE9/FF的CSS Hacks</title>
      <link href="/158.html"/>
      <url>/158.html</url>
      
        <content type="html"><![CDATA[<h2 id="IE6-IE7-FF-的-CSS-Hacks"><a href="#IE6-IE7-FF-的-CSS-Hacks" class="headerlink" title="IE6/IE7/FF 的 CSS Hacks"></a>IE6/IE7/FF 的 CSS Hacks</h2><h3 id="区别-IE-和非-IE-浏览器"><a href="#区别-IE-和非-IE-浏览器" class="headerlink" title="区别 IE 和非 IE 浏览器"></a>区别 IE 和非 IE 浏览器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue; <span class="comment">/*非IE 背景藍色*/</span></span><br><span class="line">  <span class="attribute">background</span>: red \<span class="number">9</span>; <span class="comment">/*IE6、IE7、IE8背景紅色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区别-IE6-IE7-IE8-FF"><a href="#区别-IE6-IE7-IE8-FF" class="headerlink" title="区别 IE6,IE7,IE8,FF"></a>区别 IE6,IE7,IE8,FF</h3><p>【区别符号】：<code>\9</code>、<code>*</code>、<code>_</code></p><p>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue; <span class="comment">/*Firefox 背景变蓝色*/</span></span><br><span class="line">  <span class="attribute">background</span>: red \<span class="number">9</span>; <span class="comment">/*IE8 背景变红色*/</span></span><br><span class="line">  *background: black; /*IE7 背景变黑色*/</span><br><span class="line">  _<span class="selector-tag">background</span>: <span class="selector-tag">range</span>; <span class="comment">/*IE6 背景变橘色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：因为 IE 系列浏览器可读<code>\9</code>，而 IE6 和 IE7 可读 <code>*</code>(米字号)，另外 IE6 可辨识 <code>_</code>(底线)，因此可以依照顺序写下来，就会让浏 览器正确的读取到自己看得懂得 CSS 语法，所以就可以有效区分 IE 各版本和非 IE 浏览器(像是 Firefox、Opera、Google Chrome、Safari 等)。</p><h3 id="区别-IE6、IE7、Firefox-方法-1"><a href="#区别-IE6、IE7、Firefox-方法-1" class="headerlink" title="区别 IE6、IE7、Firefox (方法 1)"></a>区别 IE6、IE7、Firefox (方法 1)</h3><p>【区别符号】：<code>*</code>、<code>_</code><br>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue; <span class="comment">/*Firefox背景变蓝色*/</span></span><br><span class="line">  *background: black; /*IE7 背景变黑色*/</span><br><span class="line">  _<span class="selector-tag">background</span>: <span class="selector-tag">orange</span>; <span class="comment">/*IE6 背景变橘色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：IE7 和 IE6 可读 <code>*</code>(米字号)，IE6 又可以读 <code>_</code>(底线)，但是 IE7 却无法读取 <code>_</code>，至于 Firefox(非 IE 浏览器)则完全无法辨识 <code>*</code> 和 <code>_</code>，因此就可以透过这样的差异性来区分 IE6、IE7、Firefox。</p><h3 id="区别-IE6、IE7、Firefox-方法-2"><a href="#区别-IE6、IE7、Firefox-方法-2" class="headerlink" title="区别 IE6、IE7、Firefox (方法 2)"></a>区别 IE6、IE7、Firefox (方法 2)</h3><p>【区别符号】：<code>*</code>、<code>!important</code><br>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue; <span class="comment">/*Firefox 背景变蓝色*/</span></span><br><span class="line">  *background: green !important; /*IE7 背景变绿色*/</span><br><span class="line">  *<span class="selector-tag">background</span>: <span class="selector-tag">orange</span>; <span class="comment">/*IE6 背景变橘色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：IE7 可以辨识 <code>*</code> 和 <code>!important</code>，但是 IE6 只可以辨识 <code>*</code>，却无法辨识 <code>!important</code>，至于 Firefox 可以读取 <code>!important</code> 但不能辨识 <code>*</code> 因此可以透过这样的差异来有效区隔 IE6、IE7、Firefox。</p><h3 id="区别-IE7、Firefox"><a href="#区别-IE7、Firefox" class="headerlink" title="区别 IE7、Firefox"></a>区别 IE7、Firefox</h3><p>【区别符号】：<code>*</code>、<code>!important</code><br>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue; <span class="comment">/*Firefox 背景变蓝色*/</span></span><br><span class="line">  *background: green !important; /*IE7 背景变绿色*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：因为 Firefox 可以辨识<code>!important</code> 但却无法辨识 <code>*</code>，而 IE7 则可以同时看懂 <code>_</code>、<code>!important</code>，因此可以两个辨识符号来区隔 IE7 和 Firefox。</p><h3 id="区别-IE6、IE7-方法-1"><a href="#区别-IE6、IE7-方法-1" class="headerlink" title="区别 IE6、IE7 (方法 1)"></a>区别 IE6、IE7 (方法 1)</h3><p>【区别符号】：<code>*</code>、<code>_</code><br>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  *background: black; /*IE7 背景变黑色*/</span><br><span class="line">  _<span class="selector-tag">background</span>: <span class="selector-tag">orange</span>; <span class="comment">/*IE6 背景变橘色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：IE7 和 IE6 都可以辨识 <code>*</code>(米字号)，但 IE6 可以辨识 <code>_</code>(底线)，IE7 却无法辨识，透过 IE7 无法读取 <code>_</code> 的特性就能轻鬆区隔 IE6 和 IE7 之间的差异。</p><h3 id="区别-IE6、IE7-方法-2"><a href="#区别-IE6、IE7-方法-2" class="headerlink" title="区别 IE6、IE7 (方法 2)"></a>区别 IE6、IE7 (方法 2)</h3><p>【区别符号】：<code>!important</code><br>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: black <span class="meta">!important</span>; <span class="comment">/*IE7 背景变黑色*/</span></span><br><span class="line">  <span class="attribute">background</span>: orange; <span class="comment">/*IE6 背景变橘色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：因为 IE7 可读取 <code>!important;</code> 但 IE6 却不行，而 CSS 的读取步骤是从上到下，因此 IE6 读取时因无法辨识 <code>!important</code> 而直接跳到下一行读取 CSS，所以背景色会呈现橘色。</p><h3 id="区别-IE6、Firefox"><a href="#区别-IE6、Firefox" class="headerlink" title="区别 IE6、Firefox"></a>区别 IE6、Firefox</h3><p>【区别符号】：<code>_</code><br>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: black; <span class="comment">/*Firefox 背景变黑色*/</span></span><br><span class="line">  <span class="attribute">_background</span>: orange; <span class="comment">/*IE6 背景变橘色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：因为 IE6 可以辨识 <code>_</code>(底线)，但是 Firefox 却不行，因此可以透过这样的差异来区隔 Firefox 和 IE6，有效达成 CSS hack。</p><h3 id="IE-6-ONLY"><a href="#IE-6-ONLY" class="headerlink" title="IE-6 ONLY"></a>IE-6 ONLY</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* <span class="selector-tag">html</span> <span class="selector-id">#div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NON-IE-7-ONLY"><a href="#NON-IE-7-ONLY" class="headerlink" title="NON IE-7 ONLY"></a>NON IE-7 ONLY</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div</span> &#123;</span><br><span class="line">  <span class="attribute">_height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hide-from-IE-6-and-LOWER"><a href="#Hide-from-IE-6-and-LOWER" class="headerlink" title="Hide from IE 6 and LOWER"></a>Hide from IE 6 and LOWER</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div</span> &#123;</span><br><span class="line">  height/**/: 300px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span> &gt; <span class="selector-tag">body</span> <span class="selector-id">#div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浏览器专属-CSS-Hack-区分-Firefox-Opera-Safari-Internet-Explorer"><a href="#浏览器专属-CSS-Hack-区分-Firefox-Opera-Safari-Internet-Explorer" class="headerlink" title="浏览器专属 CSS Hack:区分 Firefox / Opera / Safari / Internet Explorer"></a>浏览器专属 CSS Hack:区分 Firefox / Opera / Safari / Internet Explorer</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Opera */</span></span><br><span class="line"><span class="selector-tag">html</span><span class="selector-pseudo">:first-child</span> <span class="selector-id">#opera</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* IE 7 */</span></span><br><span class="line">*<span class="selector-pseudo">:first-child</span> + <span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* IE 7 */</span></span><br><span class="line"><span class="selector-tag">html</span> &gt; <span class="selector-tag">body</span> <span class="selector-id">#ie7</span> &#123;</span><br><span class="line">  *display: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* IE 6 */</span></span><br><span class="line">* <span class="selector-tag">html</span> <span class="selector-id">#div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* IE 6 */</span></span><br><span class="line"><span class="selector-tag">body</span> <span class="selector-id">#ie6</span> &#123;</span><br><span class="line">  <span class="attribute">_display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*IE7及其更低版本*/</span></span><br><span class="line">*<span class="selector-pseudo">:first-child</span> + <span class="selector-tag">html</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">*<span class="selector-tag">html</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*IE7,IE7以上和主流浏览器*/</span></span><br><span class="line"><span class="selector-tag">html</span> &gt; <span class="selector-tag">body</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*适合主流浏览器(IE7排除在外，IE7以下的也不行)*/</span></span><br><span class="line"><span class="selector-tag">html</span>&gt;<span class="comment">/**/</span><span class="selector-tag">body</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Firefox 1 - 2 */</span></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:empty</span> <span class="selector-id">#firefox12</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Firefox */</span></span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">document</span> url-prefix() &#123;</span><br><span class="line">  <span class="selector-id">#firefox</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Safari */</span></span><br><span class="line">@<span class="keyword">media</span> screen and (-webkit-min-device-pixel-ratio: <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="selector-id">#safari</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Opera */</span></span><br><span class="line">@<span class="keyword">media</span> all and (-webkit-min-device-pixel-ratio: <span class="number">10000</span>), not all and (-webkit-min-device-pixel-ratio: <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="selector-tag">head</span> ~ <span class="selector-tag">body</span> <span class="selector-id">#opera</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最新的浏览器-CSS-Hacks"><a href="#最新的浏览器-CSS-Hacks" class="headerlink" title="最新的浏览器 CSS Hacks"></a>最新的浏览器 CSS Hacks</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IE6 and below */</span></span><br><span class="line">* <span class="selector-tag">html</span> <span class="selector-id">#uno</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE7 */</span></span><br><span class="line">*<span class="selector-pseudo">:first-child</span> + <span class="selector-tag">html</span> <span class="selector-id">#dos</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">* + <span class="selector-tag">html</span> <span class="selector-id">#dieciocho</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Safari 2-3 */</span></span><br><span class="line"><span class="selector-tag">html</span><span class="selector-attr">[xmlns*='']</span> <span class="selector-tag">body</span><span class="selector-pseudo">:last-child</span> <span class="selector-id">#seis</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* webkit and opera */</span></span><br><span class="line">@<span class="keyword">media</span> all and (min-width: <span class="number">0px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.big</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">11px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* webkit */</span></span><br><span class="line">@<span class="keyword">media</span> screen and (-webkit-min-device-pixel-ratio: <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="selector-class">.big</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">11px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* opera */</span></span><br><span class="line">@<span class="keyword">media</span> all and (-webkit-min-device-pixel-ratio: <span class="number">10000</span>), not all and (-webkit-min-device-pixel-ratio: <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="selector-class">.big</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">11px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* firefox * /</span></span><br><span class="line"><span class="comment">    @-moz-document url-prefix()&#123; .big&#123;padding:11px;&#125;&#125; /* all firefox */</span></span><br><span class="line"><span class="selector-id">#veinticinco</span>,</span><br><span class="line"><span class="selector-tag">x</span><span class="selector-pseudo">:-moz-any-link</span>,</span><br><span class="line"><span class="selector-tag">x</span><span class="selector-pseudo">:default</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125; <span class="comment">/* Firefox 3.0+ */</span></span><br><span class="line"><span class="selector-tag">html</span>&gt;<span class="comment">/**/</span><span class="selector-tag">body</span> <span class="selector-class">.big</span>, <span class="selector-tag">x</span><span class="selector-pseudo">:-moz-any-link</span>, <span class="selector-tag">x</span><span class="selector-pseudo">:default</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">11px</span>;</span><br><span class="line">&#125; <span class="comment">/* newest firefox */</span></span><br></pre></td></tr></table></figure><p><img src="http://cdn.flqin.com/css-hack.png" alt="css-hack"></p><p><strong>ps</strong>：IE6 不支持 <code>!important</code>，是指不支持 <code>important</code> 的优先级，并不影响 <code>css</code> 属性值的解析。比如 <code>color:green!important;color:red;</code>，除了在 IE6 下字体颜色解析为红色，其他（你懂的）浏览器下都是绿色。</p>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）前端冷知识集锦</title>
      <link href="/131.html"/>
      <url>/131.html</url>
      
        <content type="html"><![CDATA[<p>前端已经被玩儿坏了！像 <code>console.log()</code> 可以向控制台输出图片等炫酷的玩意已经不是什么新闻了，像用||操作符给变量赋默认值也是人尽皆知的旧闻了，今天看到 Quora 上一个帖子，瞬间又 GET 了好多前端技能，一些属于技巧，一些则是闻所未闻的冷知识，一时间还消化不过来。现分类整理出来分享给大家，也补充了一些平时的积累和扩展了一些内容。</p><h2 id="HTML-篇"><a href="#HTML-篇" class="headerlink" title="HTML 篇"></a>HTML 篇</h2><h3 id="浏览器地址栏运行-JavaScript-代码"><a href="#浏览器地址栏运行-JavaScript-代码" class="headerlink" title="浏览器地址栏运行 JavaScript 代码"></a>浏览器地址栏运行 JavaScript 代码</h3><p>这个很多人应该还是知道的，在浏览器地址栏可以直接运行 <code>JavaScript</code> 代码，做法是以 <code>javascript:</code> 开头后跟要执行的语句。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript: alert(<span class="string">'hello from address bar :)'</span>);</span><br></pre></td></tr></table></figure><p>将以上代码贴到浏览器地址栏回车后 <code>alert</code> 正常执行，一个弹窗神现。</p><p>需要注意的是如果是通过 <code>copy paste</code> 代码到浏览器地址栏的话，IE 及 Chrome 会自动去掉代码开头的 <code>javascript:</code>，所以需要手动添加起来才能正确执行，而 Firefox 中虽然不会自动去掉，但它根本就不支持在地址栏运行 JS 代码，sigh~</p><h3 id="浏览器地址栏运行-HTML-代码"><a href="#浏览器地址栏运行-HTML-代码" class="headerlink" title="浏览器地址栏运行 HTML 代码"></a>浏览器地址栏运行 HTML 代码</h3><p>如果说上面那条小秘密知道的人还算多的话，这条秘笈知道的人就要少一些了，在非 IE 内核的浏览器地址栏可以直接运行 <code>HTML</code> 代码！</p><p>比如在地址栏输入以下代码然后回车运行，会出现指定的页面内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data:text/html,</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="可以把浏览器当编辑器"><a href="#可以把浏览器当编辑器" class="headerlink" title="可以把浏览器当编辑器"></a>可以把浏览器当编辑器</h3><p>还是浏览器地址栏上做文章，将以下代码贴到地址栏运行后浏览器变成了一个原始而简单的编辑器，与 <code>Windows</code> 自带的 <code>notepad</code> 一样，吼吼。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data:text/html,</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">contenteditable</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>归根结底多亏了 <code>HTML5</code> 中新加的 <code>contenteditable</code> 属性，当元素指定了该属性后，元素的内容成为可编辑状态。</p><p>推而广之，将以下代码放到 <code>console</code> 执行后，整个页面将变得可编辑，随意践踏吧~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.contentEditable = <span class="string">'true'</span>;</span><br></pre></td></tr></table></figure><h3 id="利用-a-标签自动解析-URL"><a href="#利用-a-标签自动解析-URL" class="headerlink" title="利用 a 标签自动解析 URL"></a>利用 a 标签自动解析 URL</h3><p>很多时候我们有从一个 <code>URL</code> 中提取域名，查询关键字，变量参数值等的需要，而万万没想到可以让浏览器方便地帮我们完成这一任务而不用我们写正则去抓取。方法就在 <code>JS</code> 代码里先创建一个 <code>a</code> 标签然后将需要解析的 <code>URL</code> 赋值给 <code>a</code> 的 <code>href</code> 属性，然后就得到了一切我们想要的了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">a.href = <span class="string">'http://www.cnblogs.com/wayou/p/'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.host);</span><br></pre></td></tr></table></figure><h3 id="页面拥有-ID-的元素会创建全局变量"><a href="#页面拥有-ID-的元素会创建全局变量" class="headerlink" title="页面拥有 ID 的元素会创建全局变量"></a>页面拥有 ID 的元素会创建全局变量</h3><p>在一张 <code>HTML</code> 页面中，所有设置了 <code>ID</code> 属性的元素会在 <code>JavaScript</code> 的执行环境中创建对应的全局变量，这意味着 <code>document.getElementById</code> 像人的阑尾一样显得多余了。但实际项目中最好老老实实该怎么写就怎么写，毕竟常规代码出乱子的机会要小得多。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sample"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(sample);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="加载-CDN-文件时，可以省掉-HTTP-标识"><a href="#加载-CDN-文件时，可以省掉-HTTP-标识" class="headerlink" title="加载 CDN 文件时，可以省掉 HTTP 标识"></a>加载 CDN 文件时，可以省掉 HTTP 标识</h3><p>现在很流行的 <code>CDN</code> 即从专门的服务器加载一些通用的 <code>JS</code> 和 <code>CSS</code> 文件，出于安全考虑有的 <code>CDN</code> 服务器使用 <code>HTTPS</code> 方式连接，而有的是传统的 <code>HTTP</code>，其实我们在使用时可以忽略掉这个，将它从 <code>URL</code> 中省去。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//domain.com/path/to/script.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用-script-标签保存任意信息"><a href="#利用-script-标签保存任意信息" class="headerlink" title="利用 script 标签保存任意信息"></a>利用 script 标签保存任意信息</h3><p>将 <code>script</code> 标签设置为 <code>type=&#39;text&#39;</code> 然后可以在里面保存任意信息，之后可以在 <code>JavaScript</code> 代码中很方便地获取。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"template"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This won't display<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.getElementById(<span class="string">'template'</span>).innerHTML;</span><br></pre></td></tr></table></figure><h2 id="CSS-篇"><a href="#CSS-篇" class="headerlink" title="CSS 篇"></a>CSS 篇</h2><h3 id="关于-CSS-的恶作剧"><a href="#关于-CSS-的恶作剧" class="headerlink" title="关于 CSS 的恶作剧"></a>关于 CSS 的恶作剧</h3><p>相信你看完以下代码后能够预料到会出现什么效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单的文字模糊效果"><a href="#简单的文字模糊效果" class="headerlink" title="简单的文字模糊效果"></a>简单的文字模糊效果</h3><p>以下两行简单的 CSS3 代码可达到将文字模糊化处理的目的，出来的效果有点像使用 PS 的滤镜，so cool!</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: transparent;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">#111</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重边框"><a href="#多重边框" class="headerlink" title="多重边框"></a>多重边框</h3><p>利用重复指定 box-shadow 来达到多个边框的效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*CSS Border with Box-Shadow Example*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6px</span> <span class="built_in">rgba</span>(0, 0, 0, 0.2), <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12px</span> <span class="built_in">rgba</span>(0, 0, 0, 0.2), <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">18px</span> <span class="built_in">rgba</span>(0, 0, 0, 0.2), <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">24px</span> <span class="built_in">rgba</span>(0, 0, 0, 0.2);</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实时编辑-CSS"><a href="#实时编辑-CSS" class="headerlink" title="实时编辑 CSS"></a>实时编辑 CSS</h3><p>通过设置 <code>style</code> 标签的 <code>display:block</code> 样式可以让页面的 <code>style</code> 标签显示出来，并且加上 <code>contentEditable</code> 属性后可以让样式成为可编辑状态，更改后的样式效果也是实时更新呈现的。此技巧在 IE 下无效。拥有此技能者，逆天也！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">style</span>=<span class="string">"display:block"</span> <span class="attr">contenteditable</span>&gt;</span></span><br><span class="line">      body &#123;</span><br><span class="line">        color: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建长宽比固定的元素"><a href="#创建长宽比固定的元素" class="headerlink" title="创建长宽比固定的元素"></a>创建长宽比固定的元素</h3><p>通过设置父级窗口的 <code>padding-bottom</code> 可以达到让容器保持一定的长度比的目的，这在响应式页面设计中比较有用，能够保持元素不变形。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100%; position: relative; padding-bottom: 20%;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: absolute; left: 0; top: 0; right: 0; bottom: 0;background-color:yellow;"</span>&gt;</span></span><br><span class="line">    this content will have a constant aspect ratio that varies based on the width.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS-中也可以做简单运算"><a href="#CSS-中也可以做简单运算" class="headerlink" title="CSS 中也可以做简单运算"></a>CSS 中也可以做简单运算</h3><p>通过 CSS 中的 <code>calc</code> 方法可以进行一些简单的运算，从而达到动态指定元素样式的目的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="built_in">calc</span>(100% - 50px) <span class="built_in">calc</span>(100% - 20px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaScript-篇"><a href="#JavaScript-篇" class="headerlink" title="JavaScript 篇"></a>JavaScript 篇</h2><h3 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h3><p>利用 <code>Math.random</code> 和 <code>toString</code> 生成随机字符串，来自前一阵子看到的一篇博文。这里的技巧是利用了 <code>toString</code> 方法可以接收一个基数作为参数的原理，这个基数从 2 到 36 封顶。如果不指定，默认基数是 10 进制。略屌！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateRandomAlphaNum</span>(<span class="params">len</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> rdmString = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (</span><br><span class="line">    ;</span><br><span class="line">    rdmString.length &lt; len;</span><br><span class="line">    rdmString += <span class="built_in">Math</span>.random()</span><br><span class="line">      .toString(<span class="number">36</span>)</span><br><span class="line">      .substr(<span class="number">2</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> rdmString.substr(<span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数的操作"><a href="#整数的操作" class="headerlink" title="整数的操作"></a>整数的操作</h3><p><code>JavaScript</code> 中是没有整型概念的，但利用好位操作符可以轻松处理，同时获得效率上的提升。</p><p><code>|0</code> 和 <code>~~</code> 是很好的一个例子，使用这两者可以将浮点转成整型且效率方面要比同类的 <code>parseInt</code>, <code>Math.round</code> 要快。在处理像素及动画位移等效果的时候会很有用。性能比较见此。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="number">12.4</span> / <span class="number">4.13</span>) | <span class="number">0</span>; <span class="comment">//结果为3</span></span><br><span class="line"><span class="keyword">var</span> bar = ~~(<span class="number">12.4</span> / <span class="number">4.13</span>); <span class="comment">//结果为3</span></span><br></pre></td></tr></table></figure><p>顺便说句， <code>!!</code> 将一个值方便快速转化为布尔值 <code>!!window===true</code>。</p><h3 id="重写原生浏览器方法以实现新功能"><a href="#重写原生浏览器方法以实现新功能" class="headerlink" title="重写原生浏览器方法以实现新功能"></a>重写原生浏览器方法以实现新功能</h3><p>下载的代码通过重写浏览器的 alert 让它可以记录弹窗的次数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldAlert = <span class="built_in">window</span>.alert,</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    oldAlert(a + <span class="string">"\n You've called alert "</span> + count + <span class="string">" times now. Stop, it's evil!"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">'Hello World'</span>);</span><br></pre></td></tr></table></figure><h3 id="关于-console-的恶作剧"><a href="#关于-console-的恶作剧" class="headerlink" title="关于 console 的恶作剧"></a>关于 console 的恶作剧</h3><p>关于重写原生方法，这里有个恶作剧大家可以拿去寻开心。Chrome 的 <code>console.log</code> 是支持对文字添加样式的，甚至 <code>log</code> 图片都可以。于是可以重写掉默认的 <code>log</code> 方法，把将要 <code>log</code> 的文字应用到 <code>CSS</code> 的模糊效果，这样当有人试图调用 <code>console.log()</code> 的时候，出来的是模糊不清的文字。好冷，我表示没有笑。</p><p>是从这篇 G+帖子的评论里看到的。使用之后的效果是再次调用 <code>log</code> 会输出字迹模糊不清的文字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _log = <span class="built_in">console</span>.log;</span><br><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _log.call(<span class="built_in">console</span>, <span class="string">'%c'</span> + [].slice.call(<span class="built_in">arguments</span>).join(<span class="string">' '</span>), <span class="string">'color:transparent;text-shadow:0 0 2px rgba(0,0,0,.5);'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不声明第三个变量的值交换"><a href="#不声明第三个变量的值交换" class="headerlink" title="不声明第三个变量的值交换"></a>不声明第三个变量的值交换</h3><p>我们都知道交换两个变量值的常规做法，那就是声明一个中间变量来暂存。但鲜有人去挑战不声明中间变量的情况，下面的代码给出了这种实现。蛮有创意的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">a = [b, (b = a)][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h3 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h3><p>在 <code>JavaScript</code> 的世界，万物皆对象。除了 <code>null</code> 和 <code>undefined</code>，其他基本类型数字，字符串和布尔值都有对应有包装对象。对象的一个特征是你可以在它身上直接调用方法。对于数字基本类型，当试图在其身上调用 <code>toString</code> 方法会失败，但用括号括起来后再调用就不会失败了，内部实现是用相应的包装对象将基本类型转为对象。所以 <code>(1).toString()</code> 相当于 <code>new Number(1).toString()</code>。因此，你的确可以把基本类型数字，字符串，布尔等当对象使用的，只是注意语法要得体。</p><p>同时我们注意到，<code>JavaScript</code> 中数字是不分浮点和整形的，所有数字其实均是浮点类型，只是把小数点省略了而以，比如你看到的 <code>1</code> 可以写成 <code>1.</code>，这也就是为什么当你试图 <code>1.toString()</code> 时会报错，所以正确的写法应该是这样：<code>1..toString()</code>，或者如上面所述加上括号，这里括号的作用是纠正 JS 解析器，不要把 <code>1</code> 后面的点当成小数点。内部实现如上面所述，是将 <code>1.</code> 用包装对象转成对象再调用方法。</p><h3 id="If-语句的变形"><a href="#If-语句的变形" class="headerlink" title="If 语句的变形"></a>If 语句的变形</h3><p>当你需要写一个 if 语句的时候，不妨尝试另一种更简便的方法，用 <code>JavaScript</code> 中的逻辑操作符来代替。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> day = <span class="keyword">new</span> <span class="built_in">Date</span>().getDay() === <span class="number">0</span>;</span><br><span class="line"><span class="comment">//传统if语句</span></span><br><span class="line"><span class="keyword">if</span> (day) &#123;</span><br><span class="line">  alert(<span class="string">'Today is Sunday!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运用逻辑与代替if</span></span><br><span class="line">day &amp;&amp; alert(<span class="string">'Today is Sunday!'</span>);</span><br></pre></td></tr></table></figure><p>比如上面的代码，首先得到今天的日期，如果是星期天，则弹窗，否则什么也不做。我们知道逻辑操作存在短路的情况，对于逻辑与表达式，只有两者都真才结果才为真，如果前面的 <code>day</code> 变量被判断为假了，那么对于整个与表达式来说结果就是假，所以就不会继续去执行后面的 <code>alert</code> 了，如果前面 <code>day</code> 为真，则还要继续执行后面的代码来确定整个表达式的真假。利用这点达到了 <code>if</code> 的效果。</p><p>对于传统的 <code>if</code> 语句，如果执行体代码超过了 1 条语句，则需要加花括号，而利用逗号表达式，可以执行任意条代码而不用加花括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (conditoin) alert(<span class="number">1</span>), alert(<span class="number">2</span>), <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上面 <code>if</code> 语句中，如果条件成立则执行三个操作，但我们不需要用花括号将这三句代码括起来。当然，这是不推荐的，这里是冷知识课堂:)</p><h3 id="禁止别人以-iframe-加载你的页面"><a href="#禁止别人以-iframe-加载你的页面" class="headerlink" title="禁止别人以 iframe 加载你的页面"></a>禁止别人以 iframe 加载你的页面</h3><p>下面的代码已经不言自明了，没什么好多说的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.location != <span class="built_in">window</span>.parent.location) <span class="built_in">window</span>.parent.location = <span class="built_in">window</span>.location;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）IE条件注释</title>
      <link href="/130.html"/>
      <url>/130.html</url>
      
        <content type="html"><![CDATA[<p>我们知道，IE6 的存在，因其预装于目前市场占有率最大的 Windows XP 操作系统。对于老态龙钟的 IE6，说拜拜还需要很长的时间。</p><p>IE 虽然给我们网页设计师，带来了不少多麻烦，还好，IE 条件注释，给我们解决浏览器兼容问题带来了一个很好的方法。</p><h2 id="什么是-IE-条件注释"><a href="#什么是-IE-条件注释" class="headerlink" title="什么是 IE 条件注释"></a>什么是 IE 条件注释</h2><p>IE 条件注释，顾名思义就是使用 IE 特有的条件语句来显示代码块。</p><p>这些巧妙的逻辑片段只能被 IE 浏览器所支持，其它的浏览器理解为纯粹的 HTML 注释，不起任何作用。条件注释在 IE5 中首次出现，并且得到了 Widnows 浏览器所有后续版本的支持。IE 条件注释及其有效，而且非常容易记住。通过这些技巧，我们可以为基于 Windows 的 IE5、6、7、8 添加一些特殊的行为。这样做的好处是，HTML 和 CSS 代码可以通过验证。主要的缺点是这些注释需要放在 HTML 页面中，而不是放在 CSS 中。这样，当你不需要这些东西，或者有所更改的时候，就需要维护很多的地方。好处是通过这种方式使用条件注释，可以很轻松的管理项目中的目标浏览器，并使得 CSS 补丁文件保持独立自由。更重要的是它帮助我们优化了 CSS 样式表，保证了主要样式表的干净，这对于大型网站来说就很重要了，也许你还没有感觉到它的可爱之处。</p><p>作为有 Web 标准意识的开发者，我们始终应该首先在大部分现有的兼容标准的浏览器上测试我们的设计，然后再为那些稍作细微修改就能回到正轨的浏览器提供补丁。</p><h2 id="条件注释使用方法"><a href="#条件注释使用方法" class="headerlink" title="条件注释使用方法"></a>条件注释使用方法</h2><h3 id="条件注释属性"><a href="#条件注释属性" class="headerlink" title="条件注释属性"></a>条件注释属性</h3><ul><li><strong>gt</strong> : greater than，选择条件版本以上版本，不包含条件版本</li><li><strong>lt</strong> : less than，选择条件版本以下版本，不包含条件版本</li><li><strong>gte</strong> : greater than or equal，选择条件版本以上版本，包含条件版本</li><li><strong>lte</strong> : less than or equal，选择条件版本以下版本，包含条件版本</li><li><strong>!</strong> : 选择条件版本以外所有版本，无论高低</li></ul><h3 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h3><p>我们概括性地说明一下你如何使用条件注释，首先，我们应该把你所有的 CSS 等 CSS 文件放在中。条件注释的基本结构和 HTML 的注释()是一样的。因此 ，IE 以外的浏览器将会把它们看 作是普通的注释而完全忽略它们。IE 将会根据 if 条件来判断是否如解析普通的页面内容一样解析条件注释里的内容。条件注释使用的是 HTML 的注释结构，因此他们只能使用在 HTML 文件里，而不能在 CSS 文件中使用。</p><h4 id="Target-ALL-VERSIONS-of-IE（-所有的-IE-可识别-）"><a href="#Target-ALL-VERSIONS-of-IE（-所有的-IE-可识别-）" class="headerlink" title="Target ALL VERSIONS of IE（ 所有的 IE 可识别 ）"></a>Target ALL VERSIONS of IE（ 所有的 IE 可识别 ）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if IE]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="all-ie-only.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-everything-EXCEPT-IE-（除-IE-外都可识别-）"><a href="#Target-everything-EXCEPT-IE-（除-IE-外都可识别-）" class="headerlink" title="Target everything EXCEPT IE （除 IE 外都可识别 ）"></a>Target everything EXCEPT IE （除 IE 外都可识别 ）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if !IE]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="not-ie.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-7-ONLY-（-仅-IE7-可识别-）"><a href="#Target-IE-7-ONLY-（-仅-IE7-可识别-）" class="headerlink" title="Target IE 7 ONLY （ 仅 IE7 可识别 ）"></a>Target IE 7 ONLY （ 仅 IE7 可识别 ）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if IE 7]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie7.css"&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-6-ONLY（仅-IE6-可识别）"><a href="#Target-IE-6-ONLY（仅-IE6-可识别）" class="headerlink" title="Target IE 6 ONLY（仅 IE6 可识别）"></a>Target IE 6 ONLY（仅 IE6 可识别）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if IE 6]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie6.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-5-ONLY（只有-IE5-可以识别）"><a href="#Target-IE-5-ONLY（只有-IE5-可以识别）" class="headerlink" title="Target IE 5 ONLY（只有 IE5 可以识别）"></a>Target IE 5 ONLY（只有 IE5 可以识别）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if IE 5]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie5.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-5-5-ONLY（只有-IE5-5-可以识别）"><a href="#Target-IE-5-5-ONLY（只有-IE5-5-可以识别）" class="headerlink" title="Target IE 5.5 ONLY（只有 IE5.5 可以识别）"></a>Target IE 5.5 ONLY（只有 IE5.5 可以识别）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if IE 5.5000]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie55.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-6-and-LOWER（IE6-和-IE6-以下的）"><a href="#Target-IE-6-and-LOWER（IE6-和-IE6-以下的）" class="headerlink" title="Target IE 6 and LOWER（IE6 和 IE6 以下的）"></a>Target IE 6 and LOWER（IE6 和 IE6 以下的）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if lt IE 7]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie6-and-down.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if lte IE 6]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie6-and-down.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line">`` #### Target IE 7 and LOWER（IE7 和 IE7 以下的） ```html</span><br><span class="line"><span class="comment">&lt;!-- [if lt IE 8]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie7-and-down.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if lte IE 7]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie7-and-down.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-8-and-LOWER（IE8-和-IE8-以下的）"><a href="#Target-IE-8-and-LOWER（IE8-和-IE8-以下的）" class="headerlink" title="Target IE 8 and LOWER（IE8 和 IE8 以下的）"></a>Target IE 8 and LOWER（IE8 和 IE8 以下的）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie8-and-down.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if lte IE 8]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie8-and-down.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-6-and-HIGHER（IE6-和-IE6-以上的）"><a href="#Target-IE-6-and-HIGHER（IE6-和-IE6-以上的）" class="headerlink" title="Target IE 6 and HIGHER（IE6 和 IE6 以上的）"></a>Target IE 6 and HIGHER（IE6 和 IE6 以上的）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if gt IE 5.5]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie6-and-up.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if gte IE 6]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie6-and-up.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-7-and-HIGHER（IE7-和-IE7-以上的）"><a href="#Target-IE-7-and-HIGHER（IE7-和-IE7-以上的）" class="headerlink" title="Target IE 7 and HIGHER（IE7 和 IE7 以上的）"></a>Target IE 7 and HIGHER（IE7 和 IE7 以上的）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if gt IE 6]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie7-and-up.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if gte IE 7]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie7-and-up.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-8-and-HIGHER（IE8-和-IE8-以上的）"><a href="#Target-IE-8-and-HIGHER（IE8-和-IE8-以上的）" class="headerlink" title="Target IE 8 and HIGHER（IE8 和 IE8 以上的）"></a>Target IE 8 and HIGHER（IE8 和 IE8 以上的）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if gt IE 7]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie8-and-up.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if gte IE 8]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" href="ie8-and-up.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt; ![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Universal-IE-6-CSS（通用的-IE-6-样式）"><a href="#Universal-IE-6-CSS（通用的-IE-6-样式）" class="headerlink" title="Universal IE 6 CSS（通用的 IE 6 样式）"></a>Universal IE 6 CSS（通用的 IE 6 样式）</h4><p>处理 IE 6 和 IE6 以下的版本始终是一个超特殊的挑战。老态龙钟的 IE6，还保持着高额的市场占有率，还不能彻底的放弃它，不然会有许多的客户抱怨我们。不过也有些人正在放弃对它的支持，包括大企业，大型网络应用，甚至政府。有一个不失落的 ，不放弃的 解决办法，那就是使用一个特精简的样式 universal IE 6 CSS.，然后为 IE 7 和以上（和所有其他浏览器）的应用常规的 CSS。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if !IE 6]&gt;&lt;!--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if gte IE 7]&gt;</span></span><br><span class="line"><span class="comment">       &lt;link rel="stylesheet" type="text/css" media="screen, projection" href="REGULAR-STYLESHEET.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt; ![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if lte IE 6]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel="stylesheet" type="text/css" media="screen, projection" href="http://universal-ie6-css.googlecode.com/files/ie6.0.3.css" /&gt;</span></span><br><span class="line"><span class="comment">    &lt; ![endif]--&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> detail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
